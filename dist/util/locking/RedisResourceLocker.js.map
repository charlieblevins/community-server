{"version":3,"file":"RedisResourceLocker.js","sourceRoot":"","sources":["../../../src/util/locking/RedisResourceLocker.ts"],"names":[],"mappings":";;;;;;AAAA,qCAAiC;AAEjC,iCAAqC;AAErC,sDAA8B;AAG9B,mDAAqD;AACrD,uEAAoE;AAGpE,sFAAsF;AACtF,MAAM,GAAG,GAAG,KAAK,CAAC;AAClB,6BAA6B;AAC7B,MAAM,oBAAoB,GAAG;IAC3B,6CAA6C;IAC7C,sCAAsC;IACtC,iDAAiD;IACjD,WAAW,EAAE,IAAI;IACjB,+CAA+C;IAC/C,qCAAqC;IACrC,UAAU,EAAE,OAAO;IACnB,kCAAkC;IAClC,UAAU,EAAE,GAAG;IACf,+CAA+C;IAC/C,+CAA+C;IAC/C,+DAA+D;IAC/D,WAAW,EAAE,GAAG;CACjB,CAAC;AACF;;;;;;;;;;GAUG;AACH,MAAa,mBAAmB;IAM9B,YAAmB,YAAsB,EAAE,cAAuC;QAL/D,WAAM,GAAG,sBAAY,CAAC,IAAI,CAAC,CAAC;QAM7C,IAAI,CAAC,OAAO,GAAG,IAAI,GAAG,EAAE,CAAC;QACzB,MAAM,OAAO,GAAG,IAAI,CAAC,kBAAkB,CAAC,YAAY,CAAC,CAAC;QACtD,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;YACxB,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC;SACzD;QACD,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,cAAc,CAAC,CAAC;QAC3D,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,aAAa,EAAE,CAAC,GAAG,EAAQ,EAAE;YAC3C,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,wBAAwB,GAAG,EAAE,CAAC,CAAC;QACnD,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;OAIG;IACK,kBAAkB,CAAC,mBAA6B;QACtD,MAAM,MAAM,GAAkB,EAAE,CAAC;QACjC,IAAI,mBAAmB,IAAI,mBAAmB,CAAC,MAAM,GAAG,CAAC,EAAE;YACzD,KAAK,MAAM,MAAM,IAAI,mBAAmB,EAAE;gBACxC,8CAA8C;gBAC9C,6EAA6E;gBAC7E,MAAM,KAAK,GAAG,IAAI,MAAM,CAAC,2BAA2B,EAAE,GAAG,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBACxE,IAAI,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;oBACvB,4CAA4C;oBAC5C,MAAM,IAAI,KAAK,CAAC,mDAAmD,MAAM;+GAC4B,CAAC,CAAC;iBACxG;gBACD,MAAM,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC9B,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBACtB,MAAM,WAAW,GAAG,oBAAY,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBAC7C,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;aAC1B;SACF;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;;;OAIG;IACK,aAAa,CAAC,OAAsB,EAAE,iBAAyC,EAAE;QACvF,IAAI;YACF,OAAO,IAAI,iBAAO,CAChB,OAAO,EACP,EAAE,GAAG,oBAAoB,EAAE,GAAG,cAAc,EAAE,CAC/C,CAAC;SACH;QAAC,OAAO,KAAc,EAAE;YACvB,MAAM,IAAI,yCAAmB,CAAC,+BAA+B,KAAK,EAAE,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC,CAAC;SACzF;IACH,CAAC;IAEM,KAAK,CAAC,QAAQ;QACnB,sCAAsC;QACtC,oGAAoG;QACpG,IAAI;YACF,KAAK,MAAM,CAAE,AAAD,EAAG,EAAE,IAAI,EAAE,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,EAAE;gBAClD,MAAM,IAAI,CAAC,OAAO,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;aAC7C;SACF;gBAAS;YACR,MAAM,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;SAC3B;IACH,CAAC;IAEM,KAAK,CAAC,OAAO,CAAC,UAA8B;QACjD,MAAM,QAAQ,GAAG,UAAU,CAAC,IAAI,CAAC;QACjC,IAAI,IAAsB,CAAC;QAC3B,IAAI;YACF,IAAI,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;YAC9C,gBAAM,CAAC,IAAI,CAAC,CAAC;SACd;QAAC,OAAO,KAAc,EAAE;YACvB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,8BAA8B,QAAQ,EAAE,CAAC,CAAC;YAC5D,MAAM,IAAI,yCAAmB,CAAC,8BAA8B,QAAQ,KAAK,KAAK,GAAG,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC,CAAC;SACtG;QACD,IAAI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;YAC9B,MAAM,IAAI,yCAAmB,CAAC,8BAA8B,QAAQ,EAAE,CAAC,CAAC;SACzE;QACD,gBAAgB;QAChB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,+BAA+B,QAAQ,GAAG,CAAC,CAAC;QAC9D,MAAM,QAAQ,GAAG,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC,CAAC;QACvD,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,EAAE,EAAE,IAAI,EAAE,QAAQ,EAAE,CAAC,CAAC;IACjD,CAAC;IAEM,KAAK,CAAC,OAAO,CAAC,UAA8B;QACjD,MAAM,QAAQ,GAAG,UAAU,CAAC,IAAI,CAAC;QACjC,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QACzC,IAAI,CAAC,KAAK,EAAE;YACV,kBAAkB;YAClB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,uDAAuD,QAAQ,EAAE,CAAC,CAAC;YACpF,MAAM,IAAI,yCAAmB,CAAC,iDAAiD,QAAQ,EAAE,CAAC,CAAC;SAC5F;QACD,IAAI;YACF,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YACtC,aAAa,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;YAC9B,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;YAC9B,6BAA6B;YAC7B,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,qBAAqB,QAAQ,KAAK,IAAI,CAAC,YAAY,EAAE,0BAA0B,CAAC,CAAC;SACpG;QAAC,OAAO,KAAc,EAAE;YACvB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,4BAA4B,QAAQ,KAAK,KAAK,GAAG,CAAC,CAAC;YACrE,MAAM,IAAI,yCAAmB,CAAC,+BAA+B,QAAQ,KAAK,KAAK,EAAE,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC,CAAC;SACtG;IACH,CAAC;IAED;;OAEG;IACK,YAAY;QAClB,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;IAC3B,CAAC;IAED;;;OAGG;IACK,sBAAsB,CAAC,UAAkB;QAC/C,OAAO,WAAW,CAAC,KAAK,IAAkB,EAAE;YAC1C,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,CAAE,CAAC;YAC5C,IAAI;gBACF,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;gBAC3D,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE,EAAE,IAAI,EAAE,OAAO,EAAE,QAAQ,EAAE,KAAK,CAAC,QAAQ,EAAE,CAAC,CAAC;gBAC1E,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,sCAAsC,UAAU,EAAE,CAAC,CAAC;aACvE;YAAC,OAAO,KAAc,EAAE;gBACvB,oFAAoF;gBACpF,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,mDAAmD,UAAU,KAAK,KAAK,EAAE,CAAC,CAAC;gBAC7F,aAAa,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;gBAC9B,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;aACjC;QACH,CAAC,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC;IACd,CAAC;CACF;AAzID,kDAyIC","sourcesContent":["import { assert } from 'console';\nimport type { RedisClient } from 'redis';\nimport { createClient } from 'redis';\nimport type { Lock } from 'redlock';\nimport Redlock from 'redlock';\nimport type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport type { Finalizable } from '../../init/final/Finalizable';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport { InternalServerError } from '../errors/InternalServerError';\nimport type { ResourceLocker } from './ResourceLocker';\n\n// The ttl set on a lock, not really important cause redlock wil not handle expiration\nconst ttl = 10000;\n// The default redlock config\nconst defaultRedlockConfig = {\n  // The expected clock drift; for more details\n  // see http://redis.io/topics/distlock\n  // Multiplied by lock ttl to determine drift time\n  driftFactor: 0.01,\n  // The max number of times Redlock will attempt\n  // to lock a resource before erroring\n  retryCount: 1000000,\n  // The time in ms between attempts\n  retryDelay: 200,\n  // The max time in ms randomly added to retries\n  // to improve performance under high contention\n  // see https://www.awsarchitectureblog.com/2015/03/backoff.html\n  retryJitter: 200,\n};\n/**\n * A locking system that uses a Redis server or any number of\n * Redis nodes / clusters\n * This solution has issues though:\n *  - Redlock wants to handle expiration itself, this is against the design of a ResourceLocker.\n *    The workaround for this is to extend an active lock indefinitely.\n *  - This solution is not multithreaded! If threadA locks a resource, only threadA can unlock this resource.\n *    If threadB wont be able to lock a resource if threadA already acquired that lock,\n *    in that sense it is kind of multithreaded.\n *  - Redlock does not provide the ability to see which locks have expired\n */\nexport class RedisResourceLocker implements ResourceLocker, Finalizable {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly redlock: Redlock;\n  private readonly lockMap: Map<string, { lock: Lock; interval: NodeJS.Timeout }>;\n\n  public constructor(redisClients: string[], redlockOptions?: Record<string, number>) {\n    this.lockMap = new Map();\n    const clients = this.createRedisClients(redisClients);\n    if (clients.length === 0) {\n      throw new Error('At least 1 client should be provided');\n    }\n    this.redlock = this.createRedlock(clients, redlockOptions);\n    this.redlock.on('clientError', (err): void => {\n      this.logger.error(`Redis/Redlock error: ${err}`);\n    });\n  }\n\n  /**\n   * Generate and return a list of RedisClients based on the provided strings\n   * @param redisClientsStrings - a list of strings that contain either a host address and a\n   * port number like '127.0.0.1:6379' or just a port number like '6379'\n   */\n  private createRedisClients(redisClientsStrings: string[]): RedisClient[] {\n    const result: RedisClient[] = [];\n    if (redisClientsStrings && redisClientsStrings.length > 0) {\n      for (const client of redisClientsStrings) {\n        // Check if port number or ip with port number\n        // Definitely not perfect, but configuring this is only for experienced users\n        const match = new RegExp(/^(?:([^:]+):)?(\\d{4,5})$/u, 'u').exec(client);\n        if (!match || !match[2]) {\n          // At least a port number should be provided\n          throw new Error(`Invalid data provided to create a Redis client: ${client}\\n\n            Please provide a port number like '6379' or a host address and a port number like '127.0.0.1:6379'`);\n        }\n        const port = Number(match[2]);\n        const host = match[1];\n        const redisclient = createClient(port, host);\n        result.push(redisclient);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Generate and return a Redlock instance\n   * @param clients - a list of RedisClients you want to use for the redlock instance\n   * @param redlockOptions - extra redlock options to overwrite the default config\n   */\n  private createRedlock(clients: RedisClient[], redlockOptions: Record<string, number> = {}): Redlock {\n    try {\n      return new Redlock(\n        clients,\n        { ...defaultRedlockConfig, ...redlockOptions },\n      );\n    } catch (error: unknown) {\n      throw new InternalServerError(`Error initializing Redlock: ${error}`, { cause: error });\n    }\n  }\n\n  public async finalize(): Promise<void> {\n    // This for loop is an extra failsafe,\n    // this extra code won't slow down anything, this function will only be called to shut down in peace\n    try {\n      for (const [ , { lock }] of this.lockMap.entries()) {\n        await this.release({ path: lock.resource });\n      }\n    } finally {\n      await this.redlock.quit();\n    }\n  }\n\n  public async acquire(identifier: ResourceIdentifier): Promise<void> {\n    const resource = identifier.path;\n    let lock: Lock | undefined;\n    try {\n      lock = await this.redlock.lock(resource, ttl);\n      assert(lock);\n    } catch (error: unknown) {\n      this.logger.debug(`Unable to acquire lock for ${resource}`);\n      throw new InternalServerError(`Unable to acquire lock for ${resource} (${error})`, { cause: error });\n    }\n    if (this.lockMap.get(resource)) {\n      throw new InternalServerError(`Acquired duplicate lock on ${resource}`);\n    }\n    // Lock acquired\n    this.logger.debug(`Acquired lock for resource: ${resource}!`);\n    const interval = this.extendLockIndefinitely(resource);\n    this.lockMap.set(resource, { lock, interval });\n  }\n\n  public async release(identifier: ResourceIdentifier): Promise<void> {\n    const resource = identifier.path;\n    const entry = this.lockMap.get(resource);\n    if (!entry) {\n      // Lock is invalid\n      this.logger.warn(`Unexpected release request for non-existent lock on ${resource}`);\n      throw new InternalServerError(`Trying to unlock resource that is not locked: ${resource}`);\n    }\n    try {\n      await this.redlock.unlock(entry.lock);\n      clearInterval(entry.interval);\n      this.lockMap.delete(resource);\n      // Successfully released lock\n      this.logger.debug(`Released lock for ${resource}, ${this.getLockCount()} active locks remaining!`);\n    } catch (error: unknown) {\n      this.logger.error(`Error releasing lock for ${resource} (${error})`);\n      throw new InternalServerError(`Unable to release lock for: ${resource}, ${error}`, { cause: error });\n    }\n  }\n\n  /**\n   * Counts the number of active locks.\n   */\n  private getLockCount(): number {\n    return this.lockMap.size;\n  }\n\n  /**\n   * This function is internally used to keep an acquired lock active, a wrapper class will handle expiration\n   * @param identifier - Identifier of the lock to be extended\n   */\n  private extendLockIndefinitely(identifier: string): NodeJS.Timeout {\n    return setInterval(async(): Promise<void> => {\n      const entry = this.lockMap.get(identifier)!;\n      try {\n        const newLock = await this.redlock.extend(entry.lock, ttl);\n        this.lockMap.set(identifier, { lock: newLock, interval: entry.interval });\n        this.logger.debug(`Extended (Redis)lock for resource: ${identifier}`);\n      } catch (error: unknown) {\n        // No error should be re-thrown because this means the lock has simply been released\n        this.logger.error(`Failed to extend this (Redis)lock for resource: ${identifier}, ${error}`);\n        clearInterval(entry.interval);\n        this.lockMap.delete(identifier);\n      }\n    }, ttl / 2);\n  }\n}\n"]}