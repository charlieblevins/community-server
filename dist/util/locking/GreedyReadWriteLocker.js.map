{"version":3,"file":"GreedyReadWriteLocker.js","sourceRoot":"","sources":["../../../src/util/locking/GreedyReadWriteLocker.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport type { KeyValueStorage } from '../../storage/keyvalue/KeyValueStorage';\nimport { ForbiddenHttpError } from '../errors/ForbiddenHttpError';\nimport { InternalServerError } from '../errors/InternalServerError';\nimport type { ReadWriteLocker } from './ReadWriteLocker';\nimport type { ResourceLocker } from './ResourceLocker';\n\nexport interface GreedyReadWriteSuffixes {\n  count: string;\n  read: string;\n  write: string;\n}\n\n/**\n * A {@link ReadWriteLocker} that allows for multiple simultaneous read operations.\n * Write operations will be blocked as long as read operations are not finished.\n * New read operations are allowed while this is going on, which will cause write operations to wait longer.\n *\n * Based on https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock#Using_two_mutexes .\n * As soon as 1 read lock request is made, the write lock is locked.\n * Internally a counter keeps track of the amount of active read locks.\n * Only when this number reaches 0 will the write lock be released again.\n * The internal read lock is only locked to increase/decrease this counter and is released afterwards.\n * This allows for multiple read operations, although only 1 at the time can update the counter,\n * which means there can still be a small waiting period if there are multiple simultaneous read operations.\n */\nexport class GreedyReadWriteLocker implements ReadWriteLocker {\n  private readonly locker: ResourceLocker;\n  private readonly storage: KeyValueStorage<string, number>;\n  private readonly suffixes: GreedyReadWriteSuffixes;\n\n  /**\n   * @param locker - Used for creating read and write locks.\n   * @param storage - Used for storing the amount of active read operations on a resource.\n   * @param suffixes - Used to generate identifiers with the given suffixes.\n   *                   `count` is used for the identifier used to store the counter.\n   *                   `read` and `write` are used for the 2 types of locks that are needed.\n   */\n  public constructor(locker: ResourceLocker, storage: KeyValueStorage<string, number>,\n    suffixes: GreedyReadWriteSuffixes = { count: 'count', read: 'read', write: 'write' }) {\n    this.locker = locker;\n    this.storage = storage;\n    this.suffixes = suffixes;\n  }\n\n  public async withReadLock<T>(identifier: ResourceIdentifier, whileLocked: () => (Promise<T> | T)): Promise<T> {\n    await this.preReadSetup(identifier);\n    try {\n      return await whileLocked();\n    } finally {\n      await this.postReadCleanup(identifier);\n    }\n  }\n\n  public async withWriteLock<T>(identifier: ResourceIdentifier, whileLocked: () => (Promise<T> | T)): Promise<T> {\n    if (identifier.path.endsWith(`.${this.suffixes.count}`)) {\n      throw new ForbiddenHttpError('This resource is used for internal purposes.');\n    }\n    const write = this.getWriteLockKey(identifier);\n    await this.locker.acquire(write);\n    try {\n      return await whileLocked();\n    } finally {\n      await this.locker.release(write);\n    }\n  }\n\n  /**\n   * This key is used for storing the count of active read operations.\n   */\n  private getCountKey(identifier: ResourceIdentifier): string {\n    return `${identifier.path}.${this.suffixes.count}`;\n  }\n\n  /**\n   * This is the identifier for the read lock: the lock that is used to safely update and read the count.\n   */\n  private getReadLockKey(identifier: ResourceIdentifier): ResourceIdentifier {\n    return { path: `${identifier.path}.${this.suffixes.read}` };\n  }\n\n  /**\n   * This is the identifier for the write lock, making sure there is at most 1 write operation active.\n   */\n  private getWriteLockKey(identifier: ResourceIdentifier): ResourceIdentifier {\n    return { path: `${identifier.path}.${this.suffixes.write}` };\n  }\n\n  /**\n   * Safely updates the count before starting a read operation.\n   */\n  private async preReadSetup(identifier: ResourceIdentifier): Promise<void> {\n    await this.withInternalReadLock(identifier, async(): Promise<void> => {\n      const count = await this.incrementCount(identifier, +1);\n      if (count === 1) {\n        // There is at least 1 read operation so write operations are blocked\n        const write = this.getWriteLockKey(identifier);\n        await this.locker.acquire(write);\n      }\n    });\n  }\n\n  /**\n   * Safely decreases the count after the read operation is finished.\n   */\n  private async postReadCleanup(identifier: ResourceIdentifier): Promise<void> {\n    await this.withInternalReadLock(identifier, async(): Promise<void> => {\n      const count = await this.incrementCount(identifier, -1);\n      if (count === 0) {\n        // All read locks have been released so a write operation is possible again\n        const write = this.getWriteLockKey(identifier);\n        await this.locker.release(write);\n      }\n    });\n  }\n\n  /**\n   * Safely runs an action on the count.\n   */\n  private async withInternalReadLock<T>(identifier: ResourceIdentifier, whileLocked: () => (Promise<T> | T)):\n  Promise<T> {\n    const read = this.getReadLockKey(identifier);\n    await this.locker.acquire(read);\n    try {\n      return await whileLocked();\n    } finally {\n      await this.locker.release(read);\n    }\n  }\n\n  /**\n   * Updates the count with the given modifier.\n   * Creates the data if it didn't exist yet.\n   * Deletes the data when the count reaches zero.\n   */\n  private async incrementCount(identifier: ResourceIdentifier, mod: number): Promise<number> {\n    const countKey = this.getCountKey(identifier);\n    let number = await this.storage.get(countKey) ?? 0;\n    number += mod;\n    if (number === 0) {\n      // Make sure there is no remaining data once all locks are released\n      await this.storage.delete(countKey);\n    } else if (number > 0) {\n      await this.storage.set(countKey, number);\n    } else {\n      // Failsafe in case something goes wrong with the count storage\n      throw new InternalServerError('Read counter would become negative. Something is wrong with the count storage.');\n    }\n    return number;\n  }\n}\n"]}