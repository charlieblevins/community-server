{"version":3,"file":"PromiseUtil.js","sourceRoot":"","sources":["../../src/util/PromiseUtil.ts"],"names":[],"mappings":";;;AAAA,0DAA8D;AAE9D,gEAAgE;AAChE,SAAS,IAAI,KAAU,CAAC;AAExB;;;;;;;;;;;GAWG;AACI,KAAK,UAAU,WAAW,CAAC,UAA8B;IAC9D,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAQ,EAAE;QACnC,SAAS,aAAa,CAAC,KAAc;YACnC,IAAI,KAAK,EAAE;gBACT,OAAO,CAAC,IAAI,CAAC,CAAC;aACf;QACH,CAAC;QACD,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,SAAS,EAAiB,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,CAAC,CAAC;aAC3F,IAAI,CAAC,GAAS,EAAE,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;IAC5C,CAAC,CAAC,CAAC;AACL,CAAC;AAVD,kCAUC;AAED;;;GAGG;AACI,KAAK,UAAU,YAAY,CAAI,QAAuB,EAAE,YAAY,GAAG,KAAK;IACjF,4BAA4B;IAC5B,MAAM,MAAM,GAAQ,EAAE,CAAC;IACvB,MAAM,MAAM,GAAY,EAAE,CAAC;IAC3B,KAAK,MAAM,MAAM,IAAI,MAAM,OAAO,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;QACvD,IAAI,MAAM,CAAC,MAAM,KAAK,WAAW,EAAE;YACjC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;SAC3B;aAAM,IAAI,CAAC,YAAY,EAAE;YACxB,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;SAC5B;KACF;IAED,yBAAyB;IACzB,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;QACrB,MAAM,oCAAoB,CAAC,MAAM,CAAC,CAAC;KACpC;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAjBD,oCAiBC","sourcesContent":["import { createAggregateError } from './errors/HttpErrorUtil';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop(): void {}\n\n/**\n * A function that simulates the Array.some behaviour but on an array of Promises.\n * Returns true if at least one promise returns true.\n * Returns false if all promises return false or error.\n *\n * @remarks\n *\n * Predicates provided as input must be implemented considering\n * the following points:\n * 1. if they throw an error, it won't be propagated;\n * 2. throwing an error should be logically equivalent to returning false.\n */\nexport async function promiseSome(predicates: Promise<boolean>[]): Promise<boolean> {\n  return new Promise((resolve): void => {\n    function resolveIfTrue(value: boolean): void {\n      if (value) {\n        resolve(true);\n      }\n    }\n    Promise.all(predicates.map((predicate): Promise<void> => predicate.then(resolveIfTrue, noop)))\n      .then((): void => resolve(false), noop);\n  });\n}\n\n/**\n * Obtains the values of all fulfilled promises.\n * If there are rejections (and `ignoreErrors` is false), throws a combined error of all rejected promises.\n */\nexport async function allFulfilled<T>(promises: Promise<T> [], ignoreErrors = false): Promise<T[]> {\n  // Collect values and errors\n  const values: T[] = [];\n  const errors: Error[] = [];\n  for (const result of await Promise.allSettled(promises)) {\n    if (result.status === 'fulfilled') {\n      values.push(result.value);\n    } else if (!ignoreErrors) {\n      errors.push(result.reason);\n    }\n  }\n\n  // Either throw or return\n  if (errors.length > 0) {\n    throw createAggregateError(errors);\n  }\n  return values;\n}\n"]}