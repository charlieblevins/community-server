{"version":3,"file":"TermUtil.js","sourceRoot":"","sources":["../../src/util/TermUtil.ts"],"names":[],"mappings":";;;AAAA,2BAAiC;AAEjC,iDAAmD;AAEnD,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,gBAAW,CAAC;AAE3C,0CAA0C;AAC1C,MAAM,UAAU,GAA8B;IAC5C,WAAW,EAAE,gCAAiB;CAC/B,CAAC;AAEF,gCAAgC;AAChC,MAAM,gBAAgB,GAA8B;IAClD,GAAG,UAAU;CACd,CAAC;AAEF;;;;;GAKG;AACH,SAAgB,iBAAiB,CAAC,IAAwB;IACxD,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;QAC5B,OAAO,IAAI,CAAC;KACb;IACD,IAAI,CAAC,CAAC,IAAI,IAAI,gBAAgB,CAAC,EAAE;QAC/B,gBAAgB,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC;KAC1C;IACD,OAAO,gBAAgB,CAAC,IAAI,CAAC,CAAC;AAChC,CAAC;AARD,8CAQC;AAED;;GAEG;AACH,SAAgB,MAAM,CAAC,KAAW;IAChC,OAAO,KAAK,IAAI,OAAO,KAAK,CAAC,QAAQ,KAAK,QAAQ,CAAC;AACrD,CAAC;AAFD,wBAEC;AASD,SAAgB,WAAW,CAAC,OAAsB;IAChD,OAAO,OAAO,OAAO,KAAK,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC;AACpE,CAAC;AAFD,kCAEC;AAEY,QAAA,eAAe,GAAG,WAAW,CAAC;AAU3C,SAAgB,YAAY,CAAC,MAAqB,EAAE,aAAa,GAAG,KAAK;IACvE,IAAI,OAAO,MAAM,KAAK,QAAQ,EAAE;QAC9B,OAAO,CAAC,aAAa,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,CAAQ,CAAC;KACrE;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AALD,oCAKC;AAED;;;;GAIG;AACH,SAAgB,SAAS,CAAC,MAAuB,EAAE,QAAmB;IACpE,OAAO,OAAO,CAAC,GAAG,MAAM,EAAE,EAAE,QAAQ,CAAC,CAAC;AACxC,CAAC;AAFD,8BAEC","sourcesContent":["import { DataFactory } from 'n3';\nimport type { NamedNode, Literal, Term } from 'rdf-js';\nimport { CONTENT_TYPE_TERM } from './Vocabularies';\n\nconst { namedNode, literal } = DataFactory;\n\n// Shorthands for commonly used predicates\nconst shorthands: Record<string, NamedNode> = {\n  contentType: CONTENT_TYPE_TERM,\n};\n\n// Caches named node conversions\nconst cachedNamedNodes: Record<string, NamedNode> = {\n  ...shorthands,\n};\n\n/**\n * Converts the incoming name (URI or shorthand) to a named node.\n * The generated terms get cached to reduce the number of created nodes,\n * so only use this for internal constants!\n * @param name - Predicate to potentially transform.\n */\nexport function toCachedNamedNode(name: NamedNode | string): NamedNode {\n  if (typeof name !== 'string') {\n    return name;\n  }\n  if (!(name in cachedNamedNodes)) {\n    cachedNamedNodes[name] = namedNode(name);\n  }\n  return cachedNamedNodes[name];\n}\n\n/**\n * @param input - Checks if this is a {@link Term}.\n */\nexport function isTerm(input?: any): input is Term {\n  return input && typeof input.termType === 'string';\n}\n\n/**\n * Converts a string to a named node when needed.\n * @param subject - Subject to potentially transform.\n */\nexport function toNamedTerm(subject: string): NamedNode;\nexport function toNamedTerm<T extends Term>(subject: T): T;\nexport function toNamedTerm<T extends Term>(subject: T | string): T | NamedNode;\nexport function toNamedTerm(subject: Term | string): Term {\n  return typeof subject === 'string' ? namedNode(subject) : subject;\n}\n\nexport const toPredicateTerm = toNamedTerm;\n\n/**\n * Converts an object term when needed.\n * @param object - Object to potentially transform.\n * @param preferLiteral - Whether strings are converted to literals or named nodes.\n */\nexport function toObjectTerm(object: string, preferLiteral?: boolean): NamedNode;\nexport function toObjectTerm<T extends Term>(object: T, preferLiteral?: boolean): T;\nexport function toObjectTerm<T extends Term>(object: T | string, preferLiteral?: boolean): T | NamedNode;\nexport function toObjectTerm(object: Term | string, preferLiteral = false): Term {\n  if (typeof object === 'string') {\n    return (preferLiteral ? literal(object) : namedNode(object)) as any;\n  }\n  return object;\n}\n\n/**\n * Creates a literal by first converting the dataType string to a named node.\n * @param object - Object value.\n * @param dataType - Object data type (as string).\n */\nexport function toLiteral(object: string | number, dataType: NamedNode): Literal {\n  return literal(`${object}`, dataType);\n}\n"]}