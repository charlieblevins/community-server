{"version":3,"file":"HttpErrorUtil.js","sourceRoot":"","sources":["../../../src/util/errors/HttpErrorUtil.ts"],"names":[],"mappings":";;;AAAA,+DAA4D;AAC5D,2CAAiD;AACjD,2CAAwC;AACxC,+DAA4D;AAE5D;;GAEG;AACH,SAAgB,aAAa,CAAC,KAAY;IACxC,OAAO,qBAAS,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC;AAC9D,CAAC;AAFD,sCAEC;AAED;;;;;;;GAOG;AACH,SAAgB,oBAAoB,CAAC,MAAe,EAAE,aAAa,GAAG,sCAAsC;IAE1G,MAAM,UAAU,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,EAAa,EAAE,CACjD,qBAAS,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,yCAAmB,CAAC,8BAAkB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IAC5F,MAAM,MAAM,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,KAAY,EAAU,EAAE,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAClF,MAAM,OAAO,GAAG,GAAG,aAAa,KAAK,MAAM,GAAG,CAAC;IAE/C,gDAAgD;IAChD,IAAI,UAAU,CAAC,MAAM,GAAG,CAAC,IAAI,UAAU,CAAC,KAAK,CAAC,CAAC,KAAK,EAAW,EAAE,CAAC,KAAK,CAAC,UAAU,KAAK,UAAU,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,EAAE;QAChH,OAAO,IAAI,qBAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KAC7E;IAED,oCAAoC;IACpC,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC,KAAK,EAAW,EAAE,CAAC,KAAK,CAAC,UAAU,IAAI,GAAG,CAAC,EAAE;QAChE,OAAO,IAAI,yCAAmB,CAAC,OAAO,CAAC,CAAC;KACzC;IACD,OAAO,IAAI,yCAAmB,CAAC,OAAO,CAAC,CAAC;AAC1C,CAAC;AAjBD,oDAiBC","sourcesContent":["import { BadRequestHttpError } from './BadRequestHttpError';\nimport { createErrorMessage } from './ErrorUtil';\nimport { HttpError } from './HttpError';\nimport { InternalServerError } from './InternalServerError';\n\n/**\n * Returns the HTTP status code corresponding to the error.\n */\nexport function getStatusCode(error: Error): number {\n  return HttpError.isInstance(error) ? error.statusCode : 500;\n}\n\n/**\n * Combines a list of errors into a single HttpErrors.\n * Status code depends on the input errors. If they all share the same status code that code will be re-used.\n * If they are all within the 4xx range, 400 will be used, otherwise 500.\n *\n * @param errors - Errors to combine.\n * @param messagePrefix - Prefix for the aggregate error message. Will be followed with an array of all the messages.\n */\nexport function createAggregateError(errors: Error[], messagePrefix = 'No handler supports the given input:'):\nHttpError {\n  const httpErrors = errors.map((error): HttpError =>\n    HttpError.isInstance(error) ? error : new InternalServerError(createErrorMessage(error)));\n  const joined = httpErrors.map((error: Error): string => error.message).join(', ');\n  const message = `${messagePrefix} [${joined}]`;\n\n  // Check if all errors have the same status code\n  if (httpErrors.length > 0 && httpErrors.every((error): boolean => error.statusCode === httpErrors[0].statusCode)) {\n    return new HttpError(httpErrors[0].statusCode, httpErrors[0].name, message);\n  }\n\n  // Find the error range (4xx or 5xx)\n  if (httpErrors.some((error): boolean => error.statusCode >= 500)) {\n    return new InternalServerError(message);\n  }\n  return new BadRequestHttpError(message);\n}\n"]}