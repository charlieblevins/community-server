{"version":3,"file":"HeaderUtil.js","sourceRoot":"","sources":["../../src/util/HeaderUtil.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IncomingHttpHeaders } from 'http';\nimport { getLoggerFor } from '../logging/LogUtil';\nimport type { HttpResponse } from '../server/HttpResponse';\nimport { BadRequestHttpError } from './errors/BadRequestHttpError';\n\nconst logger = getLoggerFor('HeaderUtil');\n\n// BNF based on https://tools.ietf.org/html/rfc7231\n//\n// Accept =          #( media-range [ accept-params ] )\n// Accept-Charset =  1#( ( charset / \"*\" ) [ weight ] )\n// Accept-Encoding  = #( codings [ weight ] )\n// Accept-Language = 1#( language-range [ weight ] )\n//\n// Content-Type = media-type\n// media-type = type \"/\" subtype *( OWS \";\" OWS parameter )\n//\n// media-range    = ( \"*/*\"\n//                / ( type \"/\" \"*\" )\n//                / ( type \"/\" subtype )\n//                ) *( OWS \";\" OWS parameter ) ; media type parameters\n// accept-params  = weight *( accept-ext )\n// accept-ext     = OWS \";\" OWS token [ \"=\" ( token / quoted-string ) ] ; extension parameters\n//\n// weight = OWS \";\" OWS \"q=\" qvalue\n// qvalue = ( \"0\" [ \".\" 0*3DIGIT ] )\n//        / ( \"1\" [ \".\" 0*3(\"0\") ] )\n//\n// type       = token\n// subtype    = token\n// parameter  = token \"=\" ( token / quoted-string )\n//\n// quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n// qdtext         = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text\n// obs-text       = %x80-FF\n// quoted-pair    = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n//\n// charset = token\n//\n// codings          = content-coding / \"identity\" / \"*\"\n// content-coding   = token\n//\n// language-range   = (1*8ALPHA *(\"-\" 1*8alphanum)) / \"*\"\n// alphanum         = ALPHA / DIGIT\n//\n// Delimiters are chosen from the set of US-ASCII visual characters\n// not allowed in a token (DQUOTE and \"(),/:;<=>?@[\\]{}\").\n// token          = 1*tchar\n// tchar          = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n//                / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n//                / DIGIT / ALPHA\n//                ; any VCHAR, except delimiters\n//\n\n// INTERFACES\n/**\n * General interface for all Accept* headers.\n */\nexport interface AcceptHeader {\n  /** Requested range. Can be a specific value or `*`, matching all. */\n  range: string;\n  /** Weight of the preference [0, 1]. */\n  weight: number;\n}\n\n/**\n * Contents of an HTTP Accept header.\n * Range is type/subtype. Both can be `*`.\n */\nexport interface Accept extends AcceptHeader {\n  parameters: {\n    /** Media type parameters. These are the parameters that came before the q value. */\n    mediaType: Record<string, string>;\n    /**\n     * Extension parameters. These are the parameters that came after the q value.\n     * Value will be an empty string if there was none.\n     */\n    extension: Record<string, string>;\n  };\n}\n\n/**\n * Contents of an HTTP Accept-Charset header.\n */\nexport interface AcceptCharset extends AcceptHeader { }\n\n/**\n * Contents of an HTTP Accept-Encoding header.\n */\nexport interface AcceptEncoding extends AcceptHeader { }\n\n/**\n * Contents of an HTTP Accept-Language header.\n */\nexport interface AcceptLanguage extends AcceptHeader { }\n\n/**\n * Contents of an HTTP Accept-Datetime header.\n */\nexport interface AcceptDatetime extends AcceptHeader { }\n\n// REUSED REGEXES\nconst token = /^[a-zA-Z0-9!#$%&'*+-.^_`|~]+$/u;\n\n// HELPER FUNCTIONS\n/**\n * Replaces all double quoted strings in the input string with `\"0\"`, `\"1\"`, etc.\n * @param input - The Accept header string.\n *\n * @returns The transformed string and a map with keys `\"0\"`, etc. and values the original string that was there.\n */\nexport function transformQuotedStrings(input: string): { result: string; replacements: Record<string, string> } {\n  let idx = 0;\n  const replacements: Record<string, string> = {};\n  const result = input.replace(/\"(?:[^\"\\\\]|\\\\.)*\"/gu, (match): string => {\n    // Not all characters allowed in quoted strings, see BNF above\n    if (!/^\"(?:[\\t !\\u0023-\\u005B\\u005D-\\u007E\\u0080-\\u00FF]|(?:\\\\[\\t\\u0020-\\u007E\\u0080-\\u00FF]))*\"$/u.test(match)) {\n      logger.warn(`Invalid quoted string in header: ${match}`);\n      throw new BadRequestHttpError(`Invalid quoted string in header: ${match}`);\n    }\n    const replacement = `\"${idx}\"`;\n    replacements[replacement] = match.slice(1, -1);\n    idx += 1;\n    return replacement;\n  });\n  return { result, replacements };\n}\n\n/**\n * Splits the input string on commas, trims all parts and filters out empty ones.\n *\n * @param input - Input header string.\n */\nexport function splitAndClean(input: string): string[] {\n  return input.split(',')\n    .map((part): string => part.trim())\n    .filter((part): boolean => part.length > 0);\n}\n\n/**\n * Checks if the input string matches the qvalue regex.\n *\n * @param qvalue - Input qvalue string (so \"q=....\").\n *\n * @throws {@link BadRequestHttpError}\n * Thrown on invalid syntax.\n */\nfunction testQValue(qvalue: string): void {\n  if (!/^(?:(?:0(?:\\.\\d{0,3})?)|(?:1(?:\\.0{0,3})?))$/u.test(qvalue)) {\n    logger.warn(`Invalid q value: ${qvalue}`);\n    throw new BadRequestHttpError(\n      `Invalid q value: ${qvalue} does not match ( \"0\" [ \".\" 0*3DIGIT ] ) / ( \"1\" [ \".\" 0*3(\"0\") ] ).`,\n    );\n  }\n}\n\n/**\n * Parses a list of split parameters and checks their validity.\n *\n * @param parameters - A list of split parameters (token [ \"=\" ( token / quoted-string ) ])\n * @param replacements - The double quoted strings that need to be replaced.\n *\n *\n * @throws {@link BadRequestHttpError}\n * Thrown on invalid parameter syntax.\n *\n * @returns An array of name/value objects corresponding to the parameters.\n */\nexport function parseParameters(parameters: string[], replacements: Record<string, string>):\n{ name: string; value: string }[] {\n  return parameters.map((param): { name: string; value: string } => {\n    const [ name, rawValue ] = param.split('=').map((str): string => str.trim());\n\n    // Test replaced string for easier check\n    // parameter  = token \"=\" ( token / quoted-string )\n    // second part is optional for certain parameters\n    if (!(token.test(name) && (!rawValue || /^\"\\d+\"$/u.test(rawValue) || token.test(rawValue)))) {\n      logger.warn(`Invalid parameter value: ${name}=${replacements[rawValue] || rawValue}`);\n      throw new BadRequestHttpError(\n        `Invalid parameter value: ${name}=${replacements[rawValue] || rawValue} ` +\n        `does not match (token ( \"=\" ( token / quoted-string ))?). `,\n      );\n    }\n\n    let value = rawValue;\n    if (value in replacements) {\n      value = replacements[rawValue];\n    }\n\n    return { name, value };\n  });\n}\n\n/**\n * Parses a single media range with corresponding parameters from an Accept header.\n * For every parameter value that is a double quoted string,\n * we check if it is a key in the replacements map.\n * If yes the value from the map gets inserted instead.\n *\n * @param part - A string corresponding to a media range and its corresponding parameters.\n * @param replacements - The double quoted strings that need to be replaced.\n *\n * @throws {@link BadRequestHttpError}\n * Thrown on invalid type, qvalue or parameter syntax.\n *\n * @returns {@link Accept} object corresponding to the header string.\n */\nfunction parseAcceptPart(part: string, replacements: Record<string, string>): Accept {\n  const [ range, ...parameters ] = part.split(';').map((param): string => param.trim());\n\n  // No reason to test differently for * since we don't check if the type exists\n  const [ type, subtype ] = range.split('/');\n  if (!type || !subtype || !token.test(type) || !token.test(subtype)) {\n    logger.warn(`Invalid Accept range: ${range}`);\n    throw new BadRequestHttpError(\n      `Invalid Accept range: ${range} does not match ( \"*/*\" / ( token \"/\" \"*\" ) / ( token \"/\" token ) )`,\n    );\n  }\n\n  let weight = 1;\n  const mediaTypeParams: Record<string, string> = {};\n  const extensionParams: Record<string, string> = {};\n  let map = mediaTypeParams;\n  const parsedParams = parseParameters(parameters, replacements);\n  parsedParams.forEach(({ name, value }): void => {\n    if (name === 'q') {\n      // Extension parameters appear after the q value\n      map = extensionParams;\n      testQValue(value);\n      weight = Number.parseFloat(value);\n    } else {\n      if (!value && map !== extensionParams) {\n        logger.warn(`Invalid Accept parameter ${name}`);\n        throw new BadRequestHttpError(`Invalid Accept parameter ${name}: ` +\n        `Accept parameter values are not optional when preceding the q value`);\n      }\n      map[name] = value || '';\n    }\n  });\n\n  return {\n    range,\n    weight,\n    parameters: {\n      mediaType: mediaTypeParams,\n      extension: extensionParams,\n    },\n  };\n}\n\n/**\n * Parses an Accept-* header where each part is only a value and a weight, so roughly /.*(q=.*)?/ separated by commas.\n * @param input - Input header string.\n *\n * @throws {@link BadRequestHttpError}\n * Thrown on invalid qvalue syntax.\n *\n * @returns An array of ranges and weights.\n */\nfunction parseNoParameters(input: string): AcceptHeader[] {\n  const parts = splitAndClean(input);\n\n  return parts.map((part): AcceptHeader => {\n    const [ range, qvalue ] = part.split(';').map((param): string => param.trim());\n    const result = { range, weight: 1 };\n    if (qvalue) {\n      if (!qvalue.startsWith('q=')) {\n        logger.warn(`Only q parameters are allowed in ${input}`);\n        throw new BadRequestHttpError(`Only q parameters are allowed in ${input}`);\n      }\n      const val = qvalue.slice(2);\n      testQValue(val);\n      result.weight = Number.parseFloat(val);\n    }\n    return result;\n  }).sort((left, right): number => right.weight - left.weight);\n}\n\n// EXPORTED FUNCTIONS\n\n/**\n * Parses an Accept header string.\n *\n * @param input - The Accept header string.\n *\n * @throws {@link BadRequestHttpError}\n * Thrown on invalid header syntax.\n *\n * @returns An array of {@link Accept} objects, sorted by weight.\n */\nexport function parseAccept(input: string): Accept[] {\n  // Quoted strings could prevent split from having correct results\n  const { result, replacements } = transformQuotedStrings(input);\n  return splitAndClean(result)\n    .map((part): Accept => parseAcceptPart(part, replacements))\n    .sort((left, right): number => right.weight - left.weight);\n}\n\n/**\n * Parses an Accept-Charset header string.\n *\n * @param input - The Accept-Charset header string.\n *\n * @throws {@link BadRequestHttpError}\n * Thrown on invalid header syntax.\n *\n * @returns An array of {@link AcceptCharset} objects, sorted by weight.\n */\nexport function parseAcceptCharset(input: string): AcceptCharset[] {\n  const results = parseNoParameters(input);\n  results.forEach((result): void => {\n    if (!token.test(result.range)) {\n      logger.warn(`Invalid Accept-Charset range: ${result.range}`);\n      throw new BadRequestHttpError(\n        `Invalid Accept-Charset range: ${result.range} does not match (content-coding / \"identity\" / \"*\")`,\n      );\n    }\n  });\n  return results;\n}\n\n/**\n * Parses an Accept-Encoding header string.\n *\n * @param input - The Accept-Encoding header string.\n *\n * @throws {@link BadRequestHttpError}\n * Thrown on invalid header syntax.\n *\n * @returns An array of {@link AcceptEncoding} objects, sorted by weight.\n */\nexport function parseAcceptEncoding(input: string): AcceptEncoding[] {\n  const results = parseNoParameters(input);\n  results.forEach((result): void => {\n    if (!token.test(result.range)) {\n      logger.warn(`Invalid Accept-Encoding range: ${result.range}`);\n      throw new BadRequestHttpError(`Invalid Accept-Encoding range: ${result.range} does not match (charset / \"*\")`);\n    }\n  });\n  return results;\n}\n\n/**\n * Parses an Accept-Language header string.\n *\n * @param input - The Accept-Language header string.\n *\n * @throws {@link BadRequestHttpError}\n * Thrown on invalid header syntax.\n *\n * @returns An array of {@link AcceptLanguage} objects, sorted by weight.\n */\nexport function parseAcceptLanguage(input: string): AcceptLanguage[] {\n  const results = parseNoParameters(input);\n  results.forEach((result): void => {\n    // (1*8ALPHA *(\"-\" 1*8alphanum)) / \"*\"\n    if (result.range !== '*' && !/^[a-zA-Z]{1,8}(?:-[a-zA-Z0-9]{1,8})*$/u.test(result.range)) {\n      logger.warn(\n        `Invalid Accept-Language range: ${result.range}`,\n      );\n      throw new BadRequestHttpError(\n        `Invalid Accept-Language range: ${result.range} does not match ((1*8ALPHA *(\"-\" 1*8alphanum)) / \"*\")`,\n      );\n    }\n  });\n  return results;\n}\n\n// eslint-disable-next-line max-len\nconst rfc1123Date = /^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), \\d{2} (?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d{4} \\d{2}:\\d{2}:\\d{2} GMT$/u;\n\n/**\n * Parses an Accept-DateTime header string.\n *\n * @param input - The Accept-DateTime header string.\n *\n * @returns An array with a single {@link AcceptDatetime} object.\n */\nexport function parseAcceptDateTime(input: string): AcceptDatetime[] {\n  const results: AcceptDatetime[] = [];\n  const range = input.trim();\n  if (range) {\n    if (!rfc1123Date.test(range)) {\n      logger.warn(\n        `Invalid Accept-DateTime range: ${range}`,\n      );\n      throw new BadRequestHttpError(\n        `Invalid Accept-DateTime range: ${range} does not match the RFC1123 format`,\n      );\n    }\n    results.push({ range, weight: 1 });\n  }\n  return results;\n}\n\n/**\n * Adds a header value without overriding previous values.\n */\nexport function addHeader(response: HttpResponse, name: string, value: string | string[]): void {\n  let allValues: string[] = [];\n  if (response.hasHeader(name)) {\n    let oldValues = response.getHeader(name)!;\n    if (typeof oldValues === 'string') {\n      oldValues = [ oldValues ];\n    } else if (typeof oldValues === 'number') {\n      oldValues = [ `${oldValues}` ];\n    }\n    allValues = oldValues;\n  }\n  if (Array.isArray(value)) {\n    allValues.push(...value);\n  } else {\n    allValues.push(value);\n  }\n  response.setHeader(name, allValues.length === 1 ? allValues[0] : allValues);\n}\n\n/**\n * Parses the Content-Type header.\n *\n * @param contentType - The media type of the content-type header\n *\n * @returns The parsed media type of the content-type\n */\nexport function parseContentType(contentType: string): { type: string } {\n  const contentTypeValue = /^\\s*([^;\\s]*)/u.exec(contentType)![1];\n  return { type: contentTypeValue };\n}\n\n/**\n * The Forwarded header from RFC7239\n */\nexport interface Forwarded {\n  /** The user-agent facing interface of the proxy */\n  by?: string;\n  /** The node making the request to the proxy */\n  for?: string;\n  /** The host request header field as received by the proxy */\n  host?: string;\n  /** The protocol used to make the request */\n  proto?: string;\n}\n\n/**\n * Parses a Forwarded header value and will fall back to X-Forwarded-* headers.\n *\n * @param headers - The incoming HTTP headers.\n *\n * @returns The parsed Forwarded header.\n */\nexport function parseForwarded(headers: IncomingHttpHeaders): Forwarded {\n  const forwarded: Record<string, string> = {};\n  if (headers.forwarded) {\n    for (const pair of headers.forwarded.replace(/\\s*,.*/u, '').split(';')) {\n      const components = /^(by|for|host|proto)=(.+)$/u.exec(pair);\n      if (components) {\n        forwarded[components[1]] = components[2];\n      }\n    }\n  } else {\n    const suffixes = [ 'host', 'proto' ];\n    for (const suffix of suffixes) {\n      const value = headers[`x-forwarded-${suffix}`] as string;\n      if (value) {\n        forwarded[suffix] = value.trim().replace(/\\s*,.*/u, '');\n      }\n    }\n  }\n  return forwarded;\n}\n"]}