{"version":3,"file":"UnionHandler.js","sourceRoot":"","sources":["../../../src/util/handlers/UnionHandler.ts"],"names":[],"mappings":";;;AAAA,gDAA8C;AAC9C,iDAA8C;AAC9C,+CAA4D;AAO5D;;;;GAIG;AACH,MAAsB,YAA+C,SAAQ,2BAAmC;IAK9G;;;;;;;;;;;;;OAaG;IACH,YAAmB,QAAa,EAAE,UAAU,GAAG,KAAK,EAAE,YAAY,GAAG,CAAC,UAAU;QAC9E,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAC7B,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;IACnC,CAAC;IAEM,KAAK,CAAC,SAAS,CAAC,KAAgB;QACrC,IAAI,IAAI,CAAC,UAAU,EAAE;YACnB,MAAM,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;SAChC;aAAM;YACL,mDAAmD;YACnD,MAAM,yBAAW,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;SACzC;IACH,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,KAAgB;QAClC,MAAM,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,MAAM,4BAAc,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;QAC9F,MAAM,OAAO,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,OAAO,EAAuB,EAAE,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;QACtF,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,0BAAY,CAAC,OAAO,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC;IACtE,CAAC;IAED;;;OAGG;IACO,KAAK,CAAC,YAAY,CAAC,KAAgB;QAC3C,MAAM,0BAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,OAAO,EAAiB,EAAE,CAAC,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IAC9F,CAAC;CAMF;AArDD,oCAqDC","sourcesContent":["import { allFulfilled } from '../PromiseUtil';\nimport { AsyncHandler } from './AsyncHandler';\nimport { filterHandlers, findHandler } from './HandlerUtil';\n\n// Helper types to make sure the UnionHandler has the same in/out types as the AsyncHandler type it wraps\ntype Awaited<T> = T extends PromiseLike<infer U> ? U : T;\ntype InType<T extends AsyncHandler<any, any>> = Parameters<T['handle']>[0];\ntype OutType<T extends AsyncHandler<any, any>> = Awaited<ReturnType<T['handle']>>;\n\n/**\n * Utility handler that allows combining the results of multiple handlers into one.\n * Will run the handlers and then call the abstract `combine` function with the results,\n * which then generates the handler's output.\n */\nexport abstract class UnionHandler<T extends AsyncHandler<any, any>> extends AsyncHandler<InType<T>, OutType<T>> {\n  protected readonly handlers: T[];\n  private readonly requireAll: boolean;\n  private readonly ignoreErrors: boolean;\n\n  /**\n   * Creates a new `UnionHandler`.\n   *\n   * When `requireAll` is false or `ignoreErrors` is true,\n   * the length of the input to `combine` can vary;\n   * otherwise, it is exactly the number of handlers.\n   *\n   * @param handlers - The handlers whose output is to be combined.\n   * @param requireAll - If true, will fail if any of the handlers do not support the input.\n                         If false, only the handlers that support the input will be called;\n   *                     will fail only if none of the handlers can handle the input.\n   * @param ignoreErrors - If true, ignores handlers that fail by omitting their output;\n   *                       if false, fails when any handlers fail.\n   */\n  public constructor(handlers: T[], requireAll = false, ignoreErrors = !requireAll) {\n    super();\n    this.handlers = handlers;\n    this.requireAll = requireAll;\n    this.ignoreErrors = ignoreErrors;\n  }\n\n  public async canHandle(input: InType<T>): Promise<void> {\n    if (this.requireAll) {\n      await this.allCanHandle(input);\n    } else {\n      // This will error if no handler supports the input\n      await findHandler(this.handlers, input);\n    }\n  }\n\n  public async handle(input: InType<T>): Promise<OutType<T>> {\n    const handlers = this.requireAll ? this.handlers : await filterHandlers(this.handlers, input);\n    const results = handlers.map((handler): Promise<OutType<T>> => handler.handle(input));\n    return this.combine(await allFulfilled(results, this.ignoreErrors));\n  }\n\n  /**\n   * Checks if all handlers can handle the input.\n   * If not, throw an error based on the errors of the failed handlers.\n   */\n  protected async allCanHandle(input: InType<T>): Promise<void> {\n    await allFulfilled(this.handlers.map((handler): Promise<void> => handler.canHandle(input)));\n  }\n\n  /**\n   * Combines the results of the handlers into a single output.\n   */\n  protected abstract combine(results: OutType<T>[]): Promise<OutType<T>>;\n}\n"]}