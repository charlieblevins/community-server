{"version":3,"file":"SequenceHandler.js","sourceRoot":"","sources":["../../../src/util/handlers/SequenceHandler.ts"],"names":[],"mappings":";;;AAAA,iDAA8C;AAE9C;;;;GAIG;AACH,MAAa,eAAyC,SAAQ,2BAAmC;IAG/F,YAAmB,QAAmC;QACpD,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,QAAQ,GAAG,CAAE,GAAG,QAAQ,CAAE,CAAC;IAClC,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,KAAU;QAC5B,IAAI,MAAwB,CAAC;QAC7B,KAAK,MAAM,OAAO,IAAI,IAAI,CAAC,QAAQ,EAAE;YACnC,IAAI,SAAkB,CAAC;YACvB,IAAI;gBACF,MAAM,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;gBAC/B,SAAS,GAAG,IAAI,CAAC;aAClB;YAAC,MAAM;gBACN,SAAS,GAAG,KAAK,CAAC;aACnB;YACD,IAAI,SAAS,EAAE;gBACb,MAAM,GAAG,MAAM,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;aACtC;SACF;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AAxBD,0CAwBC","sourcesContent":["import { AsyncHandler } from './AsyncHandler';\n\n/**\n * A composite handler that will try to run all supporting handlers sequentially\n * and return the value of the last supported handler.\n * The `canHandle` check of this handler will always succeed.\n */\nexport class SequenceHandler<TIn = void, TOut = void> extends AsyncHandler<TIn, TOut | undefined> {\n  private readonly handlers: AsyncHandler<TIn, TOut>[];\n\n  public constructor(handlers: AsyncHandler<TIn, TOut>[]) {\n    super();\n    this.handlers = [ ...handlers ];\n  }\n\n  public async handle(input: TIn): Promise<TOut | undefined> {\n    let result: TOut | undefined;\n    for (const handler of this.handlers) {\n      let supported: boolean;\n      try {\n        await handler.canHandle(input);\n        supported = true;\n      } catch {\n        supported = false;\n      }\n      if (supported) {\n        result = await handler.handle(input);\n      }\n    }\n    return result;\n  }\n}\n"]}