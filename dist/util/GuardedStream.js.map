{"version":3,"file":"GuardedStream.js","sourceRoot":"","sources":["../../src/util/GuardedStream.ts"],"names":[],"mappings":";;;AAAA,gDAAkD;AAElD,MAAM,MAAM,GAAG,sBAAY,CAAC,eAAe,CAAC,CAAC;AAE7C,mEAAmE;AACnE,MAAM,aAAa,GAAG,MAAM,CAAC,eAAe,CAAC,CAAC;AAC9C,MAAM,cAAc,GAAG,MAAM,CAAC,gBAAgB,CAAC,CAAC;AAEhD,qCAAqC;AACrC,MAAM,KAAK;CAGV;AASD;;GAEG;AACH,SAAgB,SAAS,CAAgC,MAAS;IAChE,OAAO,OAAQ,MAAc,CAAC,aAAa,CAAC,KAAK,QAAQ,CAAC;AAC5D,CAAC;AAFD,8BAEC;AAED;;;;;;;GAOG;AACH,SAAS,qBAAqB,CAAgB,KAAY;IACxD,kFAAkF;IAClF,MAAM,cAAc,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;IAC/C,IAAI,cAAc,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,qBAAqB,EAAE;QACvE,IAAI,CAAC,aAAa,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAChC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,EAAE;YACzB,IAAI,CAAC,cAAc,CAAC,GAAG,UAAU,CAAC,GAAS,EAAE;gBAC3C,MAAM,OAAO,GAAG,wDAAwD,KAAK,CAAC,OAAO,EAAE,CAAC;gBACxF,MAAM,CAAC,KAAK,CAAC,OAAO,EAAE,EAAE,KAAK,EAAE,CAAC,CAAC;YACnC,CAAC,EAAE,IAAI,CAAC,CAAC;SACV;KACF;AACH,CAAC;AAED;;GAEG;AACH,SAAS,gBAAgB,CAAgB,KAAa,EAAE,IAA4B;IAClF,IAAI,KAAK,KAAK,OAAO,IAAI,IAAI,KAAK,qBAAqB,EAAE;QACvD,0BAA0B;QAC1B,IAAI,IAAI,CAAC,cAAc,CAAC,EAAE;YACxB,YAAY,CAAC,IAAI,CAAC,cAAc,CAAE,CAAC,CAAC;YACpC,IAAI,CAAC,cAAc,CAAC,GAAG,SAAS,CAAC;SAClC;QAED,oCAAoC;QACpC,MAAM,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,CAAC;QACnC,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;YACrB,IAAI,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC;YACzB,YAAY,CAAC,GAAS,EAAE;gBACtB,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;oBAC1B,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;iBAC3B;YACH,CAAC,CAAC,CAAC;SACJ;KACF;AACH,CAAC;AAED;;;;;;;;;;;;;GAaG;AACH,SAAgB,WAAW,CAAgC,MAAS;IAClE,MAAM,OAAO,GAAG,MAAoB,CAAC;IACrC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,EAAE;QACtB,OAAO,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC;QAC5B,OAAO,CAAC,EAAE,CAAC,OAAO,EAAE,qBAAqB,CAAC,CAAC;QAC3C,OAAO,CAAC,EAAE,CAAC,aAAa,EAAE,gBAAgB,CAAC,CAAC;KAC7C;SAAM;QACL,gFAAgF;QAChF,OAAO,CAAC,cAAc,CAAC,OAAO,EAAE,qBAAqB,CAAC,CAAC;QACvD,OAAO,CAAC,EAAE,CAAC,OAAO,EAAE,qBAAqB,CAAC,CAAC;KAC5C;IACD,OAAO,OAAO,CAAC;AACjB,CAAC;AAZD,kCAYC","sourcesContent":["import { getLoggerFor } from '../logging/LogUtil';\n\nconst logger = getLoggerFor('GuardedStream');\n\n// Using symbols to make sure we don't override existing parameters\nconst guardedErrors = Symbol('guardedErrors');\nconst guardedTimeout = Symbol('guardedTimeout');\n\n// Private fields for guarded streams\nclass Guard {\n  private [guardedErrors]: Error[];\n  private [guardedTimeout]?: NodeJS.Timeout;\n}\n\n/**\n * A stream that is guarded from emitting errors when there are no listeners.\n * If an error occurs while no listener is attached,\n * it will store the error and emit it once a listener is added (or a timeout occurs).\n */\nexport type Guarded<T extends NodeJS.EventEmitter = NodeJS.EventEmitter> = T & Guard;\n\n/**\n * Determines whether the stream is guarded from emitting errors.\n */\nexport function isGuarded<T extends NodeJS.EventEmitter>(stream: T): stream is Guarded<T> {\n  return typeof (stream as any)[guardedErrors] === 'object';\n}\n\n/**\n * Callback that is used when a stream emits an error and no other error listener is attached.\n * Used to store the error and start the logger timer.\n *\n * It is important that this listener always remains attached for edge cases where an error listener gets removed\n * and the number of error listeners is checked immediately afterwards.\n * See https://github.com/solid/community-server/pull/462#issuecomment-758013492 .\n */\nfunction guardingErrorListener(this: Guarded, error: Error): void {\n  // Only fall back to this if no new listeners are attached since guarding started.\n  const errorListeners = this.listeners('error');\n  if (errorListeners[errorListeners.length - 1] === guardingErrorListener) {\n    this[guardedErrors].push(error);\n    if (!this[guardedTimeout]) {\n      this[guardedTimeout] = setTimeout((): void => {\n        const message = `No error listener was attached but error was thrown: ${error.message}`;\n        logger.error(message, { error });\n      }, 1000);\n    }\n  }\n}\n\n/**\n * Callback that is used when a new listener is attached and there are errors that were not emitted yet.\n */\nfunction emitStoredErrors(this: Guarded, event: string, func: (error: Error) => void): void {\n  if (event === 'error' && func !== guardingErrorListener) {\n    // Cancel an error timeout\n    if (this[guardedTimeout]) {\n      clearTimeout(this[guardedTimeout]!);\n      this[guardedTimeout] = undefined;\n    }\n\n    // Emit any errors that were guarded\n    const errors = this[guardedErrors];\n    if (errors.length > 0) {\n      this[guardedErrors] = [];\n      setImmediate((): void => {\n        for (const error of errors) {\n          this.emit('error', error);\n        }\n      });\n    }\n  }\n}\n\n/**\n * Makes sure that listeners always receive the error event of a stream,\n * even if it was thrown before the listener was attached.\n *\n * When guarding a stream it is assumed that error listeners already attached should be ignored,\n * only error listeners attached after the stream is guarded will prevent an error from being logged.\n *\n * If the input is already guarded the guard will be reset,\n * which means ignoring error listeners already attached.\n *\n * @param stream - Stream that can potentially throw an error.\n *\n * @returns The stream.\n */\nexport function guardStream<T extends NodeJS.EventEmitter>(stream: T): Guarded<T> {\n  const guarded = stream as Guarded<T>;\n  if (!isGuarded(stream)) {\n    guarded[guardedErrors] = [];\n    guarded.on('error', guardingErrorListener);\n    guarded.on('newListener', emitStoredErrors);\n  } else {\n    // This makes sure the guarding error listener is the last one in the list again\n    guarded.removeListener('error', guardingErrorListener);\n    guarded.on('error', guardingErrorListener);\n  }\n  return guarded;\n}\n"]}