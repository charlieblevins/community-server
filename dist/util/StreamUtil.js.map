{"version":3,"file":"StreamUtil.js","sourceRoot":"","sources":["../../src/util/StreamUtil.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Writable, ReadableOptions, DuplexOptions } from 'stream';\nimport { Readable, Transform } from 'stream';\nimport { promisify } from 'util';\nimport arrayifyStream from 'arrayify-stream';\nimport eos from 'end-of-stream';\nimport { Store } from 'n3';\nimport pump from 'pump';\nimport { getLoggerFor } from '../logging/LogUtil';\nimport { isHttpRequest } from '../server/HttpRequest';\nimport { InternalServerError } from './errors/InternalServerError';\nimport type { Guarded } from './GuardedStream';\nimport { guardStream } from './GuardedStream';\n\nexport const endOfStream = promisify(eos);\n\nconst logger = getLoggerFor('StreamUtil');\n\n/**\n * Joins all strings of a stream.\n * @param stream - Stream of strings.\n *\n * @returns The joined string.\n */\nexport async function readableToString(stream: Readable): Promise<string> {\n  return (await arrayifyStream(stream)).join('');\n}\n\n/**\n * Imports quads from a stream into a Store.\n * @param stream - Stream of quads.\n *\n * @returns A Store containing all the quads.\n */\nexport async function readableToQuads(stream: Readable): Promise<Store> {\n  const quads = new Store();\n  quads.import(stream);\n  await endOfStream(stream);\n  return quads;\n}\n\n/**\n * Interprets the stream as JSON and converts it to a Dict.\n * @param stream - Stream of JSON data.\n *\n * @returns The parsed object.\n */\nexport async function readJsonStream(stream: Readable): Promise<NodeJS.Dict<any>> {\n  const body = await readableToString(stream);\n  return JSON.parse(body);\n}\n\n/**\n * Converts the stream to a single object.\n * This assumes the stream is in object mode and only contains a single element,\n * otherwise an error will be thrown.\n * @param stream - Object stream with single entry.\n */\nexport async function getSingleItem(stream: Readable): Promise<unknown> {\n  const items = await arrayifyStream(stream);\n  if (items.length !== 1) {\n    throw new InternalServerError('Expected a stream with a single object.');\n  }\n  return items[0];\n}\n\n// These error messages usually indicate expected behaviour so should not give a warning.\n// We compare against the error message instead of the code\n// since the second one is from an external library that does not assign an error code.\n// At the time of writing the first one gets thrown in Node 16 and the second one in Node 14.\nconst safeErrors = new Set([\n  'Cannot call write after a stream was destroyed',\n  'premature close',\n]);\n\n/**\n * Pipes one stream into another and emits errors of the first stream with the second.\n * In case of an error in the first stream the second one will be destroyed with the given error.\n * This will also make the stream {@link Guarded}.\n * @param readable - Initial readable stream.\n * @param destination - The destination for writing data.\n * @param mapError - Optional function that takes the error and converts it to a new error.\n *\n * @returns The destination stream.\n */\nexport function pipeSafely<T extends Writable>(readable: NodeJS.ReadableStream, destination: T,\n  mapError?: (error: Error) => Error): Guarded<T> {\n  // We never want to closes the incoming HttpRequest if there is an error\n  // since that also closes the outgoing HttpResponse.\n  // Since `pump` sends stream errors both up and down the pipe chain,\n  // in this case we need to make sure the error only goes down the chain.\n  if (isHttpRequest(readable)) {\n    readable.pipe(destination);\n    readable.on('error', (error): void => {\n      logger.warn(`HttpRequest errored with ${error.message}`);\n      // From https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options :\n      // One important caveat is that if the Readable stream emits an error during processing,\n      // the Writable destination is not closed automatically. If an error occurs,\n      // it will be necessary to manually close each stream in order to prevent memory leaks.\n      destination.destroy(mapError ? mapError(error) : error);\n    });\n  } else {\n    // In case the input readable is guarded, it will no longer log errors since `pump` attaches a new error listener\n    pump(readable, destination, (error): void => {\n      if (error) {\n        const msg = `Piped stream errored with ${error.message}`;\n        logger.log(safeErrors.has(error.message) ? 'debug' : 'warn', msg);\n\n        // Make sure the final error can be handled in a normal streaming fashion\n        destination.emit('error', mapError ? mapError(error) : error);\n      }\n    });\n  }\n  // Guarding the stream now means the internal error listeners of pump will be ignored\n  // when checking if there is a valid error listener.\n  return guardStream(destination);\n}\n\nexport interface AsyncTransformOptions<T = any> extends DuplexOptions {\n  /**\n   * Transforms data from the source by calling the `push` method\n   */\n  transform?: (this: Transform, data: T, encoding: string) => any | Promise<any>;\n\n  /**\n   * Performs any final actions after the source has ended\n   */\n  flush?: (this: Transform) => any | Promise<any>;\n}\n\n/**\n * Transforms a stream, ensuring that all errors are forwarded.\n * @param source - The stream to be transformed\n * @param options - The transformation options\n *\n * @returns The transformed stream\n */\nexport function transformSafely<T = any>(\n  source: NodeJS.ReadableStream,\n  {\n    transform = function(data): void {\n      this.push(data);\n    },\n    flush = (): null => null,\n    ...options\n  }: AsyncTransformOptions<T> = {},\n):\n  Guarded<Transform> {\n  return pipeSafely(source, new Transform({\n    ...options,\n    async transform(data, encoding, callback): Promise<void> {\n      let error: Error | null = null;\n      try {\n        await transform.call(this, data, encoding);\n      } catch (err: unknown) {\n        error = err as Error;\n      }\n      callback(error);\n    },\n    async flush(callback): Promise<void> {\n      let error: Error | null = null;\n      try {\n        await flush.call(this);\n      } catch (err: unknown) {\n        error = err as Error;\n      }\n      callback(error);\n    },\n  }));\n}\n\n/**\n * Converts a string or array to a stream and applies an error guard so that it is {@link Guarded}.\n * @param contents - Data to stream.\n * @param options - Options to pass to the Readable constructor. See {@link Readable.from}.\n */\nexport function guardedStreamFrom(contents: string | Iterable<any>, options?: ReadableOptions): Guarded<Readable> {\n  return guardStream(Readable.from(typeof contents === 'string' ? [ contents ] : contents, options));\n}\n"]}