{"version":3,"file":"FetchUtil.js","sourceRoot":"","sources":["../../src/util/FetchUtil.ts"],"names":[],"mappings":";;;AACA,6CAAoC;AACpC,oFAAiF;AAEjF,gDAAkD;AAElD,iDAAgD;AAChD,sEAAmE;AACnE,6CAAgD;AAEhD,MAAM,MAAM,GAAG,sBAAY,CAAC,WAAW,CAAC,CAAC;AAclC,KAAK,UAAU,YAAY,CAAC,KAAwB,EAAE,SAAkC,EAAE,IAAa;IAE5G,IAAI,QAAkB,CAAC;IACvB,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QAC7B,QAAQ,GAAG,MAAM,mBAAK,CAAC,KAAK,CAAC,CAAC;KAC/B;SAAM;QACL,QAAQ,GAAG,KAAK,CAAC;KAClB;IACD,IAAI,CAAC,IAAI,EAAE;QACT,IAAI,GAAG,MAAM,QAAQ,CAAC,IAAI,EAAE,CAAC;KAC9B;IAED,wGAAwG;IACxG,MAAM,KAAK,GAAG,IAAI,yCAAmB,CAAC,4BAA4B,QAAQ,CAAC,GAAG,EAAE,CAAC,CAAC;IAElF,IAAI,QAAQ,CAAC,MAAM,KAAK,GAAG,EAAE;QAC3B,MAAM,CAAC,IAAI,CAAC,gBAAgB,QAAQ,CAAC,GAAG,KAAK,IAAI,EAAE,CAAC,CAAC;QACrD,MAAM,KAAK,CAAC;KACb;IAED,MAAM,WAAW,GAAG,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;IACzD,IAAI,CAAC,WAAW,EAAE;QAChB,MAAM,CAAC,IAAI,CAAC,oCAAoC,QAAQ,CAAC,GAAG,EAAE,CAAC,CAAC;QAChE,MAAM,KAAK,CAAC;KACb;IACD,MAAM,gBAAgB,GAAG,6BAAgB,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC;IAE5D,0BAA0B;IAC1B,MAAM,cAAc,GAAG,IAAI,yCAAmB,CAAC,IAAI,EAAE,gBAAgB,CAAC,CAAC;IACvE,MAAM,WAAW,GAAG,EAAE,IAAI,EAAE,EAAE,CAAC,6BAAc,CAAC,EAAE,CAAC,EAAE,EAAC,CAAC;IACrD,OAAO,SAAS,CAAC,UAAU,CAAC,EAAE,cAAc,EAAE,UAAU,EAAE,EAAE,IAAI,EAAE,QAAQ,CAAC,GAAG,EAAE,EAAE,WAAW,EAAE,CAAC,CAAC;AACnG,CAAC;AA/BD,oCA+BC","sourcesContent":["import type { Response } from 'cross-fetch';\nimport { fetch } from 'cross-fetch';\nimport { BasicRepresentation } from '../http/representation/BasicRepresentation';\nimport type { Representation } from '../http/representation/Representation';\nimport { getLoggerFor } from '../logging/LogUtil';\nimport type { RepresentationConverter } from '../storage/conversion/RepresentationConverter';\nimport { INTERNAL_QUADS } from './ContentTypes';\nimport { BadRequestHttpError } from './errors/BadRequestHttpError';\nimport { parseContentType } from './HeaderUtil';\n\nconst logger = getLoggerFor('FetchUtil');\n\n/**\n * Fetches an RDF dataset from the given URL.\n * Input can also be a Response if the request was already made.\n * In case the given Response object was already parsed its body can be passed along as a string.\n *\n * The converter will be used to convert the response body to RDF.\n *\n * Response will be a Representation with content-type internal/quads.\n */\nexport async function fetchDataset(url: string, converter: RepresentationConverter): Promise<Representation>;\nexport async function fetchDataset(response: Response, converter: RepresentationConverter, body?: string):\nPromise<Representation>;\nexport async function fetchDataset(input: string | Response, converter: RepresentationConverter, body?: string):\nPromise<Representation> {\n  let response: Response;\n  if (typeof input === 'string') {\n    response = await fetch(input);\n  } else {\n    response = input;\n  }\n  if (!body) {\n    body = await response.text();\n  }\n\n  // Keeping the error message the same everywhere to prevent leaking possible information about intranet.\n  const error = new BadRequestHttpError(`Unable to access data at ${response.url}`);\n\n  if (response.status !== 200) {\n    logger.warn(`Cannot fetch ${response.url}: ${body}`);\n    throw error;\n  }\n\n  const contentType = response.headers.get('content-type');\n  if (!contentType) {\n    logger.warn(`Missing content-type header from ${response.url}`);\n    throw error;\n  }\n  const contentTypeValue = parseContentType(contentType).type;\n\n  // Try to convert to quads\n  const representation = new BasicRepresentation(body, contentTypeValue);\n  const preferences = { type: { [INTERNAL_QUADS]: 1 }};\n  return converter.handleSafe({ representation, identifier: { path: response.url }, preferences });\n}\n"]}