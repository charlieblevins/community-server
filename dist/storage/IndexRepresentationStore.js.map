{"version":3,"file":"IndexRepresentationStore.js","sourceRoot":"","sources":["../../src/storage/IndexRepresentationStore.ts"],"names":[],"mappings":";;;;;;AAAA,oDAA4B;AAI5B,wEAAqE;AACrE,+CAAyD;AAEzD,gEAAiF;AACjF,yDAAsD;AAGtD;;;;;;;;;;;;;;;GAeG;AACH,MAAa,wBAAyB,SAAQ,mCAAgB;IAI5D,YAAmB,MAAqB,EAAE,SAAS,GAAG,YAAY,EAAE,UAAU,GAAG,WAAW;QAC1F,KAAK,CAAC,MAAM,CAAC,CAAC;QACd,gBAAM,CAAC,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,oBAAoB,CAAC,CAAC;QAC3D,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;IAC/B,CAAC;IAEM,KAAK,CAAC,iBAAiB,CAAC,UAA8B,EAAE,WAAsC,EACnG,UAAuB;QACvB,IAAI,gCAAqB,CAAC,UAAU,CAAC,IAAI,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,EAAE;YAC7E,IAAI;gBACF,MAAM,eAAe,GAAG,EAAE,IAAI,EAAE,GAAG,UAAU,CAAC,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,EAAE,CAAC;gBACxE,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,eAAe,EAAE,WAAW,EAAE,UAAU,CAAC,CAAC;gBAC5F,wEAAwE;gBACxE,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,UAAU,EAAE,EAAE,EAAE,UAAU,CAAC,CAAC;gBAClF,SAAS,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;gBAEzB,+DAA+D;gBAC/D,sFAAsF;gBACtF,kEAAkE;gBAClE,MAAM,EAAE,WAAW,EAAE,GAAG,KAAK,CAAC,QAAQ,CAAC;gBACvC,KAAK,CAAC,QAAQ,GAAG,SAAS,CAAC,QAAQ,CAAC;gBACpC,KAAK,CAAC,QAAQ,CAAC,WAAW,GAAG,WAAW,CAAC;gBAEzC,OAAO,KAAK,CAAC;aACd;YAAC,OAAO,KAAc,EAAE;gBACvB,IAAI,CAAC,qCAAiB,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE;oBACxC,MAAM,KAAK,CAAC;iBACb;aACF;SACF;QAED,OAAO,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,UAAU,EAAE,WAAW,EAAE,UAAU,CAAC,CAAC;IAC5E,CAAC;IAED;;OAEG;IACK,kBAAkB,CAAC,WAAsC;QAC/D,mBAAmB;QACnB,IAAI,IAAI,CAAC,UAAU,KAAK,KAAK,EAAE;YAC7B,OAAO,IAAI,CAAC;SACb;QAED,mEAAmE;QACnE,MAAM,KAAK,GAAG,iCAAgB,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QACjD,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;QAC9C,OAAO,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,CAAE,KAAK,EAAE,MAAM,CAAE,EAAW,EAAE,CAC/D,KAAK,KAAK,KAAK,IAAI,CAAC,GAAG,GAAG,MAAM,CAAC,GAAG,IAAI,IAAI,iCAAgB,CAAC,KAAK,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;IAC1F,CAAC;CACF;AAtDD,4DAsDC","sourcesContent":["import assert from 'assert';\nimport type { Representation } from '../http/representation/Representation';\nimport type { RepresentationPreferences } from '../http/representation/RepresentationPreferences';\nimport type { ResourceIdentifier } from '../http/representation/ResourceIdentifier';\nimport { NotFoundHttpError } from '../util/errors/NotFoundHttpError';\nimport { isContainerIdentifier } from '../util/PathUtil';\nimport type { Conditions } from './Conditions';\nimport { cleanPreferences, matchesMediaType } from './conversion/ConversionUtil';\nimport { PassthroughStore } from './PassthroughStore';\nimport type { ResourceStore } from './ResourceStore';\n\n/**\n * Allow containers to have a custom representation.\n * The index representation will be returned when the following conditions are fulfilled:\n *  * The request targets a container.\n *  * A resource with the given `indexName` exists in the container. (default: \"index.html\")\n *  * The highest weighted preference matches the `mediaRange` (default: \"text/html\")\n * Otherwise the request will be passed on to the source store.\n * In case the index representation should always be returned when it exists,\n * the `mediaRange` should be set to \"\\*âˆ•\\*\".\n *\n * Note: this functionality is not yet part of the specification. Relevant issues are:\n * - https://github.com/solid/specification/issues/69\n * - https://github.com/solid/specification/issues/198\n * - https://github.com/solid/specification/issues/109\n * - https://github.com/solid/web-access-control-spec/issues/36\n */\nexport class IndexRepresentationStore extends PassthroughStore {\n  private readonly indexName: string;\n  private readonly mediaRange: string;\n\n  public constructor(source: ResourceStore, indexName = 'index.html', mediaRange = 'text/html') {\n    super(source);\n    assert(/^[\\w.-]+$/u.test(indexName), 'Invalid index name');\n    this.indexName = indexName;\n    this.mediaRange = mediaRange;\n  }\n\n  public async getRepresentation(identifier: ResourceIdentifier, preferences: RepresentationPreferences,\n    conditions?: Conditions): Promise<Representation> {\n    if (isContainerIdentifier(identifier) && this.matchesPreferences(preferences)) {\n      try {\n        const indexIdentifier = { path: `${identifier.path}${this.indexName}` };\n        const index = await this.source.getRepresentation(indexIdentifier, preferences, conditions);\n        // We only care about the container metadata so preferences don't matter\n        const container = await this.source.getRepresentation(identifier, {}, conditions);\n        container.data.destroy();\n\n        // Uses the container metadata but with the index content-type.\n        // There is potential metadata loss if there is more representation-specific metadata,\n        // but that can be looked into once the issues above are resolved.\n        const { contentType } = index.metadata;\n        index.metadata = container.metadata;\n        index.metadata.contentType = contentType;\n\n        return index;\n      } catch (error: unknown) {\n        if (!NotFoundHttpError.isInstance(error)) {\n          throw error;\n        }\n      }\n    }\n\n    return this.source.getRepresentation(identifier, preferences, conditions);\n  }\n\n  /**\n   * Makes sure the stored media range explicitly matches the highest weight preference.\n   */\n  private matchesPreferences(preferences: RepresentationPreferences): boolean {\n    // Always match */*\n    if (this.mediaRange === '*/*') {\n      return true;\n    }\n\n    // Otherwise, determine if an explicit match has the highest weight\n    const types = cleanPreferences(preferences.type);\n    const max = Math.max(...Object.values(types));\n    return Object.entries(types).some(([ range, weight ]): boolean =>\n      range !== '*/*' && (max - weight) < 0.01 && matchesMediaType(range, this.mediaRange));\n  }\n}\n"]}