{"version":3,"file":"LockingResourceStore.js","sourceRoot":"","sources":["../../src/storage/LockingResourceStore.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Readable } from 'stream';\nimport type { AuxiliaryIdentifierStrategy } from '../http/auxiliary/AuxiliaryIdentifierStrategy';\nimport { BasicRepresentation } from '../http/representation/BasicRepresentation';\nimport type { Patch } from '../http/representation/Patch';\nimport type { Representation } from '../http/representation/Representation';\nimport type { RepresentationPreferences } from '../http/representation/RepresentationPreferences';\nimport type { ResourceIdentifier } from '../http/representation/ResourceIdentifier';\nimport { getLoggerFor } from '../logging/LogUtil';\nimport type { ExpiringReadWriteLocker } from '../util/locking/ExpiringReadWriteLocker';\nimport { endOfStream } from '../util/StreamUtil';\nimport type { AtomicResourceStore } from './AtomicResourceStore';\nimport type { Conditions } from './Conditions';\nimport type { ModifiedResource, ResourceStore } from './ResourceStore';\n\n/**\n * Store that for every call acquires a lock before executing it on the requested resource,\n * and releases it afterwards.\n * In case the request returns a Representation the lock will only be released when the data stream is finished.\n *\n * For auxiliary resources the lock will be applied to the subject resource.\n * The actual operation is still executed on the auxiliary resource.\n */\nexport class LockingResourceStore implements AtomicResourceStore {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly source: ResourceStore;\n  private readonly locks: ExpiringReadWriteLocker;\n  private readonly auxiliaryStrategy: AuxiliaryIdentifierStrategy;\n\n  public constructor(source: ResourceStore, locks: ExpiringReadWriteLocker,\n    auxiliaryStrategy: AuxiliaryIdentifierStrategy) {\n    this.source = source;\n    this.locks = locks;\n    this.auxiliaryStrategy = auxiliaryStrategy;\n  }\n\n  public async resourceExists(identifier: ResourceIdentifier, conditions?: Conditions): Promise<boolean> {\n    return this.locks.withReadLock(this.getLockIdentifier(identifier),\n      async(): Promise<boolean> => this.source.resourceExists(identifier, conditions));\n  }\n\n  public async getRepresentation(identifier: ResourceIdentifier, preferences: RepresentationPreferences,\n    conditions?: Conditions): Promise<Representation> {\n    return this.lockedRepresentationRun(this.getLockIdentifier(identifier),\n      async(): Promise<Representation> => this.source.getRepresentation(identifier, preferences, conditions));\n  }\n\n  public async addResource(container: ResourceIdentifier, representation: Representation,\n    conditions?: Conditions): Promise<ModifiedResource> {\n    return this.locks.withWriteLock(this.getLockIdentifier(container),\n      async(): Promise<ModifiedResource> => this.source.addResource(container, representation, conditions));\n  }\n\n  public async setRepresentation(identifier: ResourceIdentifier, representation: Representation,\n    conditions?: Conditions): Promise<ModifiedResource[]> {\n    return this.locks.withWriteLock(this.getLockIdentifier(identifier),\n      async(): Promise<ModifiedResource[]> => this.source.setRepresentation(identifier, representation, conditions));\n  }\n\n  public async deleteResource(identifier: ResourceIdentifier,\n    conditions?: Conditions): Promise<ModifiedResource[]> {\n    return this.locks.withWriteLock(this.getLockIdentifier(identifier),\n      async(): Promise<ModifiedResource[]> => this.source.deleteResource(identifier, conditions));\n  }\n\n  public async modifyResource(identifier: ResourceIdentifier, patch: Patch,\n    conditions?: Conditions): Promise<ModifiedResource[]> {\n    return this.locks.withWriteLock(this.getLockIdentifier(identifier),\n      async(): Promise<ModifiedResource[]> => this.source.modifyResource(identifier, patch, conditions));\n  }\n\n  /**\n   * Acquires the correct identifier to lock this resource.\n   * For auxiliary resources this means the subject identifier.\n   */\n  protected getLockIdentifier(identifier: ResourceIdentifier): ResourceIdentifier {\n    return this.auxiliaryStrategy.isAuxiliaryIdentifier(identifier) ?\n      this.auxiliaryStrategy.getSubjectIdentifier(identifier) :\n      identifier;\n  }\n\n  /**\n   * Acquires a lock that is only released when all data of the resulting representation data has been read,\n   * an error occurs, or the timeout has been triggered.\n   * The resulting data stream will be adapted to reset the timer every time data is read.\n   *\n   * In case the data of the resulting stream is not needed it should be closed to prevent a timeout error.\n   *\n   * @param identifier - Identifier that should be locked.\n   * @param whileLocked - Function to be executed while the resource is locked.\n   */\n  protected async lockedRepresentationRun(identifier: ResourceIdentifier, whileLocked: () => Promise<Representation>):\n  Promise<Representation> {\n    // Create a new Promise that resolves to the resulting Representation\n    // while only unlocking when the data has been read (or there's a timeout).\n    // Note that we can't just return the result of `withReadLock` since that promise only\n    // resolves when the stream is finished, while we want `lockedRepresentationRun` to resolve\n    // once we have the Representation.\n    // See https://github.com/solid/community-server/pull/536#discussion_r562467957\n    return new Promise((resolve, reject): void => {\n      let representation: Representation;\n      // Make the resource time out to ensure that the lock is always released eventually.\n      this.locks.withReadLock(identifier, async(maintainLock): Promise<void> => {\n        representation = await whileLocked();\n        resolve(this.createExpiringRepresentation(representation, maintainLock));\n\n        // Release the lock when an error occurs or the data finished streaming\n        await this.waitForStreamToEnd(representation.data);\n      }).catch((error): void => {\n        // Destroy the source stream in case the lock times out\n        representation?.data.destroy(error);\n\n        // Let this function return an error in case something went wrong getting the data\n        // or in case the timeout happens before `func` returned\n        reject(error);\n      });\n    });\n  }\n\n  /**\n   * Wraps a representation to make it reset the timeout timer every time data is read.\n   *\n   * @param representation - The representation to wrap\n   * @param maintainLock - Function to call to reset the timer.\n   */\n  protected createExpiringRepresentation(representation: Representation, maintainLock: () => void): Representation {\n    const source = representation.data;\n    // Spy on the source to maintain the lock upon reading.\n    const data = Object.create(source, {\n      read: {\n        value(size: number): any {\n          maintainLock();\n          return source.read(size);\n        },\n      },\n    });\n    return new BasicRepresentation(data, representation.metadata, representation.binary);\n  }\n\n  /**\n   * Returns a promise that resolve when the source stream is finished,\n   * either by ending or emitting an error.\n   * In the case of an error the stream will be destroyed if it hasn't been already.\n   *\n   * @param source - The input stream.\n   */\n  protected async waitForStreamToEnd(source: Readable): Promise<void> {\n    try {\n      await endOfStream(source);\n    } catch {\n      // Destroy the stream in case of errors\n      if (!source.destroyed) {\n        source.destroy();\n      }\n    }\n  }\n}\n"]}