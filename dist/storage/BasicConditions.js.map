{"version":3,"file":"BasicConditions.js","sourceRoot":"","sources":["../../src/storage/BasicConditions.ts"],"names":[],"mappings":";;;AACA,uDAA0C;AAC1C,6CAAuC;AAUvC;;GAEG;AACH,MAAa,eAAe;IAM1B,YAAmB,OAA+B;QAChD,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC,WAAW,CAAC;QACvC,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC,cAAc,CAAC;QAC7C,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC,aAAa,CAAC;QAC3C,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,eAAe,CAAC;IACjD,CAAC;IAEM,eAAe,CAAC,QAAiC;;QACtD,IAAI,CAAC,QAAQ,EAAE;YACb,iGAAiG;YACjG,kEAAkE;YAClE,OAAO,CAAC,CAAA,MAAA,IAAI,CAAC,WAAW,0CAAE,QAAQ,CAAC,GAAG,CAAC,CAAA,CAAC;SACzC;QAED,MAAM,QAAQ,GAAG,QAAQ,CAAC,GAAG,CAAC,iBAAE,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;QACjD,MAAM,YAAY,GAAG,QAAQ,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QACrE,MAAM,IAAI,GAAG,oBAAO,CAAC,QAAQ,CAAC,CAAC;QAC/B,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;IAC1C,CAAC;IAEM,OAAO,CAAC,IAAa,EAAE,YAAmB;;QAC/C,sGAAsG;QACtG,wDAAwD;QACxD,IAAI,MAAA,IAAI,CAAC,cAAc,0CAAE,QAAQ,CAAC,GAAG,CAAC,EAAE;YACtC,OAAO,KAAK,CAAC;SACd;QAED,IAAI,IAAI,EAAE;YACR,IAAI,IAAI,CAAC,WAAW,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;gBAC3F,OAAO,KAAK,CAAC;aACd;YACD,IAAI,MAAA,IAAI,CAAC,cAAc,0CAAE,QAAQ,CAAC,IAAI,CAAC,EAAE;gBACvC,OAAO,KAAK,CAAC;aACd;SACF;QAED,IAAI,YAAY,EAAE;YAChB,IAAI,IAAI,CAAC,aAAa,IAAI,YAAY,GAAG,IAAI,CAAC,aAAa,EAAE;gBAC3D,OAAO,KAAK,CAAC;aACd;YACD,IAAI,IAAI,CAAC,eAAe,IAAI,YAAY,GAAG,IAAI,CAAC,eAAe,EAAE;gBAC/D,OAAO,KAAK,CAAC;aACd;SACF;QAED,OAAO,IAAI,CAAC;IACd,CAAC;CACF;AArDD,0CAqDC","sourcesContent":["import type { RepresentationMetadata } from '../http/representation/RepresentationMetadata';\nimport { DC } from '../util/Vocabularies';\nimport { getETag } from './Conditions';\nimport type { Conditions } from './Conditions';\n\nexport interface BasicConditionsOptions {\n  matchesETag?: string[];\n  notMatchesETag?: string[];\n  modifiedSince?: Date;\n  unmodifiedSince?: Date;\n}\n\n/**\n * Stores all the relevant Conditions values and matches them based on RFC7232.\n */\nexport class BasicConditions implements Conditions {\n  public readonly matchesETag?: string[];\n  public readonly notMatchesETag?: string[];\n  public readonly modifiedSince?: Date;\n  public readonly unmodifiedSince?: Date;\n\n  public constructor(options: BasicConditionsOptions) {\n    this.matchesETag = options.matchesETag;\n    this.notMatchesETag = options.notMatchesETag;\n    this.modifiedSince = options.modifiedSince;\n    this.unmodifiedSince = options.unmodifiedSince;\n  }\n\n  public matchesMetadata(metadata?: RepresentationMetadata): boolean {\n    if (!metadata) {\n      // RFC7232: ...If-Match... If the field-value is \"*\", the condition is false if the origin server\n      // does not have a current representation for the target resource.\n      return !this.matchesETag?.includes('*');\n    }\n\n    const modified = metadata.get(DC.terms.modified);\n    const modifiedDate = modified ? new Date(modified.value) : undefined;\n    const etag = getETag(metadata);\n    return this.matches(etag, modifiedDate);\n  }\n\n  public matches(eTag?: string, lastModified?: Date): boolean {\n    // RFC7232: ...If-None-Match... If the field-value is \"*\", the condition is false if the origin server\n    // has a current representation for the target resource.\n    if (this.notMatchesETag?.includes('*')) {\n      return false;\n    }\n\n    if (eTag) {\n      if (this.matchesETag && !this.matchesETag.includes(eTag) && !this.matchesETag.includes('*')) {\n        return false;\n      }\n      if (this.notMatchesETag?.includes(eTag)) {\n        return false;\n      }\n    }\n\n    if (lastModified) {\n      if (this.modifiedSince && lastModified < this.modifiedSince) {\n        return false;\n      }\n      if (this.unmodifiedSince && lastModified > this.unmodifiedSince) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n"]}