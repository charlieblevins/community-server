{"version":3,"file":"ConvertingRouterRule.js","sourceRoot":"","sources":["../../../src/storage/routing/ConvertingRouterRule.ts"],"names":[],"mappings":";;;AAIA,6CAA0C;AAO1C;;;;;;;;;GASG;AACH,MAAa,oBAAqB,SAAQ,uBAAU;IAIlD,YAAmB,UAAgC,EAAE,YAA2B;QAC9E,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,WAAW,GAAG,CAAE,UAAU,CAAE,CAAC;QAClC,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;IACnC,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,KAA0E;QAE5F,MAAM,EAAE,UAAU,EAAE,cAAc,EAAE,GAAG,KAAK,CAAC;QAC7C,IAAI,KAAoB,CAAC;QACzB,IAAI,cAAc,EAAE;YAClB,wEAAwE;YACxE,KAAK,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,KAAK,EAAC,KAAK,EAAoB,EAAE,CAC5D,KAAK,CAAC,cAAc,CAAC,QAAQ,CAAC,EAAE,UAAU,EAAE,cAAc,EAAE,CAAC,CAAC,CAAC;SAClE;aAAM;YACL,8FAA8F;YAC9F,KAAK,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,KAAK,EAAC,KAAK,EAAoB,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC,CAAC;SACxG;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;;;;OAKG;IACK,KAAK,CAAC,SAAS,CAAC,QAA2D;QACjF,0DAA0D;QAC1D,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,WAAW,EAAE;YACpC,IAAI,MAAM,QAAQ,CAAC,KAAK,CAAC,EAAE;gBACzB,OAAO,KAAK,CAAC,KAAK,CAAC;aACpB;SACF;QACD,OAAO,IAAI,CAAC,YAAY,CAAC;IAC3B,CAAC;CACF;AAxCD,oDAwCC","sourcesContent":["import type { Representation } from '../../http/representation/Representation';\nimport type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport type { ResourceStore } from '../ResourceStore';\nimport type { PreferenceSupport } from './PreferenceSupport';\nimport { RouterRule } from './RouterRule';\n\nexport interface ConvertingStoreEntry {\n  store: ResourceStore;\n  supportChecker: PreferenceSupport;\n}\n\n/**\n * Rule that directs requests based on how the data would need to be converted.\n * In case the given converter can convert the data to the requested type,\n * it will be directed to the `convertStore`.\n * Otherwise the `defaultStore` will be chosen.\n *\n * In case there is no data and only an identifier the `defaultStore` will be checked\n * if it contains the given identifier.\n * If not, the `convertStore` will be returned.\n */\nexport class ConvertingRouterRule extends RouterRule {\n  private readonly typedStores: ConvertingStoreEntry[];\n  private readonly defaultStore: ResourceStore;\n\n  public constructor(typedStore: ConvertingStoreEntry, defaultStore: ResourceStore) {\n    super();\n    this.typedStores = [ typedStore ];\n    this.defaultStore = defaultStore;\n  }\n\n  public async handle(input: { identifier: ResourceIdentifier; representation?: Representation }):\n  Promise<ResourceStore> {\n    const { identifier, representation } = input;\n    let store: ResourceStore;\n    if (representation) {\n      // TS type checking is not smart enough to let us reuse the input object\n      store = await this.findStore(async(entry): Promise<boolean> =>\n        entry.supportChecker.supports({ identifier, representation }));\n    } else {\n      // No content-type given so we can only check if one of the stores has data for the identifier\n      store = await this.findStore(async(entry): Promise<boolean> => entry.store.resourceExists(identifier));\n    }\n    return store;\n  }\n\n  /**\n   * Helper function that runs the given callback function for all the stores\n   * and returns the first one that does not throw an error.\n   *\n   * Returns the default store if no match was found.\n   */\n  private async findStore(supports: (entry: ConvertingStoreEntry) => Promise<boolean>): Promise<ResourceStore> {\n    // Try all the stores, return default if there is no match\n    for (const entry of this.typedStores) {\n      if (await supports(entry)) {\n        return entry.store;\n      }\n    }\n    return this.defaultStore;\n  }\n}\n"]}