{"version":3,"file":"RegexRouterRule.js","sourceRoot":"","sources":["../../../src/storage/routing/RegexRouterRule.ts"],"names":[],"mappings":";;;AAEA,+EAA4E;AAC5E,uFAAoF;AACpF,kDAA0D;AAE1D,6CAA0C;AAE1C;;;;;;;GAOG;AACH,MAAa,eAAgB,SAAQ,uBAAU;IAI7C;;OAEG;IACH,YAAmB,IAAY,EAAE,QAAuC;QACtE,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,IAAI,GAAG,8BAAmB,CAAC,IAAI,CAAC,CAAC;QACtC,IAAI,CAAC,OAAO,GAAG,IAAI,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,EAA6B,EAAE,CACpF,CAAE,IAAI,MAAM,CAAC,KAAK,EAAE,GAAG,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAE,CAAC,CAAC,CAAC;IAClD,CAAC;IAEM,KAAK,CAAC,SAAS,CAAC,KAA0E;QAC/F,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;IACpC,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,KAAyC;QAC3D,OAAO,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;IAC3C,CAAC;IAED;;;OAGG;IACK,UAAU,CAAC,UAA8B;QAC/C,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;QACzC,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE;YACvC,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;gBACpB,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAE,CAAC;aACjC;SACF;QACD,MAAM,IAAI,iDAAuB,CAAC,2BAA2B,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC;IAClF,CAAC;IAED;;OAEG;IACK,UAAU,CAAC,UAA8B;QAC/C,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;YAC1C,MAAM,IAAI,yCAAmB,CAAC,kCAAkC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;SAC9E;QACD,OAAO,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACjD,CAAC;CACF;AA7CD,0CA6CC","sourcesContent":["import type { Representation } from '../../http/representation/Representation';\nimport type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport { BadRequestHttpError } from '../../util/errors/BadRequestHttpError';\nimport { NotImplementedHttpError } from '../../util/errors/NotImplementedHttpError';\nimport { trimTrailingSlashes } from '../../util/PathUtil';\nimport type { ResourceStore } from '../ResourceStore';\nimport { RouterRule } from './RouterRule';\n\n/**\n * Routes requests to a store based on the path of the identifier.\n * The identifier will be stripped of the base URI after which regexes will be used to find the correct store.\n * The trailing slash of the base URI will still be present so the first character a regex can match would be that `/`.\n * This way regexes such as `/container/` can match containers in any position.\n *\n * In case none of the regexes match an error will be thrown.\n */\nexport class RegexRouterRule extends RouterRule {\n  private readonly base: string;\n  private readonly regexes: Map<RegExp, ResourceStore>;\n\n  /**\n   * The keys of the `storeMap` will be converted into actual RegExp objects that will be used for testing.\n   */\n  public constructor(base: string, storeMap: Record<string, ResourceStore>) {\n    super();\n    this.base = trimTrailingSlashes(base);\n    this.regexes = new Map(Object.keys(storeMap).map((regex): [ RegExp, ResourceStore ] =>\n      [ new RegExp(regex, 'u'), storeMap[regex] ]));\n  }\n\n  public async canHandle(input: { identifier: ResourceIdentifier; representation?: Representation }): Promise<void> {\n    this.matchStore(input.identifier);\n  }\n\n  public async handle(input: { identifier: ResourceIdentifier }): Promise<ResourceStore> {\n    return this.matchStore(input.identifier);\n  }\n\n  /**\n   * Finds the store corresponding to the regex that matches the given identifier.\n   * Throws an error if none is found.\n   */\n  private matchStore(identifier: ResourceIdentifier): ResourceStore {\n    const path = this.toRelative(identifier);\n    for (const regex of this.regexes.keys()) {\n      if (regex.test(path)) {\n        return this.regexes.get(regex)!;\n      }\n    }\n    throw new NotImplementedHttpError(`No stored regexes match ${identifier.path}`);\n  }\n\n  /**\n   * Strips the base of the identifier and throws an error if there is no overlap.\n   */\n  private toRelative(identifier: ResourceIdentifier): string {\n    if (!identifier.path.startsWith(this.base)) {\n      throw new BadRequestHttpError(`Identifiers need to start with ${this.base}`);\n    }\n    return identifier.path.slice(this.base.length);\n  }\n}\n"]}