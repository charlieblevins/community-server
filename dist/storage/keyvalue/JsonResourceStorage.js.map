{"version":3,"file":"JsonResourceStorage.js","sourceRoot":"","sources":["../../../src/storage/keyvalue/JsonResourceStorage.ts"],"names":[],"mappings":"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","sourcesContent":["import { URL } from 'url';\nimport { BasicRepresentation } from '../../http/representation/BasicRepresentation';\nimport type { Representation } from '../../http/representation/Representation';\nimport type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport { NotFoundHttpError } from '../../util/errors/NotFoundHttpError';\nimport { ensureTrailingSlash } from '../../util/PathUtil';\nimport { readableToString } from '../../util/StreamUtil';\nimport { LDP } from '../../util/Vocabularies';\nimport type { ResourceStore } from '../ResourceStore';\nimport type { KeyValueStorage } from './KeyValueStorage';\n\n/**\n * A {@link KeyValueStorage} for JSON-like objects using a {@link ResourceStore} as backend.\n *\n * The keys will be transformed so they can be safely used\n * as a resource name in the given container.\n * Values will be sent as data streams,\n * so how these are stored depends on the underlying store.\n *\n * All non-404 errors will be re-thrown.\n */\nexport class JsonResourceStorage implements KeyValueStorage<string, unknown> {\n  private readonly source: ResourceStore;\n  private readonly container: string;\n\n  public constructor(source: ResourceStore, baseUrl: string, container: string) {\n    this.source = source;\n    this.container = ensureTrailingSlash(new URL(container, baseUrl).href);\n  }\n\n  public async get(key: string): Promise<unknown | undefined> {\n    try {\n      const identifier = this.createIdentifier(key);\n      const representation = await this.source.getRepresentation(identifier, { type: { 'application/json': 1 }});\n      return JSON.parse(await readableToString(representation.data));\n    } catch (error: unknown) {\n      if (!NotFoundHttpError.isInstance(error)) {\n        throw error;\n      }\n    }\n  }\n\n  public async has(key: string): Promise<boolean> {\n    const identifier = this.createIdentifier(key);\n    return await this.source.resourceExists(identifier);\n  }\n\n  public async set(key: string, value: unknown): Promise<this> {\n    const identifier = this.createIdentifier(key);\n    const representation = new BasicRepresentation(JSON.stringify(value), identifier, 'application/json');\n    await this.source.setRepresentation(identifier, representation);\n    return this;\n  }\n\n  public async delete(key: string): Promise<boolean> {\n    try {\n      const identifier = this.createIdentifier(key);\n      await this.source.deleteResource(identifier);\n      return true;\n    } catch (error: unknown) {\n      if (!NotFoundHttpError.isInstance(error)) {\n        throw error;\n      }\n      return false;\n    }\n  }\n\n  public async* entries(): AsyncIterableIterator<[string, unknown]> {\n    // Getting ldp:contains metadata from container to find entries\n    let container: Representation;\n    try {\n      container = await this.source.getRepresentation({ path: this.container }, {});\n    } catch (error: unknown) {\n      // Container might not exist yet, will be created the first time `set` gets called\n      if (!NotFoundHttpError.isInstance(error)) {\n        throw error;\n      }\n      return;\n    }\n\n    // Only need the metadata\n    container.data.destroy();\n    const members = container.metadata.getAll(LDP.terms.contains).map((term): string => term.value);\n    for (const member of members) {\n      const representation = await this.source.getRepresentation({ path: member }, { type: { 'application/json': 1 }});\n      const json = JSON.parse(await readableToString(representation.data));\n      yield [ this.parseMember(member), json ];\n    }\n  }\n\n  /**\n   * Converts a key into an identifier for internal storage.\n   */\n  private createIdentifier(key: string): ResourceIdentifier {\n    const buffer = Buffer.from(key);\n    return { path: `${this.container}${buffer.toString('base64')}` };\n  }\n\n  /**\n   * Converts an internal storage identifier string into the original identifier key.\n   */\n  private parseMember(member: string): string {\n    const buffer = Buffer.from(member.slice(this.container.length), 'base64');\n    return buffer.toString('utf-8');\n  }\n}\n"]}