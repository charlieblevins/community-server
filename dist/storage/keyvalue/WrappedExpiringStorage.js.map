{"version":3,"file":"WrappedExpiringStorage.js","sourceRoot":"","sources":["../../../src/storage/keyvalue/WrappedExpiringStorage.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Finalizable } from '../../init/final/Finalizable';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport { InternalServerError } from '../../util/errors/InternalServerError';\nimport type { ExpiringStorage } from './ExpiringStorage';\nimport type { KeyValueStorage } from './KeyValueStorage';\n\n// Used as internal storage format\nexport type Expires<T> = { expires?: string; payload: T };\n\n/**\n * A storage that wraps around another storage and expires resources based on the given (optional) expiry date.\n * Will delete expired entries when trying to get their value.\n * Has a timer that will delete all expired data every hour (default value).\n */\nexport class WrappedExpiringStorage<TKey, TValue> implements ExpiringStorage<TKey, TValue>, Finalizable {\n  protected readonly logger = getLoggerFor(this);\n  private readonly source: KeyValueStorage<TKey, Expires<TValue>>;\n  private readonly timer: NodeJS.Timeout;\n\n  /**\n   * @param source - KeyValueStorage to actually store the data.\n   * @param timeout - How often the expired data needs to be checked in minutes.\n   */\n  public constructor(source: KeyValueStorage<TKey, Expires<TValue>>, timeout = 60) {\n    this.source = source;\n    this.timer = setInterval(this.removeExpiredEntries.bind(this), timeout * 60 * 1000);\n  }\n\n  public async get(key: TKey): Promise<TValue | undefined> {\n    return this.getUnexpired(key);\n  }\n\n  public async has(key: TKey): Promise<boolean> {\n    return Boolean(await this.getUnexpired(key));\n  }\n\n  public async set(key: TKey, value: TValue, expiration?: number): Promise<this>;\n  public async set(key: TKey, value: TValue, expires?: Date): Promise<this>;\n  public async set(key: TKey, value: TValue, expireValue?: number | Date): Promise<this> {\n    const expires = typeof expireValue === 'number' ? new Date(Date.now() + expireValue) : expireValue;\n    if (this.isExpired(expires)) {\n      throw new InternalServerError('Value is already expired');\n    }\n    await this.source.set(key, this.toExpires(value, expires));\n    return this;\n  }\n\n  public async delete(key: TKey): Promise<boolean> {\n    return this.source.delete(key);\n  }\n\n  public async* entries(): AsyncIterableIterator<[TKey, TValue]> {\n    // Not deleting expired entries here to prevent iterator issues\n    for await (const [ key, value ] of this.source.entries()) {\n      const { expires, payload } = this.toData(value);\n      if (!this.isExpired(expires)) {\n        yield [ key, payload ];\n      }\n    }\n  }\n\n  /**\n   * Deletes all entries that have expired.\n   */\n  private async removeExpiredEntries(): Promise<void> {\n    this.logger.debug('Removing expired entries');\n    const expired: TKey[] = [];\n    for await (const [ key, value ] of this.source.entries()) {\n      const { expires } = this.toData(value);\n      if (this.isExpired(expires)) {\n        expired.push(key);\n      }\n    }\n    await Promise.all(expired.map(async(key): Promise<boolean> => this.source.delete(key)));\n    this.logger.debug('Finished removing expired entries');\n  }\n\n  /**\n   * Tries to get the data for the given key.\n   * In case the data exists but has expired,\n   * it will be deleted and `undefined` will be returned instead.\n   */\n  private async getUnexpired(key: TKey): Promise<TValue | undefined> {\n    const data = await this.source.get(key);\n    if (!data) {\n      return;\n    }\n    const { expires, payload } = this.toData(data);\n    if (this.isExpired(expires)) {\n      await this.source.delete(key);\n      return;\n    }\n    return payload;\n  }\n\n  /**\n   * Checks if the given data entry has expired.\n   */\n  private isExpired(expires?: Date): boolean {\n    return typeof expires !== 'undefined' && expires < new Date();\n  }\n\n  /**\n   * Creates a new object where the `expires` field is a string instead of a Date.\n   */\n  private toExpires(data: TValue, expires?: Date): Expires<TValue> {\n    return { expires: expires?.toISOString(), payload: data };\n  }\n\n  /**\n   * Creates a new object where the `expires` field is a Date instead of a string.\n   */\n  private toData(expireData: Expires<TValue>): { expires?: Date; payload: TValue } {\n    const result: { expires?: Date; payload: TValue } = { payload: expireData.payload };\n    if (expireData.expires) {\n      result.expires = new Date(expireData.expires);\n    }\n    return result;\n  }\n\n  /**\n   * Stops the continuous cleanup timer.\n   */\n  public async finalize(): Promise<void> {\n    clearInterval(this.timer);\n  }\n}\n"]}