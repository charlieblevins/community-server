{"version":3,"file":"DataAccessorBasedStore.js","sourceRoot":"","sources":["../../src/storage/DataAccessorBasedStore.ts"],"names":[],"mappings":"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","sourcesContent":["import arrayifyStream from 'arrayify-stream';\nimport { DataFactory } from 'n3';\nimport type { NamedNode, Quad, Term } from 'rdf-js';\nimport { v4 as uuid } from 'uuid';\nimport { ModificationType } from '..';\nimport type { AuxiliaryStrategy } from '../http/auxiliary/AuxiliaryStrategy';\nimport { BasicRepresentation } from '../http/representation/BasicRepresentation';\nimport type { Patch } from '../http/representation/Patch';\nimport type { Representation } from '../http/representation/Representation';\nimport type { RepresentationMetadata } from '../http/representation/RepresentationMetadata';\nimport type { ResourceIdentifier } from '../http/representation/ResourceIdentifier';\nimport { getLoggerFor } from '../logging/LogUtil';\nimport { INTERNAL_QUADS } from '../util/ContentTypes';\nimport { BadRequestHttpError } from '../util/errors/BadRequestHttpError';\nimport { ConflictHttpError } from '../util/errors/ConflictHttpError';\nimport { createErrorMessage } from '../util/errors/ErrorUtil';\nimport { ForbiddenHttpError } from '../util/errors/ForbiddenHttpError';\nimport { MethodNotAllowedHttpError } from '../util/errors/MethodNotAllowedHttpError';\nimport { NotFoundHttpError } from '../util/errors/NotFoundHttpError';\nimport { NotImplementedHttpError } from '../util/errors/NotImplementedHttpError';\nimport { PreconditionFailedHttpError } from '../util/errors/PreconditionFailedHttpError';\nimport type { IdentifierStrategy } from '../util/identifiers/IdentifierStrategy';\nimport {\n  ensureTrailingSlash,\n  isContainerIdentifier,\n  isContainerPath,\n  trimTrailingSlashes,\n  toCanonicalUriPath,\n} from '../util/PathUtil';\nimport { parseQuads } from '../util/QuadUtil';\nimport { addResourceMetadata, updateModifiedDate } from '../util/ResourceUtil';\nimport {\n  CONTENT_TYPE,\n  DC,\n  SOLID_HTTP,\n  LDP,\n  POSIX,\n  PIM,\n  RDF,\n  XSD,\n  SOLID_META,\n  PREFERRED_PREFIX_TERM,\n} from '../util/Vocabularies';\nimport type { DataAccessor } from './accessors/DataAccessor';\nimport type { Conditions } from './Conditions';\nimport type { ModifiedResource, ResourceStore } from './ResourceStore';\nimport { createModifiedResource } from './ResourceStore';\n\n/**\n * ResourceStore which uses a DataAccessor for backend access.\n *\n * The DataAccessor interface provides elementary store operations such as read and write.\n * This DataAccessorBasedStore uses those elementary store operations\n * to implement the more high-level ResourceStore contact, abstracting all common functionality\n * such that new stores can be added by implementing the more simple DataAccessor contract.\n * DataAccessorBasedStore thereby provides behaviours for reuse across different stores, such as:\n *  * Converting container metadata to data\n *  * Converting slug to URI\n *  * Checking if addResource target is a container\n *  * Checking if no containment triples are written to a container\n *  * etc.\n *\n * Currently \"metadata\" is seen as something that is not directly accessible.\n * That means that a consumer can't write directly to the metadata of a resource, only indirectly through headers.\n * (Except for containers where data and metadata overlap).\n *\n * The one thing this store does not take care of (yet?) are containment triples for containers\n *\n * Work has been done to minimize the number of required calls to the DataAccessor,\n * but the main disadvantage is that sometimes multiple calls are required where a specific store might only need one.\n */\nexport class DataAccessorBasedStore implements ResourceStore {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly accessor: DataAccessor;\n  private readonly identifierStrategy: IdentifierStrategy;\n  private readonly auxiliaryStrategy: AuxiliaryStrategy;\n\n  public constructor(accessor: DataAccessor, identifierStrategy: IdentifierStrategy,\n    auxiliaryStrategy: AuxiliaryStrategy) {\n    this.accessor = accessor;\n    this.identifierStrategy = identifierStrategy;\n    this.auxiliaryStrategy = auxiliaryStrategy;\n  }\n\n  public async resourceExists(identifier: ResourceIdentifier): Promise<boolean> {\n    try {\n      this.validateIdentifier(identifier);\n      await this.accessor.getMetadata(identifier);\n      return true;\n    } catch (error: unknown) {\n      if (NotFoundHttpError.isInstance(error)) {\n        return false;\n      }\n      throw error;\n    }\n  }\n\n  public async getRepresentation(identifier: ResourceIdentifier): Promise<Representation> {\n    this.validateIdentifier(identifier);\n\n    // In the future we want to use getNormalizedMetadata and redirect in case the identifier differs\n    const metadata = await this.accessor.getMetadata(identifier);\n    let representation: Representation;\n\n    // Potentially add auxiliary related metadata\n    // Solid, §4.3: \"Clients can discover auxiliary resources associated with a subject resource by making an HTTP HEAD\n    // or GET request on the target URL, and checking the HTTP Link header with the rel parameter\"\n    // https://solid.github.io/specification/protocol#auxiliary-resources\n    await this.auxiliaryStrategy.addMetadata(metadata);\n\n    if (isContainerPath(metadata.identifier.value)) {\n      // Add containment triples of non-auxiliary resources\n      for await (const child of this.accessor.getChildren(identifier)) {\n        if (!this.auxiliaryStrategy.isAuxiliaryIdentifier({ path: child.identifier.value })) {\n          metadata.addQuads(child.quads());\n          metadata.add(LDP.terms.contains, child.identifier as NamedNode, SOLID_META.terms.ResponseMetadata);\n        }\n      }\n\n      // Generate a container representation from the metadata\n      // All triples should be in the same graph for the data representation\n      const data = metadata.quads().map((triple): Quad => {\n        if (triple.graph.termType === 'DefaultGraph') {\n          return triple;\n        }\n        return DataFactory.quad(triple.subject, triple.predicate, triple.object);\n      });\n\n      metadata.addQuad(DC.terms.namespace, PREFERRED_PREFIX_TERM, 'dc', SOLID_META.terms.ResponseMetadata);\n      metadata.addQuad(LDP.terms.namespace, PREFERRED_PREFIX_TERM, 'ldp', SOLID_META.terms.ResponseMetadata);\n      metadata.addQuad(POSIX.terms.namespace, PREFERRED_PREFIX_TERM, 'posix', SOLID_META.terms.ResponseMetadata);\n      metadata.addQuad(XSD.terms.namespace, PREFERRED_PREFIX_TERM, 'xsd', SOLID_META.terms.ResponseMetadata);\n      representation = new BasicRepresentation(data, metadata, INTERNAL_QUADS);\n    } else {\n      // Retrieve a document representation from the accessor\n      representation = new BasicRepresentation(await this.accessor.getData(identifier), metadata);\n    }\n    return representation;\n  }\n\n  public async addResource(container: ResourceIdentifier, representation: Representation, conditions?: Conditions):\n  Promise<ModifiedResource> {\n    this.validateIdentifier(container);\n\n    const parentMetadata = await this.getSafeNormalizedMetadata(container);\n\n    // Solid, §5.3: \"When a POST method request targets a resource without an existing representation,\n    // the server MUST respond with the 404 status code.\"\n    // https://solid.github.io/specification/protocol#writing-resources\n    if (!parentMetadata) {\n      throw new NotFoundHttpError();\n    }\n\n    // Not using `container` since `getSafeNormalizedMetadata` might return metadata for a different identifier.\n    // Solid, §5: \"Servers MUST respond with the 405 status code to requests using HTTP methods\n    // that are not supported by the target resource.\"\n    // https://solid.github.io/specification/protocol#reading-writing-resources\n    if (!isContainerPath(parentMetadata.identifier.value)) {\n      throw new MethodNotAllowedHttpError('The given path is not a container.');\n    }\n\n    this.validateConditions(conditions, parentMetadata);\n\n    // Solid, §5.1: \"Servers MAY allow clients to suggest the URI of a resource created through POST,\n    // using the HTTP Slug header as defined in [RFC5023].\n    // Clients who want the server to assign a URI of a resource, MUST use the POST request.\"\n    // https://solid.github.io/specification/protocol#resource-type-heuristics\n    const newID = await this.createSafeUri(container, representation.metadata);\n    const isContainer = isContainerIdentifier(newID);\n\n    // Ensure the representation is supported by the accessor\n    // Containers are not checked because uploaded representations are treated as metadata\n    if (!isContainer) {\n      await this.accessor.canHandle(representation);\n    }\n\n    // Write the data. New containers should never be made for a POST request.\n    await this.writeData(newID, representation, isContainer, false, false);\n\n    return createModifiedResource(newID, ModificationType.created);\n  }\n\n  public async setRepresentation(identifier: ResourceIdentifier, representation: Representation,\n    conditions?: Conditions): Promise<ModifiedResource[]> {\n    this.validateIdentifier(identifier);\n\n    // Check if the resource already exists\n    const oldMetadata = await this.getSafeNormalizedMetadata(identifier);\n\n    // Might want to redirect in the future.\n    // See #480\n    // Solid, §3.1: \"If two URIs differ only in the trailing slash, and the server has associated a resource with\n    // one of them, then the other URI MUST NOT correspond to another resource. Instead, the server MAY respond to\n    // requests for the latter URI with a 301 redirect to the former.\"\n    // https://solid.github.io/specification/protocol#uri-slash-semantics\n    if (oldMetadata && oldMetadata.identifier.value !== identifier.path) {\n      throw new ConflictHttpError(`${identifier.path} conflicts with existing path ${oldMetadata.identifier.value}`);\n    }\n\n    const isContainer = this.isNewContainer(representation.metadata, identifier.path);\n    // Solid, §3.1: \"Paths ending with a slash denote a container resource.\"\n    // https://solid.github.io/specification/protocol#uri-slash-semantics\n    if (isContainer !== isContainerIdentifier(identifier)) {\n      throw new BadRequestHttpError('Containers should have a `/` at the end of their path, resources should not.');\n    }\n\n    // Ensure the representation is supported by the accessor\n    // Containers are not checked because uploaded representations are treated as metadata\n    if (!isContainer) {\n      await this.accessor.canHandle(representation);\n    }\n\n    this.validateConditions(conditions, oldMetadata);\n\n    // Potentially have to create containers if it didn't exist yet\n    return this.writeData(identifier, representation, isContainer, !oldMetadata, Boolean(oldMetadata));\n  }\n\n  public async modifyResource(identifier: ResourceIdentifier, patch: Patch,\n    conditions?: Conditions): Promise<ModifiedResource[]> {\n    if (conditions) {\n      let metadata: RepresentationMetadata | undefined;\n      try {\n        metadata = await this.accessor.getMetadata(identifier);\n      } catch (error: unknown) {\n        if (!NotFoundHttpError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      this.validateConditions(conditions, metadata);\n    }\n\n    throw new NotImplementedHttpError('Patches are not supported by the default store.');\n  }\n\n  public async deleteResource(identifier: ResourceIdentifier, conditions?: Conditions): Promise<ModifiedResource[]> {\n    this.validateIdentifier(identifier);\n    const metadata = await this.accessor.getMetadata(identifier);\n    // Solid, §5.4: \"When a DELETE request targets storage’s root container or its associated ACL resource,\n    // the server MUST respond with the 405 status code.\"\n    // https://solid.github.io/specification/protocol#deleting-resources\n    if (this.isRootStorage(metadata)) {\n      throw new MethodNotAllowedHttpError('Cannot delete a root storage container.');\n    }\n    if (this.auxiliaryStrategy.isAuxiliaryIdentifier(identifier) &&\n      this.auxiliaryStrategy.isRequiredInRoot(identifier)) {\n      const subjectIdentifier = this.auxiliaryStrategy.getSubjectIdentifier(identifier);\n      const parentMetadata = await this.accessor.getMetadata(subjectIdentifier);\n      if (this.isRootStorage(parentMetadata)) {\n        throw new MethodNotAllowedHttpError(`Cannot delete ${identifier.path} from a root storage container.`);\n      }\n    }\n\n    // Solid, §5.4: \"When a DELETE request is made to a container, the server MUST delete the container\n    // if it contains no resources. If the container contains resources,\n    // the server MUST respond with the 409 status code and response body describing the error.\"\n    // https://solid.github.io/specification/protocol#deleting-resources\n    // Auxiliary resources are not counted when deleting a container since they will also be deleted.\n    if (isContainerIdentifier(identifier) && await this.hasProperChildren(identifier)) {\n      throw new ConflictHttpError('Can only delete empty containers.');\n    }\n\n    this.validateConditions(conditions, metadata);\n\n    // Solid, §5.4: \"When a contained resource is deleted,\n    // the server MUST also delete the associated auxiliary resources\"\n    // https://solid.github.io/specification/protocol#deleting-resources\n    const modfied = [ createModifiedResource(identifier, ModificationType.deleted) ];\n    if (!this.auxiliaryStrategy.isAuxiliaryIdentifier(identifier)) {\n      const auxiliaries = this.auxiliaryStrategy.getAuxiliaryIdentifiers(identifier);\n      modfied.push(...(await this.safelyDeleteAuxiliaryResources(auxiliaries))\n        .map((id: ResourceIdentifier): ModifiedResource => createModifiedResource(id, ModificationType.deleted)));\n    }\n\n    if (!this.identifierStrategy.isRootContainer(identifier)) {\n      const container = this.identifierStrategy.getParentContainer(identifier);\n      modfied.push(createModifiedResource(container, ModificationType.changed));\n\n      // Update modified date of parent\n      await this.updateContainerModifiedDate(container);\n    }\n\n    await this.accessor.deleteResource(identifier);\n    return modfied;\n  }\n\n  /**\n   * Verify if the given identifier matches the stored base.\n   */\n  protected validateIdentifier(identifier: ResourceIdentifier): void {\n    if (!this.identifierStrategy.supportsIdentifier(identifier)) {\n      throw new NotFoundHttpError();\n    }\n  }\n\n  /**\n   * Verify if the given metadata matches the conditions.\n   */\n  protected validateConditions(conditions?: Conditions, metadata?: RepresentationMetadata): void {\n    // The 412 (Precondition Failed) status code indicates\n    // that one or more conditions given in the request header fields evaluated to false when tested on the server.\n    if (conditions && !conditions.matchesMetadata(metadata)) {\n      throw new PreconditionFailedHttpError();\n    }\n  }\n\n  /**\n   * Returns the metadata matching the identifier, ignoring the presence of a trailing slash or not.\n   *\n   * Solid, §3.1: \"If two URIs differ only in the trailing slash,\n   * and the server has associated a resource with one of them,\n   * then the other URI MUST NOT correspond to another resource.\"\n   * https://solid.github.io/specification/protocol#uri-slash-semantics\n   *\n   * First the identifier gets requested and if no result is found\n   * the identifier with differing trailing slash is requested.\n   * @param identifier - Identifier that needs to be checked.\n   */\n  protected async getNormalizedMetadata(\n    identifier: ResourceIdentifier,\n  ): Promise<RepresentationMetadata> {\n    const hasSlash = isContainerIdentifier(identifier);\n    try {\n      return await this.accessor.getMetadata(identifier);\n    } catch (error: unknown) {\n      if (NotFoundHttpError.isInstance(error)) {\n        const otherIdentifier =\n          { path: hasSlash ? trimTrailingSlashes(identifier.path) : ensureTrailingSlash(identifier.path) };\n\n        // Only try to access other identifier if it is valid in the scope of the DataAccessor\n        this.validateIdentifier(otherIdentifier);\n        return this.accessor.getMetadata(otherIdentifier);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Returns the result of `getNormalizedMetadata` or undefined if a 404 error is thrown.\n   */\n  protected async getSafeNormalizedMetadata(identifier: ResourceIdentifier):\n  Promise<RepresentationMetadata | undefined> {\n    try {\n      return await this.getNormalizedMetadata(identifier);\n    } catch (error: unknown) {\n      if (!NotFoundHttpError.isInstance(error)) {\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Write the given resource to the DataAccessor. Metadata will be updated with necessary triples.\n   * In case of containers `handleContainerData` will be used to verify the data.\n   * @param identifier - Identifier of the resource.\n   * @param representation - Corresponding Representation.\n   * @param isContainer - Is the incoming resource a container?\n   * @param createContainers - Should parent containers (potentially) be created?\n   * @param exists - If the resource already exists.\n   *\n   * @returns Identifiers of resources that were possibly modified.\n   */\n  protected async writeData(identifier: ResourceIdentifier, representation: Representation, isContainer: boolean,\n    createContainers: boolean, exists: boolean): Promise<ModifiedResource[]> {\n    // Make sure the metadata has the correct identifier and correct type quads\n    // Need to do this before handling container data to have the correct identifier\n    representation.metadata.identifier = DataFactory.namedNode(identifier.path);\n    addResourceMetadata(representation.metadata, isContainer);\n\n    // Validate container data\n    if (isContainer) {\n      await this.handleContainerData(representation);\n    }\n\n    // Validate auxiliary data\n    if (this.auxiliaryStrategy.isAuxiliaryIdentifier(identifier)) {\n      await this.auxiliaryStrategy.validate(representation);\n    }\n\n    // Add date modified metadata\n    updateModifiedDate(representation.metadata);\n\n    // Root container should not have a parent container\n    // Solid, §5.3: \"Servers MUST create intermediate containers and include corresponding containment triples\n    // in container representations derived from the URI path component of PUT and PATCH requests.\"\n    // https://solid.github.io/specification/protocol#writing-resources\n    const modified: ModifiedResource[] = [];\n    if (!this.identifierStrategy.isRootContainer(identifier) && !exists) {\n      const container = this.identifierStrategy.getParentContainer(identifier);\n      if (!createContainers) {\n        modified.push(createModifiedResource(container, ModificationType.changed));\n      } else {\n        const createdResources = await this.createRecursiveContainers(container);\n        // The parent container is marked 'changed'\n        modified.push(\n          ...createdResources.length === 0 ?\n            [ createModifiedResource(container, ModificationType.changed) ] :\n            createdResources,\n        );\n      }\n\n      // Parent container is also modified\n      await this.updateContainerModifiedDate(container);\n    }\n\n    // Remove all generated metadata to prevent it from being stored permanently\n    this.removeResponseMetadata(representation.metadata);\n\n    await (isContainer ?\n      this.accessor.writeContainer(identifier, representation.metadata) :\n      this.accessor.writeDocument(identifier, representation.data, representation.metadata));\n\n    return [\n      ...modified,\n      exists ?\n        createModifiedResource(identifier, ModificationType.changed) :\n        createModifiedResource(identifier, ModificationType.created),\n    ];\n  }\n\n  /**\n   * Verify if the incoming data for a container is valid (RDF and no containment triples).\n   * Adds the container data to its metadata afterwards.\n   *\n   * @param representation - Container representation.\n   */\n  protected async handleContainerData(representation: Representation): Promise<void> {\n    let quads: Quad[];\n    try {\n      // No need to parse the data if it already contains internal/quads\n      if (representation.metadata.contentType === INTERNAL_QUADS) {\n        quads = await arrayifyStream(representation.data);\n      } else {\n        const { contentType, identifier } = representation.metadata;\n        quads = await parseQuads(representation.data, { format: contentType, baseIRI: identifier.value });\n      }\n    } catch (error: unknown) {\n      throw new BadRequestHttpError(`Can only create containers with RDF data. ${createErrorMessage(error)}`,\n        { cause: error });\n    }\n\n    // Solid, §5.3: \"Servers MUST NOT allow HTTP POST, PUT and PATCH to update a container’s containment triples;\n    // if the server receives such a request, it MUST respond with a 409 status code.\"\n    // https://solid.github.io/specification/protocol#writing-resources\n    if (quads.some((quad): boolean => quad.predicate.value === LDP.contains)) {\n      throw new ConflictHttpError('Container bodies are not allowed to have containment triples.');\n    }\n\n    // Input content type doesn't matter anymore\n    representation.metadata.removeAll(CONTENT_TYPE);\n\n    // Container data is stored in the metadata\n    representation.metadata.addQuads(quads);\n  }\n\n  /**\n   * Removes all generated data from metadata to prevent it from being stored permanently.\n   */\n  protected removeResponseMetadata(metadata: RepresentationMetadata): void {\n    metadata.removeQuads(\n      metadata.quads(null, null, null, SOLID_META.terms.ResponseMetadata),\n    );\n  }\n\n  /**\n   * Updates the last modified date of the given container\n   */\n  protected async updateContainerModifiedDate(container: ResourceIdentifier): Promise<void> {\n    const parentMetadata = await this.accessor.getMetadata(container);\n    updateModifiedDate(parentMetadata);\n    this.removeResponseMetadata(parentMetadata);\n    await this.accessor.writeContainer(container, parentMetadata);\n  }\n\n  /**\n   * Generates a new URI for a resource in the given container, potentially using the given slug.\n   *\n   * Solid, §5.3: \"Servers MUST allow creating new resources with a POST request to URI path ending `/`.\n   * Servers MUST create a resource with URI path ending `/{id}` in container `/`.\n   * Servers MUST create a container with URI path ending `/{id}/` in container `/` for requests\n   * including the HTTP Link header with rel=\"type\" targeting a valid LDP container type.\"\n   * https://solid.github.io/specification/protocol#writing-resources\n   *\n   * @param container - Parent container of the new URI.\n   * @param isContainer - Does the new URI represent a container?\n   * @param slug - Slug to use for the new URI.\n   */\n  protected createURI(container: ResourceIdentifier, isContainer: boolean, slug?: string): ResourceIdentifier {\n    const base = ensureTrailingSlash(container.path);\n    const name = (slug && this.cleanSlug(slug)) ?? uuid();\n    const suffix = isContainer ? '/' : '';\n    return { path: `${base}${name}${suffix}` };\n  }\n\n  /**\n   * Clean http Slug to be compatible with the server. Makes sure there are no unwanted characters\n   * e.g.: cleanslug('&%26') returns '%26%26'\n   * @param slug - the slug to clean\n   */\n  protected cleanSlug(slug: string): string {\n    if (/\\/[^/]/u.test(slug)) {\n      throw new BadRequestHttpError('Slugs should not contain slashes');\n    }\n    return toCanonicalUriPath(trimTrailingSlashes(slug));\n  }\n\n  /**\n   * Generate a valid URI to store a new Resource in the given container.\n   * URI will be based on the slug header if there is one and is guaranteed to not exist yet.\n   *\n   * @param container - Identifier of the target container.\n   * @param metadata - Metadata of the new resource.\n   */\n  protected async createSafeUri(container: ResourceIdentifier, metadata: RepresentationMetadata):\n  Promise<ResourceIdentifier> {\n    // Get all values needed for naming the resource\n    const isContainer = this.isNewContainer(metadata);\n    const slug = metadata.get(SOLID_HTTP.slug)?.value;\n    metadata.removeAll(SOLID_HTTP.slug);\n\n    let newID: ResourceIdentifier = this.createURI(container, isContainer, slug);\n\n    // Solid, §5.3: \"When a POST method request with the Slug header targets an auxiliary resource,\n    // the server MUST respond with the 403 status code and response body describing the error.\"\n    // https://solid.github.io/specification/protocol#writing-resources\n    if (this.auxiliaryStrategy.isAuxiliaryIdentifier(newID)) {\n      throw new ForbiddenHttpError('Slug bodies that would result in an auxiliary resource are forbidden');\n    }\n\n    // Make sure we don't already have a resource with this exact name (or with differing trailing slash)\n    const withSlash = { path: ensureTrailingSlash(newID.path) };\n    const withoutSlash = { path: trimTrailingSlashes(newID.path) };\n    if (await this.resourceExists(withSlash) || await this.resourceExists(withoutSlash)) {\n      newID = this.createURI(container, isContainer);\n    }\n\n    return newID;\n  }\n\n  /**\n   * Checks if the given metadata represents a (potential) container,\n   * both based on the metadata and the URI.\n   * @param metadata - Metadata of the (new) resource.\n   * @param suffix - Suffix of the URI. Can be the full URI, but only the last part is required.\n   */\n  protected isNewContainer(metadata: RepresentationMetadata, suffix?: string): boolean {\n    if (this.hasContainerType(metadata.getAll(RDF.type))) {\n      return true;\n    }\n    const slug = suffix ?? metadata.get(SOLID_HTTP.slug)?.value;\n    return Boolean(slug && isContainerPath(slug));\n  }\n\n  /**\n   * Checks in a list of types if any of them match a Container type.\n   */\n  protected hasContainerType(rdfTypes: Term[]): boolean {\n    return rdfTypes.some((type): boolean => type.value === LDP.Container || type.value === LDP.BasicContainer);\n  }\n\n  /**\n   * Verifies if this is the metadata of a root storage container.\n   */\n  protected isRootStorage(metadata: RepresentationMetadata): boolean {\n    return metadata.getAll(RDF.type).some((term): boolean => term.value === PIM.Storage);\n  }\n\n  /**\n   * Checks if the given container has any non-auxiliary resources.\n   */\n  protected async hasProperChildren(container: ResourceIdentifier): Promise<boolean> {\n    for await (const child of this.accessor.getChildren(container)) {\n      if (!this.auxiliaryStrategy.isAuxiliaryIdentifier({ path: child.identifier.value })) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Deletes the given array of auxiliary identifiers.\n   * Does not throw an error if something goes wrong.\n   */\n  protected async safelyDeleteAuxiliaryResources(identifiers: ResourceIdentifier[]): Promise<ResourceIdentifier[]> {\n    const deletedResources: ResourceIdentifier[] = [];\n    await Promise.all(identifiers.map(async(identifier): Promise<void> => {\n      try {\n        await this.accessor.deleteResource(identifier);\n        deletedResources.push(identifier);\n      } catch (error: unknown) {\n        if (!NotFoundHttpError.isInstance(error)) {\n          this.logger.error(`Error deleting auxiliary resource ${identifier.path}: ${createErrorMessage(error)}`);\n        }\n      }\n    }));\n    return deletedResources;\n  }\n\n  /**\n   * Create containers starting from the root until the given identifier corresponds to an existing container.\n   * Will throw errors if the identifier of the last existing \"container\" corresponds to an existing document.\n   * @param container - Identifier of the container which will need to exist.\n   */\n  protected async createRecursiveContainers(container: ResourceIdentifier): Promise<ModifiedResource[]> {\n    // Verify whether the container already exists\n    try {\n      const metadata = await this.getNormalizedMetadata(container);\n      // See #480\n      // Solid, §3.1: \"If two URIs differ only in the trailing slash, and the server has associated a resource with\n      // one of them, then the other URI MUST NOT correspond to another resource. Instead, the server MAY respond to\n      // requests for the latter URI with a 301 redirect to the former.\"\n      // https://solid.github.io/specification/protocol#uri-slash-semantics\n      if (!isContainerPath(metadata.identifier.value)) {\n        throw new ForbiddenHttpError(`Creating container ${container.path} conflicts with an existing resource.`);\n      }\n      return [];\n    } catch (error: unknown) {\n      if (!NotFoundHttpError.isInstance(error)) {\n        throw error;\n      }\n    }\n\n    // Create the container, starting with its parent\n    const ancestors = this.identifierStrategy.isRootContainer(container) ?\n      [] :\n      await this.createRecursiveContainers(this.identifierStrategy.getParentContainer(container));\n    await this.writeData(container, new BasicRepresentation([], container), true, false, false);\n    return [ ...ancestors, createModifiedResource(container, ModificationType.created) ];\n  }\n}\n"]}