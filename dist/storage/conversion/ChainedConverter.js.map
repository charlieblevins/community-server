{"version":3,"file":"ChainedConverter.js","sourceRoot":"","sources":["../../../src/storage/conversion/ChainedConverter.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Representation } from '../../http/representation/Representation';\nimport type { ValuePreference, ValuePreferences } from '../../http/representation/RepresentationPreferences';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport { BadRequestHttpError } from '../../util/errors/BadRequestHttpError';\nimport { NotImplementedHttpError } from '../../util/errors/NotImplementedHttpError';\nimport { cleanPreferences, getBestPreference, getTypeWeight } from './ConversionUtil';\nimport type { RepresentationConverterArgs } from './RepresentationConverter';\nimport { RepresentationConverter } from './RepresentationConverter';\nimport type { TypedRepresentationConverter } from './TypedRepresentationConverter';\n\ntype ConverterPreference = ValuePreference & { converter: TypedRepresentationConverter };\n\n/**\n * A chain of converters that can go from `inTypes` to `outTypes`.\n * `intermediateTypes` contains the exact types that have the highest weight when going from converter i to i+1.\n */\ntype ConversionPath = {\n  converters: TypedRepresentationConverter[];\n  intermediateTypes: string[];\n  inTypes: ValuePreferences;\n  outTypes: ValuePreferences;\n};\n\n/**\n * The result of applying a `ConversionPath` to a specific input.\n */\ntype MatchedPath = {\n  path: ConversionPath;\n  inType: string;\n  outType: string;\n  weight: number;\n};\n\n/**\n * A meta converter that takes an array of other converters as input.\n * It chains these converters by finding a path of converters\n * that can go from the given content-type to the given type preferences.\n * In case there are multiple paths, the one with the highest weight gets found.\n * Will error in case no path can be found.\n *\n * This is not a TypedRepresentationConverter since the supported output types\n * might depend on what is the input content-type.\n *\n * This converter should be the last in a WaterfallHandler if there are multiple,\n * since it will try to convert any representation with a content-type.\n *\n * Some suggestions on how this class can be even more optimized should this ever be needed in the future.\n * Most of these decrease computation time at the cost of more memory.\n *  - The algorithm could start on both ends of a possible path and work towards the middle.\n *  - When creating a path, store the list of unused converters instead of checking every step.\n *  - Caching: https://github.com/solid/community-server/issues/832\n */\nexport class ChainedConverter extends RepresentationConverter {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly converters: TypedRepresentationConverter[];\n\n  public constructor(converters: TypedRepresentationConverter[]) {\n    super();\n    if (converters.length === 0) {\n      throw new Error('At least 1 converter is required.');\n    }\n    this.converters = [ ...converters ];\n  }\n\n  public async canHandle(input: RepresentationConverterArgs): Promise<void> {\n    const type = input.representation.metadata.contentType;\n    if (!type) {\n      throw new BadRequestHttpError('Missing Content-Type header.');\n    }\n  }\n\n  public async handle(input: RepresentationConverterArgs): Promise<Representation> {\n    const match = await this.findPath(input);\n\n    // No conversion needed\n    if (!this.isMatchedPath(match)) {\n      return input.representation;\n    }\n\n    const { path, inType, outType } = match;\n    this.logger.debug(`Converting ${inType} -> ${[ ...path.intermediateTypes, outType ].join(' -> ')}.`);\n\n    const args = { ...input };\n    for (let i = 0; i < path.converters.length - 1; ++i) {\n      const type = path.intermediateTypes[i];\n      args.preferences = { type: { [type]: 1 }};\n      args.representation = await path.converters[i].handle(args);\n    }\n    // For the last converter we set the preferences to the best output type\n    args.preferences = { type: { [outType]: 1 }};\n    return path.converters.slice(-1)[0].handle(args);\n  }\n\n  private isMatchedPath(path: unknown): path is MatchedPath {\n    return typeof (path as MatchedPath).path === 'object';\n  }\n\n  /**\n   * Finds a conversion path that can handle the given input.\n   */\n  private async findPath(input: RepresentationConverterArgs): Promise<MatchedPath | ValuePreference> {\n    const type = input.representation.metadata.contentType!;\n    const preferences = cleanPreferences(input.preferences.type);\n\n    const weight = getTypeWeight(type, preferences);\n    if (weight > 0) {\n      this.logger.debug(`No conversion required: ${type} already matches ${Object.keys(preferences)}`);\n      return { value: type, weight };\n    }\n\n    return this.generatePath(type, preferences);\n  }\n\n  /**\n   * Tries to generate the optimal `ConversionPath` that supports the given parameters,\n   * which will then be used to instantiate a specific `MatchedPath` for those parameters.\n   *\n   * Errors if such a path does not exist.\n   */\n  private async generatePath(inType: string, outPreferences: ValuePreferences): Promise<MatchedPath> {\n    // Generate paths from all converters that match the input type\n    let paths = await this.converters.reduce(async(matches: Promise<ConversionPath[]>, converter):\n    Promise<ConversionPath[]> => {\n      const inTypes = await converter.getInputTypes();\n      if (getTypeWeight(inType, inTypes) > 0) {\n        (await matches).push({\n          converters: [ converter ],\n          intermediateTypes: [],\n          inTypes,\n          outTypes: await converter.getOutputTypes(),\n        });\n      }\n      return matches;\n    }, Promise.resolve([]));\n\n    // It's impossible for a path to have a higher weight than this value\n    const maxWeight = Math.max(...Object.values(outPreferences));\n\n    let bestPath = this.findBest(inType, outPreferences, paths);\n    paths = this.removeBadPaths(paths, maxWeight, inType, bestPath);\n    // This will always stop at some point since paths can't have the same converter twice\n    while (paths.length > 0) {\n      // For every path, find all the paths that can be made by adding 1 more converter\n      const promises = paths.map(async(path): Promise<ConversionPath[]> => this.takeStep(path));\n      paths = (await Promise.all(promises)).flat();\n      const newBest = this.findBest(inType, outPreferences, paths);\n      if (newBest && (!bestPath || newBest.weight > bestPath.weight)) {\n        bestPath = newBest;\n      }\n      paths = this.removeBadPaths(paths, maxWeight, inType, bestPath);\n    }\n\n    if (!bestPath) {\n      this.logger.warn(`No conversion path could be made from ${inType} to ${Object.keys(outPreferences)}.`);\n      throw new NotImplementedHttpError(\n        `No conversion path could be made from ${inType} to ${Object.keys(outPreferences)}.`,\n      );\n    }\n    return bestPath;\n  }\n\n  /**\n   * Finds the path from the given list that can convert the given type to the given preferences.\n   * If there are multiple matches the one with the highest result weight gets chosen.\n   * Will return undefined if there are no matches.\n   */\n  private findBest(type: string, preferences: ValuePreferences, paths: ConversionPath[]): MatchedPath | undefined {\n    // Need to use null instead of undefined so `reduce` doesn't take the first element of the array as `best`\n    return paths.reduce((best: MatchedPath | null, path): MatchedPath | null => {\n      const outMatch = getBestPreference(path.outTypes, preferences);\n      if (outMatch && !(best && best.weight >= outMatch.weight)) {\n        // Create new MatchedPath, using the output match above\n        const inWeight = getTypeWeight(type, path.inTypes);\n        return { path, inType: type, outType: outMatch.value, weight: inWeight * outMatch.weight };\n      }\n      return best;\n    }, null) ?? undefined;\n  }\n\n  /**\n   * Filter out paths that can no longer be better than the current best solution.\n   * This depends on a valid path already being found, if not all the input paths will be returned.\n   *\n   * @param paths - Paths to filter.\n   * @param maxWeight - The maximum weight in the output preferences.\n   * @param inType - The input type.\n   * @param bestMatch - The current best path.\n   */\n  private removeBadPaths(paths: ConversionPath[], maxWeight: number, inType: string, bestMatch?: MatchedPath):\n  ConversionPath[] {\n    // All paths are still good if there is no best match yet\n    if (!bestMatch) {\n      return paths;\n    }\n    // Do not improve if the maximum weight has been achieved (accounting for floating point errors)\n    if (bestMatch.weight >= maxWeight - 0.01) {\n      return [];\n    }\n\n    // Only return paths that can potentially improve upon bestPath\n    return paths.filter((path): boolean => {\n      const optimisticWeight = getTypeWeight(inType, path.inTypes) *\n        Math.max(...Object.values(path.outTypes)) *\n        maxWeight;\n      return optimisticWeight > bestMatch.weight;\n    });\n  }\n\n  /**\n   * Finds all converters that could take the output of the given path as input.\n   * For each of these converters a new path gets created which is the input path appended by the converter.\n   */\n  private async takeStep(path: ConversionPath): Promise<ConversionPath[]> {\n    const unusedConverters = this.converters.filter((converter): boolean => !path.converters.includes(converter));\n    const nextConverters = await this.supportedConverters(path.outTypes, unusedConverters);\n\n    // Create a new path for every converter that can be appended\n    return Promise.all(nextConverters.map(async(pref): Promise<ConversionPath> => ({\n      converters: [ ...path.converters, pref.converter ],\n      intermediateTypes: [ ...path.intermediateTypes, pref.value ],\n      inTypes: path.inTypes,\n      outTypes: this.modifyTypeWeights(pref.weight, await pref.converter.getOutputTypes()),\n    })));\n  }\n\n  /**\n   * Creates a new ValuePreferences object, which is equal to the input object\n   * with all values multiplied by the given weight.\n   */\n  private modifyTypeWeights(weight: number, types: ValuePreferences): ValuePreferences {\n    return Object.fromEntries(Object.entries(types).map(([ type, pref ]): [string, number] => [ type, weight * pref ]));\n  }\n\n  /**\n   * Finds all converters in the given list that support taking any of the given types as input.\n   */\n  private async supportedConverters(types: ValuePreferences, converters: TypedRepresentationConverter[]):\n  Promise<ConverterPreference[]> {\n    const promises = converters.map(async(converter): Promise<ConverterPreference | undefined> => {\n      const inputTypes = await converter.getInputTypes();\n      const match = getBestPreference(types, inputTypes);\n      if (match) {\n        return { ...match, converter };\n      }\n    });\n    return (await Promise.all(promises)).filter(Boolean) as ConverterPreference[];\n  }\n}\n"]}