{"version":3,"file":"DynamicJsonToTemplateConverter.js","sourceRoot":"","sources":["../../../src/storage/conversion/DynamicJsonToTemplateConverter.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Term, NamedNode } from 'rdf-js';\nimport { BasicRepresentation } from '../../http/representation/BasicRepresentation';\nimport type { Representation } from '../../http/representation/Representation';\nimport { RepresentationMetadata } from '../../http/representation/RepresentationMetadata';\nimport type { ValuePreferences } from '../../http/representation/RepresentationPreferences';\nimport type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport { APPLICATION_JSON } from '../../util/ContentTypes';\nimport { NotImplementedHttpError } from '../../util/errors/NotImplementedHttpError';\nimport { readableToString } from '../../util/StreamUtil';\nimport type { TemplateEngine } from '../../util/templates/TemplateEngine';\nimport { CONTENT_TYPE, CONTENT_TYPE_TERM, SOLID_META } from '../../util/Vocabularies';\nimport { getConversionTarget } from './ConversionUtil';\nimport { RepresentationConverter } from './RepresentationConverter';\nimport type { RepresentationConverterArgs } from './RepresentationConverter';\n\n/**\n * Converts JSON data by using it as input parameters for rendering a template.\n * The `extension` field can be used to only support a specific type of templates,\n * such as \".ejs\" for EJS templates.\n *\n * To find the templates it expects the Representation metadata to contain `SOLID_META.template` triples,\n * with the objects being the template paths.\n * For each of those templates there also needs to be a CONTENT_TYPE triple\n * describing the content-type of that template.\n *\n * The output of the result depends on the content-type matched with the template.\n */\nexport class DynamicJsonToTemplateConverter extends RepresentationConverter {\n  private readonly templateEngine: TemplateEngine;\n\n  public constructor(templateEngine: TemplateEngine) {\n    super();\n    this.templateEngine = templateEngine;\n  }\n\n  public async canHandle(input: RepresentationConverterArgs): Promise<void> {\n    if (input.representation.metadata.contentType !== APPLICATION_JSON) {\n      throw new NotImplementedHttpError('Only JSON data is supported');\n    }\n\n    const { identifier, representation, preferences } = input;\n\n    // Can only handle this input if we can find a type to convert to\n    const typeMap = this.constructTypeMap(identifier, representation);\n    this.findType(typeMap, preferences.type);\n  }\n\n  public async handle(input: RepresentationConverterArgs): Promise<Representation> {\n    const { identifier, representation, preferences } = input;\n\n    const typeMap = this.constructTypeMap(identifier, representation);\n    const type = this.findType(typeMap, preferences.type);\n\n    const json = JSON.parse(await readableToString(representation.data));\n\n    const rendered = await this.templateEngine.render(json, { templateFile: typeMap[type] });\n    const metadata = new RepresentationMetadata(representation.metadata, { [CONTENT_TYPE]: type });\n\n    return new BasicRepresentation(rendered, metadata);\n  }\n\n  /**\n   * Uses the metadata of the Representation to create a map where each key is a content-type\n   * and each value is the path of the corresponding template.\n   */\n  private constructTypeMap(identifier: ResourceIdentifier, representation: Representation): Record<string, string> {\n    // Finds the templates in the metadata\n    const templates: NamedNode[] = representation.metadata.quads(identifier.path, SOLID_META.terms.template)\n      .map((quad): Term => quad.object)\n      .filter((term: Term): boolean => term.termType === 'NamedNode') as NamedNode[];\n\n    // Maps all content-types to their template\n    const typeMap: Record<string, string> = {};\n    for (const template of templates) {\n      const types = representation.metadata.quads(template, CONTENT_TYPE_TERM).map((quad): string => quad.object.value);\n      for (const type of types) {\n        typeMap[type] = template.value;\n      }\n    }\n    return typeMap;\n  }\n\n  /**\n   * Finds the best content-type to convert to based on the provided templates and preferences.\n   */\n  private findType(typeMap: Record<string, string>, typePreferences: ValuePreferences = {}): string {\n    const typeWeights = Object.fromEntries(Object.keys(typeMap).map((type: string): [ string, 1 ] => [ type, 1 ]));\n    const type = getConversionTarget(typeWeights, typePreferences);\n    if (!type) {\n      throw new NotImplementedHttpError(\n        `No templates found matching ${Object.keys(typePreferences)}, only ${Object.keys(typeMap)}`,\n      );\n    }\n    return type;\n  }\n}\n"]}