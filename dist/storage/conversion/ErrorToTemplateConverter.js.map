{"version":3,"file":"ErrorToTemplateConverter.js","sourceRoot":"","sources":["../../../src/storage/conversion/ErrorToTemplateConverter.ts"],"names":[],"mappings":";;;;;;AAAA,oDAA4B;AAC5B,uFAAoF;AAEpF,0DAAyD;AACzD,2DAAwD;AACxD,kDAA4D;AAC5D,sDAAsD;AAGtD,iFAA8E;AAU9E,MAAM,wBAAwB,GAAoB;IAChD,gBAAgB,EAAE,GAAG,gCAAqB,6BAA6B;IACvE,iBAAiB,EAAE,GAAG,gCAAqB,+BAA+B;IAC1E,SAAS,EAAE,SAAS;IACpB,WAAW,EAAE,eAAe;CAC7B,CAAC;AAEF;;;;;;;;;;GAUG;AACH,MAAa,wBAAyB,SAAQ,2DAA4B;IAOxE,YAAmB,cAA8B,EAAE,eAAiC;;QAClF,KAAK,CAAC,6BAAc,EAAE,MAAA,eAAe,aAAf,eAAe,uBAAf,eAAe,CAAE,WAAW,mCAAI,wBAAwB,CAAC,WAAW,CAAC,CAAC;QAC5F,uFAAuF;QACvF,IAAI,CAAC,eAAe,IAAI,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE;YACjE,eAAe,GAAG,wBAAwB,CAAC;SAC5C;QACD,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;QACrC,IAAI,CAAC,gBAAgB,GAAG,eAAe,CAAC,gBAAiB,CAAC;QAC1D,IAAI,CAAC,iBAAiB,GAAG,eAAe,CAAC,iBAAkB,CAAC;QAC5D,IAAI,CAAC,SAAS,GAAG,eAAe,CAAC,SAAU,CAAC;QAC5C,IAAI,CAAC,WAAW,GAAG,eAAe,CAAC,WAAY,CAAC;IAClD,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,EAAE,cAAc,EAA+B;;QACjE,MAAM,KAAK,GAAG,MAAM,0BAAa,CAAC,cAAc,CAAC,IAAI,CAAU,CAAC;QAEhE,gEAAgE;QAChE,IAAI,WAA+B,CAAC;QACpC,IAAI,qBAAS,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE;YAC/B,IAAI;gBACF,MAAM,YAAY,GAAG,GAAG,KAAK,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;gBAC3D,gBAAM,CAAC,YAAY,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE,6BAA6B,CAAC,CAAC;gBACvE,WAAW,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,MAAA,KAAK,CAAC,OAAO,mCAAI,EAAE,EAChE,EAAE,YAAY,EAAE,YAAY,EAAE,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC;aAC3D;YAAC,MAAM;gBACN,8EAA8E;aAC/E;SACF;QAED,qEAAqE;QACrE,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,KAAK,CAAC;QACvC,MAAM,SAAS,GAAG,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,WAAW,EAAE,CAAC;QACxD,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,SAAS,EAAE,EAAE,YAAY,EAAE,IAAI,CAAC,gBAAgB,EAAE,CAAC,CAAC;QAEtG,OAAO,IAAI,yCAAmB,CAAC,QAAQ,EAAE,cAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;IACtF,CAAC;CACF;AA3CD,4DA2CC","sourcesContent":["import assert from 'assert';\nimport { BasicRepresentation } from '../../http/representation/BasicRepresentation';\nimport type { Representation } from '../../http/representation/Representation';\nimport { INTERNAL_ERROR } from '../../util/ContentTypes';\nimport { HttpError } from '../../util/errors/HttpError';\nimport { modulePathPlaceholder } from '../../util/PathUtil';\nimport { getSingleItem } from '../../util/StreamUtil';\nimport type { TemplateEngine } from '../../util/templates/TemplateEngine';\nimport type { RepresentationConverterArgs } from './RepresentationConverter';\nimport { TypedRepresentationConverter } from './TypedRepresentationConverter';\n\n// Fields optional due to https://github.com/LinkedSoftwareDependencies/Components.js/issues/20\nexport interface TemplateOptions {\n  mainTemplatePath?: string;\n  codeTemplatesPath?: string;\n  extension?: string;\n  contentType?: string;\n}\n\nconst DEFAULT_TEMPLATE_OPTIONS: TemplateOptions = {\n  mainTemplatePath: `${modulePathPlaceholder}templates/error/main.md.hbs`,\n  codeTemplatesPath: `${modulePathPlaceholder}templates/error/descriptions/`,\n  extension: '.md.hbs',\n  contentType: 'text/markdown',\n};\n\n/**\n * Serializes an Error by filling in the provided template.\n * Content-type is based on the constructor parameter.\n *\n * In case the input Error has an `errorCode` value,\n * the converter will look in the `descriptions` for a file\n * with the exact same name as that error code + `extension`.\n * The templating engine will then be applied to that file.\n * That result will be passed as an additional parameter to the main templating call,\n * using the variable `codeMessage`.\n */\nexport class ErrorToTemplateConverter extends TypedRepresentationConverter {\n  private readonly templateEngine: TemplateEngine;\n  private readonly mainTemplatePath: string;\n  private readonly codeTemplatesPath: string;\n  private readonly extension: string;\n  private readonly contentType: string;\n\n  public constructor(templateEngine: TemplateEngine, templateOptions?: TemplateOptions) {\n    super(INTERNAL_ERROR, templateOptions?.contentType ?? DEFAULT_TEMPLATE_OPTIONS.contentType);\n    // Workaround for https://github.com/LinkedSoftwareDependencies/Components.js/issues/20\n    if (!templateOptions || Object.keys(templateOptions).length === 0) {\n      templateOptions = DEFAULT_TEMPLATE_OPTIONS;\n    }\n    this.templateEngine = templateEngine;\n    this.mainTemplatePath = templateOptions.mainTemplatePath!;\n    this.codeTemplatesPath = templateOptions.codeTemplatesPath!;\n    this.extension = templateOptions.extension!;\n    this.contentType = templateOptions.contentType!;\n  }\n\n  public async handle({ representation }: RepresentationConverterArgs): Promise<Representation> {\n    const error = await getSingleItem(representation.data) as Error;\n\n    // Render the error description using an error-specific template\n    let description: string | undefined;\n    if (HttpError.isInstance(error)) {\n      try {\n        const templateFile = `${error.errorCode}${this.extension}`;\n        assert(/^[\\w.-]+$/u.test(templateFile), 'Invalid error template name');\n        description = await this.templateEngine.render(error.details ?? {},\n          { templateFile, templatePath: this.codeTemplatesPath });\n      } catch {\n        // In case no template is found, or rendering errors, we still want to convert\n      }\n    }\n\n    // Render the main template, embedding the rendered error description\n    const { name, message, stack } = error;\n    const variables = { name, message, stack, description };\n    const rendered = await this.templateEngine.render(variables, { templateFile: this.mainTemplatePath });\n\n    return new BasicRepresentation(rendered, representation.metadata, this.contentType);\n  }\n}\n"]}