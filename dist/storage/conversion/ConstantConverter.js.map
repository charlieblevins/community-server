{"version":3,"file":"ConstantConverter.js","sourceRoot":"","sources":["../../../src/storage/conversion/ConstantConverter.ts"],"names":[],"mappings":"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","sourcesContent":["import { createReadStream } from 'fs';\nimport { BasicRepresentation } from '../../http/representation/BasicRepresentation';\nimport type { Representation } from '../../http/representation/Representation';\nimport { NotImplementedHttpError } from '../../util/errors/NotImplementedHttpError';\nimport { isContainerIdentifier } from '../../util/PathUtil';\nimport { matchesMediaType, getTypeWeight, cleanPreferences } from './ConversionUtil';\nimport { RepresentationConverter } from './RepresentationConverter';\nimport type { RepresentationConverterArgs } from './RepresentationConverter';\n\n/**\n * Extra options for the ConstantConverter.\n */\nexport interface ConstantConverterOptions {\n  /**\n   * Whether this should trigger on containers.\n   */\n  container?: boolean;\n  /**\n   * Whether this should trigger on documents.\n   */\n  document?: boolean;\n  /**\n   * The minimum requested quality/preference before this should trigger.\n   */\n  minQuality?: number;\n  /**\n   * Media ranges for which the conversion should happen.\n   */\n  enabledMediaRanges?: string[];\n  /**\n   * Media ranges for which the conversion should not happen.\n   */\n  disabledMediaRanges?: string[];\n}\n\n/**\n * A {@link RepresentationConverter} that ensures\n * a representation for a certain content type is available.\n *\n * Representations of the same content type are served as is;\n * others are replaced by a constant document.\n *\n * This can for example be used to serve an index.html file,\n * which could then interactively load another representation.\n *\n * Options default to the most permissive values when not defined.\n */\nexport class ConstantConverter extends RepresentationConverter {\n  private readonly filePath: string;\n  private readonly contentType: string;\n  private readonly options: Required<ConstantConverterOptions>;\n\n  /**\n   * Creates a new constant converter.\n   *\n   * @param filePath - The path to the constant representation.\n   * @param contentType - The content type of the constant representation.\n   * @param options - Extra options for the converter.\n   */\n  public constructor(filePath: string, contentType: string, options: ConstantConverterOptions = {}) {\n    super();\n    this.filePath = filePath;\n    this.contentType = contentType;\n    this.options = {\n      container: options.container ?? true,\n      document: options.document ?? true,\n      minQuality: options.minQuality ?? 0,\n      enabledMediaRanges: options.enabledMediaRanges ?? [ '*/*' ],\n      disabledMediaRanges: options.disabledMediaRanges ?? [],\n    };\n  }\n\n  public async canHandle({ identifier, preferences, representation }: RepresentationConverterArgs): Promise<void> {\n    // Do not replace the representation if there is no preference for our content type\n    if (!preferences.type) {\n      throw new NotImplementedHttpError('No content type preferences specified');\n    }\n\n    // Do not replace the representation of unsupported resource types\n    const isContainer = isContainerIdentifier(identifier);\n    if (isContainer && !this.options.container) {\n      throw new NotImplementedHttpError('Containers are not supported');\n    }\n    if (!isContainer && !this.options.document) {\n      throw new NotImplementedHttpError('Documents are not supported');\n    }\n\n    // Do not replace the representation if the preference weight is too low\n    const quality = getTypeWeight(this.contentType, cleanPreferences({ ...preferences.type, '*/*': 0 }));\n    if (quality === 0) {\n      throw new NotImplementedHttpError(`No preference for ${this.contentType}`);\n    } else if (quality < this.options.minQuality) {\n      throw new NotImplementedHttpError(`Preference is lower than the specified minimum quality`);\n    }\n\n    const sourceContentType = representation.metadata.contentType ?? '';\n    // Do not replace the representation if it already has our content type\n    if (matchesMediaType(sourceContentType, this.contentType)) {\n      throw new NotImplementedHttpError(`Representation is already ${this.contentType}`);\n    }\n\n    // Only replace the representation if it matches the media range settings\n    if (!this.options.enabledMediaRanges.some((type): boolean => matchesMediaType(sourceContentType, type))) {\n      throw new NotImplementedHttpError(`${sourceContentType} is not one of the enabled media types.`);\n    }\n    if (this.options.disabledMediaRanges.some((type): boolean => matchesMediaType(sourceContentType, type))) {\n      throw new NotImplementedHttpError(`${sourceContentType} is one of the disabled media types.`);\n    }\n  }\n\n  public async handle({ representation }: RepresentationConverterArgs): Promise<Representation> {\n    // Ignore the original representation\n    representation.data.destroy();\n\n    // Create a new representation from the constant file\n    const data = createReadStream(this.filePath, 'utf8');\n    return new BasicRepresentation(data, representation.metadata, this.contentType);\n  }\n}\n"]}