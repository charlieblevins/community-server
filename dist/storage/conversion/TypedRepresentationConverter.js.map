{"version":3,"file":"TypedRepresentationConverter.js","sourceRoot":"","sources":["../../../src/storage/conversion/TypedRepresentationConverter.ts"],"names":[],"mappings":";;;AACA,uFAAoF;AACpF,qDAAsE;AACtE,uEAAoE;AASpE,KAAK,UAAU,kBAAkB,CAAC,GAAwB;IACxD,MAAM,QAAQ,GAAG,MAAM,GAAG,CAAC;IAC3B,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;QAChC,OAAO,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC;KAC1B;IACD,IAAI,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE;QAC3B,OAAO,MAAM,CAAC,WAAW,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,IAAI,EAAoB,EAAE,CAAC,CAAE,IAAI,EAAE,CAAC,CAAE,CAAC,CAAC,CAAC;KAClF;IACD,OAAO,QAAQ,CAAC;AAClB,CAAC;AAED;;GAEG;AACH,MAAsB,4BAA6B,SAAQ,iDAAuB;IAIhF,YAAmB,aAAkC,EAAE,EAAE,cAAmC,EAAE;QAC5F,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,UAAU,GAAG,kBAAkB,CAAC,UAAU,CAAC,CAAC;QACjD,IAAI,CAAC,WAAW,GAAG,kBAAkB,CAAC,WAAW,CAAC,CAAC;IACrD,CAAC;IAED;;OAEG;IACI,KAAK,CAAC,aAAa;QACxB,OAAO,IAAI,CAAC,UAAU,CAAC;IACzB,CAAC;IAED;;OAEG;IACI,KAAK,CAAC,cAAc;QACzB,OAAO,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;IAED;;;;;;;OAOG;IACI,KAAK,CAAC,SAAS,CAAC,IAAiC;;QACtD,MAAM,KAAK,GAAG,CAAE,IAAI,CAAC,aAAa,EAAE,EAAE,IAAI,CAAC,cAAc,EAAE,CAAE,CAAC;QAC9D,MAAM,EAAE,WAAW,EAAE,GAAG,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC;QAErD,IAAI,CAAC,WAAW,EAAE;YAChB,MAAM,IAAI,iDAAuB,CAAC,8CAA8C,CAAC,CAAC;SACnF;QAED,MAAM,CAAE,UAAU,EAAE,WAAW,CAAE,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAC7D,MAAM,iBAAiB,GAAG,MAAA,IAAI,CAAC,WAAW,CAAC,IAAI,mCAAI,EAAE,CAAC;QACtD,IAAI,8BAAa,CAAC,WAAW,EAAE,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,oCAAmB,CAAC,WAAW,EAAE,iBAAiB,CAAC,EAAE;YACxG,MAAM,IAAI,iDAAuB,CAC/B,uBAAuB,WAAW,OAAO,MAAM,CAAC,IAAI,CAAC,iBAAiB,CACtE,eAAe,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,OAAO,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,CACzE,CAAC;SACH;IACH,CAAC;CACF;AAjDD,oEAiDC","sourcesContent":["import type { ValuePreferences } from '../../http/representation/RepresentationPreferences';\nimport { NotImplementedHttpError } from '../../util/errors/NotImplementedHttpError';\nimport { getConversionTarget, getTypeWeight } from './ConversionUtil';\nimport { RepresentationConverter } from './RepresentationConverter';\nimport type { RepresentationConverterArgs } from './RepresentationConverter';\n\ntype PromiseOrValue<T> = T | Promise<T>;\ntype ValuePreferencesArg =\n  PromiseOrValue<string> |\n  PromiseOrValue<string[]> |\n  PromiseOrValue<ValuePreferences>;\n\nasync function toValuePreferences(arg: ValuePreferencesArg): Promise<ValuePreferences> {\n  const resolved = await arg;\n  if (typeof resolved === 'string') {\n    return { [resolved]: 1 };\n  }\n  if (Array.isArray(resolved)) {\n    return Object.fromEntries(resolved.map((type): [string, number] => [ type, 1 ]));\n  }\n  return resolved;\n}\n\n/**\n * A {@link RepresentationConverter} that allows requesting the supported types.\n */\nexport abstract class TypedRepresentationConverter extends RepresentationConverter {\n  protected inputTypes: Promise<ValuePreferences>;\n  protected outputTypes: Promise<ValuePreferences>;\n\n  public constructor(inputTypes: ValuePreferencesArg = {}, outputTypes: ValuePreferencesArg = {}) {\n    super();\n    this.inputTypes = toValuePreferences(inputTypes);\n    this.outputTypes = toValuePreferences(outputTypes);\n  }\n\n  /**\n   * Gets the supported input content types for this converter, mapped to a numerical priority.\n   */\n  public async getInputTypes(): Promise<ValuePreferences> {\n    return this.inputTypes;\n  }\n\n  /**\n   * Gets the supported output content types for this converter, mapped to a numerical quality.\n   */\n  public async getOutputTypes(): Promise<ValuePreferences> {\n    return this.outputTypes;\n  }\n\n  /**\n   * Determines whether the given conversion request is supported,\n   * given the available content type conversions:\n   *  - Checks if there is a content type for the input.\n   *  - Checks if the input type is supported by the parser.\n   *  - Checks if the parser can produce one of the preferred output types.\n   * Throws an error with details if conversion is not possible.\n   */\n  public async canHandle(args: RepresentationConverterArgs): Promise<void> {\n    const types = [ this.getInputTypes(), this.getOutputTypes() ];\n    const { contentType } = args.representation.metadata;\n\n    if (!contentType) {\n      throw new NotImplementedHttpError('Can not convert data without a Content-Type.');\n    }\n\n    const [ inputTypes, outputTypes ] = await Promise.all(types);\n    const outputPreferences = args.preferences.type ?? {};\n    if (getTypeWeight(contentType, inputTypes) === 0 || !getConversionTarget(outputTypes, outputPreferences)) {\n      throw new NotImplementedHttpError(\n        `Cannot convert from ${contentType} to ${Object.keys(outputPreferences)\n        }, only from ${Object.keys(inputTypes)} to ${Object.keys(outputTypes)}.`,\n      );\n    }\n  }\n}\n"]}