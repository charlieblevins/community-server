{"version":3,"file":"ConversionUtil.js","sourceRoot":"","sources":["../../../src/storage/conversion/ConversionUtil.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ValuePreference, ValuePreferences } from '../../http/representation/RepresentationPreferences';\nimport { INTERNAL_ALL } from '../../util/ContentTypes';\nimport { InternalServerError } from '../../util/errors/InternalServerError';\n\n/**\n * Cleans incoming preferences to prevent unwanted behaviour.\n * Makes sure internal types have weight 0, unless specifically requested in the preferences,\n * and interprets empty preferences as accepting everything.\n *\n * @param preferences - Preferences that need to be updated.\n *\n * @returns A copy of the the preferences with the necessary updates.\n */\nexport function cleanPreferences(preferences: ValuePreferences = {}): ValuePreferences {\n  // No preference means anything is acceptable\n  const preferred = { ...preferences };\n  if (Object.keys(preferences).length === 0) {\n    preferred['*/*'] = 1;\n  }\n  // Prevent accidental use of internal types\n  if (!(INTERNAL_ALL in preferred)) {\n    preferred[INTERNAL_ALL] = 0;\n  }\n  return preferred;\n}\n\n/**\n * Tries to match the given type to the given preferences.\n * In case there are multiple matches the most specific one will be chosen as per RFC 7231.\n *\n * @param type - Type for which the matching weight is needed.\n * @param preferred - Preferences to match the type to.\n *\n * @returns The corresponding weight from the preferences or 0 if there is no match.\n */\nexport function getTypeWeight(type: string, preferred: ValuePreferences): number {\n  const match = /^([^/]+)\\/([^\\s;]+)/u.exec(type);\n  if (!match) {\n    throw new InternalServerError(`Unexpected media type: ${type}.`);\n  }\n  const [ , main, sub ] = match;\n  // RFC 7231\n  //    Media ranges can be overridden by more specific media ranges or\n  //    specific media types.  If more than one media range applies to a\n  //    given type, the most specific reference has precedence.\n  return preferred[type] ??\n         preferred[`${main}/${sub}`] ??\n         preferred[`${main}/*`] ??\n         preferred['*/*'] ??\n         0;\n}\n\n/**\n * Measures the weights for all the given types when matched against the given preferences.\n * Results will be sorted by weight.\n * Weights of 0 indicate that no match is possible.\n *\n * @param types - Types for which we want to calculate the weights.\n * @param preferred - Preferences to match the types against.\n *\n * @returns An array with a {@link ValuePreference} object for every input type, sorted by calculated weight.\n */\nexport function getWeightedPreferences(types: ValuePreferences, preferred: ValuePreferences): ValuePreference[] {\n  const weightedSupported = Object.entries(types)\n    .map(([ value, quality ]): ValuePreference => ({ value, weight: quality * getTypeWeight(value, preferred) }));\n  return weightedSupported\n    .sort(({ weight: weightA }, { weight: weightB }): number => weightB - weightA);\n}\n\n/**\n * Finds the type from the given types that has the best match with the given preferences,\n * based on the calculated weight.\n *\n * @param types - Types for which we want to find the best match.\n * @param preferred - Preferences to match the types against.\n *\n * @returns A {@link ValuePreference} containing the best match and the corresponding weight.\n * Undefined if there is no match.\n */\nexport function getBestPreference(types: ValuePreferences, preferred: ValuePreferences): ValuePreference | undefined {\n  // Could also return the first entry of the above function but this is more efficient\n  const result = Object.entries(types).reduce((best, [ value, quality ]): ValuePreference => {\n    if (best.weight >= quality) {\n      return best;\n    }\n    const weight = quality * getTypeWeight(value, preferred);\n    if (weight > best.weight) {\n      return { value, weight };\n    }\n    return best;\n  }, { value: '', weight: 0 });\n\n  if (result.weight > 0) {\n    return result;\n  }\n}\n\n/**\n * For a media type converter that can generate the given types,\n * this function tries to find the type that best matches the given preferences.\n *\n * This function combines several other conversion utility functions\n * to determine what output a converter should generate:\n * it cleans the preferences with {@link cleanPreferences} to support empty preferences\n * and to prevent the accidental generation of internal types,\n * after which the best match gets found based on the weights.\n *\n * @param types - Media types that can be converted to.\n * @param preferred - Preferences for output type.\n *\n * @returns The best match. Undefined if there is no match.\n */\nexport function getConversionTarget(types: ValuePreferences, preferred: ValuePreferences = {}): string | undefined {\n  const cleaned = cleanPreferences(preferred);\n\n  return getBestPreference(types, cleaned)?.value;\n}\n\n/**\n * Checks if the given type matches the given preferences.\n *\n * @param type - Type to match.\n * @param preferred - Preferences to match against.\n */\nexport function matchesMediaPreferences(type: string, preferred?: ValuePreferences): boolean {\n  return getTypeWeight(type, cleanPreferences(preferred)) > 0;\n}\n\n/**\n * Checks if the given two media types/ranges match each other.\n * Takes wildcards into account.\n * @param mediaA - Media type to match.\n * @param mediaB - Media type to match.\n *\n * @returns True if the media type patterns can match each other.\n */\nexport function matchesMediaType(mediaA: string, mediaB: string): boolean {\n  if (mediaA === mediaB) {\n    return true;\n  }\n\n  const [ typeA, subTypeA ] = mediaA.split('/');\n  const [ typeB, subTypeB ] = mediaB.split('/');\n  if (typeA === '*' || typeB === '*') {\n    return true;\n  }\n  if (typeA !== typeB) {\n    return false;\n  }\n  if (subTypeA === '*' || subTypeB === '*') {\n    return true;\n  }\n  return subTypeA === subTypeB;\n}\n\n/**\n * Checks if the given content type is an internal content type such as internal/quads.\n * Response will be `false` if the input type is undefined.\n *\n * Do not use this for media ranges.\n *\n * @param contentType - Type to check.\n */\nexport function isInternalContentType(contentType?: string): boolean {\n  return typeof contentType !== 'undefined' && matchesMediaType(contentType, INTERNAL_ALL);\n}\n"]}