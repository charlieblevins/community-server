{"version":3,"file":"InMemoryDataAccessor.js","sourceRoot":"","sources":["../../../src/storage/accessors/InMemoryDataAccessor.ts"],"names":[],"mappings":";;;;;;AACA,sEAA6C;AAC7C,6FAA0F;AAE1F,+EAA4E;AAC5E,2EAAwE;AAGxE,sDAA0D;AAa1D,MAAa,oBAAoB;IAK/B,YAAmB,kBAAsC;QACvD,IAAI,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;QAE7C,IAAI,CAAC,KAAK,GAAG,EAAE,OAAO,EAAE,EAAG,EAAC,CAAC;IAC/B,CAAC;IAEM,KAAK,CAAC,SAAS;QACpB,kEAAkE;IACpE,CAAC;IAEM,KAAK,CAAC,OAAO,CAAC,UAA8B;QACjD,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;QACxC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE;YAC5B,MAAM,IAAI,qCAAiB,EAAE,CAAC;SAC/B;QACD,OAAO,8BAAiB,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IACvC,CAAC;IAEM,KAAK,CAAC,WAAW,CAAC,UAA8B;QACrD,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;QACxC,OAAO,IAAI,+CAAsB,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;IACpD,CAAC;IAEM,KAAK,CAAA,CAAE,WAAW,CAAC,UAA8B;QACtD,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;QACxC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE;YAC5B,MAAM,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;YAC9C,KAAK,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,IAAI,EAA0B,EAAE,CAAC,IAAI,+CAAsB,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;SACrG;IACH,CAAC;IAEM,KAAK,CAAC,aAAa,CAAC,UAA8B,EAAE,IAAuB,EAAE,QAAgC;QAElH,MAAM,MAAM,GAAG,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;QAC/C,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG;YAChC,wCAAwC;YACxC,IAAI,EAAE,MAAM,yBAAc,CAAC,IAAI,CAAC;YAChC,QAAQ;SACT,CAAC;IACJ,CAAC;IAEM,KAAK,CAAC,cAAc,CAAC,UAA8B,EAAE,QAAgC;QAC1F,IAAI;YACF,4EAA4E;YAC5E,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YACxC,KAAK,CAAC,QAAQ,GAAG,QAAQ,CAAC;SAC3B;QAAC,OAAO,KAAc,EAAE;YACvB,0CAA0C;YAC1C,IAAI,qCAAiB,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE;gBACvC,MAAM,MAAM,GAAG,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;gBAC/C,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG;oBAChC,OAAO,EAAE,EAAE;oBACX,QAAQ;iBACT,CAAC;aACH;iBAAM;gBACL,MAAM,KAAK,CAAC;aACb;SACF;IACH,CAAC;IAEM,KAAK,CAAC,cAAc,CAAC,UAA8B;QACxD,MAAM,MAAM,GAAG,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;QAC/C,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;YACpC,MAAM,IAAI,qCAAiB,EAAE,CAAC;SAC/B;QACD,gEAAgE;QAChE,OAAO,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;IACzC,CAAC;IAEO,WAAW,CAAC,KAAiB;QACnC,OAAO,OAAO,CAAE,KAAmB,CAAC,IAAI,CAAC,CAAC;IAC5C,CAAC;IAED;;;OAGG;IACK,YAAY,CAAC,UAA8B;QACjD,IAAI,IAAI,CAAC,kBAAkB,CAAC,eAAe,CAAC,UAAU,CAAC,EAAE;YACvD,OAAO,CAAE,UAAU,CAAE,CAAC;SACvB;QACD,MAAM,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,kBAAkB,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC,CAAC;QAC5F,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAC3B,OAAO,SAAS,CAAC;IACnB,CAAC;IAED;;;OAGG;IACK,cAAc,CAAC,UAA8B;QACnD,8EAA8E;QAC9E,IAAI,MAAM,GAAe,IAAI,CAAC,KAAuB,CAAC;QACtD,IAAI,IAAI,CAAC,kBAAkB,CAAC,eAAe,CAAC,UAAU,CAAC,EAAE;YACvD,OAAO,MAAM,CAAC;SACf;QAED,MAAM,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,kBAAkB,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC,CAAC;QAC5F,KAAK,MAAM,KAAK,IAAI,SAAS,EAAE;YAC7B,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YACpC,IAAI,CAAC,MAAM,EAAE;gBACX,MAAM,IAAI,qCAAiB,EAAE,CAAC;aAC/B;YACD,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,EAAE;gBAC5B,MAAM,IAAI,yCAAmB,CAAC,eAAe,CAAC,CAAC;aAChD;SACF;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;;OAGG;IACK,QAAQ,CAAC,UAA8B;QAC7C,MAAM,MAAM,GAAG,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;QAC/C,MAAM,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QAC9C,IAAI,CAAC,KAAK,EAAE;YACV,MAAM,IAAI,qCAAiB,EAAE,CAAC;SAC/B;QACD,OAAO,KAAK,CAAC;IACf,CAAC;CACF;AAhID,oDAgIC","sourcesContent":["import type { Readable } from 'stream';\nimport arrayifyStream from 'arrayify-stream';\nimport { RepresentationMetadata } from '../../http/representation/RepresentationMetadata';\nimport type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport { InternalServerError } from '../../util/errors/InternalServerError';\nimport { NotFoundHttpError } from '../../util/errors/NotFoundHttpError';\nimport type { Guarded } from '../../util/GuardedStream';\nimport type { IdentifierStrategy } from '../../util/identifiers/IdentifierStrategy';\nimport { guardedStreamFrom } from '../../util/StreamUtil';\nimport type { DataAccessor } from './DataAccessor';\n\ninterface DataEntry {\n  data: any[];\n  metadata: RepresentationMetadata;\n}\ninterface ContainerEntry {\n  entries: Record<string, CacheEntry>;\n  metadata: RepresentationMetadata;\n}\ntype CacheEntry = DataEntry | ContainerEntry;\n\nexport class InMemoryDataAccessor implements DataAccessor {\n  private readonly identifierStrategy: IdentifierStrategy;\n  // A dummy container where every entry corresponds to a root container\n  private readonly store: { entries: Record<string, ContainerEntry> };\n\n  public constructor(identifierStrategy: IdentifierStrategy) {\n    this.identifierStrategy = identifierStrategy;\n\n    this.store = { entries: { }};\n  }\n\n  public async canHandle(): Promise<void> {\n    // All data is supported since streams never get read, only copied\n  }\n\n  public async getData(identifier: ResourceIdentifier): Promise<Guarded<Readable>> {\n    const entry = this.getEntry(identifier);\n    if (!this.isDataEntry(entry)) {\n      throw new NotFoundHttpError();\n    }\n    return guardedStreamFrom(entry.data);\n  }\n\n  public async getMetadata(identifier: ResourceIdentifier): Promise<RepresentationMetadata> {\n    const entry = this.getEntry(identifier);\n    return new RepresentationMetadata(entry.metadata);\n  }\n\n  public async* getChildren(identifier: ResourceIdentifier): AsyncIterableIterator<RepresentationMetadata> {\n    const entry = this.getEntry(identifier);\n    if (!this.isDataEntry(entry)) {\n      const childNames = Object.keys(entry.entries);\n      yield* childNames.map((name): RepresentationMetadata => new RepresentationMetadata({ path: name }));\n    }\n  }\n\n  public async writeDocument(identifier: ResourceIdentifier, data: Guarded<Readable>, metadata: RepresentationMetadata):\n  Promise<void> {\n    const parent = this.getParentEntry(identifier);\n    parent.entries[identifier.path] = {\n      // Drain original stream and create copy\n      data: await arrayifyStream(data),\n      metadata,\n    };\n  }\n\n  public async writeContainer(identifier: ResourceIdentifier, metadata: RepresentationMetadata): Promise<void> {\n    try {\n      // Overwrite existing metadata but keep children if container already exists\n      const entry = this.getEntry(identifier);\n      entry.metadata = metadata;\n    } catch (error: unknown) {\n      // Create new entry if it didn't exist yet\n      if (NotFoundHttpError.isInstance(error)) {\n        const parent = this.getParentEntry(identifier);\n        parent.entries[identifier.path] = {\n          entries: {},\n          metadata,\n        };\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  public async deleteResource(identifier: ResourceIdentifier): Promise<void> {\n    const parent = this.getParentEntry(identifier);\n    if (!parent.entries[identifier.path]) {\n      throw new NotFoundHttpError();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n    delete parent.entries[identifier.path];\n  }\n\n  private isDataEntry(entry: CacheEntry): entry is DataEntry {\n    return Boolean((entry as DataEntry).data);\n  }\n\n  /**\n   * Generates an array of identifiers corresponding to the nested containers until the given identifier is reached.\n   * This does not verify if these identifiers actually exist.\n   */\n  private getHierarchy(identifier: ResourceIdentifier): ResourceIdentifier[] {\n    if (this.identifierStrategy.isRootContainer(identifier)) {\n      return [ identifier ];\n    }\n    const hierarchy = this.getHierarchy(this.identifierStrategy.getParentContainer(identifier));\n    hierarchy.push(identifier);\n    return hierarchy;\n  }\n\n  /**\n   * Returns the ContainerEntry corresponding to the parent container of the given identifier.\n   * Will throw 404 if the parent does not exist.\n   */\n  private getParentEntry(identifier: ResourceIdentifier): ContainerEntry {\n    // Casting is fine here as the parent should never be used as a real container\n    let parent: CacheEntry = this.store as ContainerEntry;\n    if (this.identifierStrategy.isRootContainer(identifier)) {\n      return parent;\n    }\n\n    const hierarchy = this.getHierarchy(this.identifierStrategy.getParentContainer(identifier));\n    for (const entry of hierarchy) {\n      parent = parent.entries[entry.path];\n      if (!parent) {\n        throw new NotFoundHttpError();\n      }\n      if (this.isDataEntry(parent)) {\n        throw new InternalServerError('Invalid path.');\n      }\n    }\n\n    return parent;\n  }\n\n  /**\n   * Returns the CacheEntry corresponding the given identifier.\n   * Will throw 404 if the resource does not exist.\n   */\n  private getEntry(identifier: ResourceIdentifier): CacheEntry {\n    const parent = this.getParentEntry(identifier);\n    const entry = parent.entries[identifier.path];\n    if (!entry) {\n      throw new NotFoundHttpError();\n    }\n    return entry;\n  }\n}\n"]}