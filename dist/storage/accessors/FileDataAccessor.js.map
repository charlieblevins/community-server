{"version":3,"file":"FileDataAccessor.js","sourceRoot":"","sources":["../../../src/storage/accessors/FileDataAccessor.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Stats } from 'fs';\nimport { createWriteStream, createReadStream, promises as fsPromises } from 'fs';\nimport type { Readable } from 'stream';\nimport type { Quad } from 'rdf-js';\nimport type { Representation } from '../../http/representation/Representation';\nimport { RepresentationMetadata } from '../../http/representation/RepresentationMetadata';\nimport type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport { NotFoundHttpError } from '../../util/errors/NotFoundHttpError';\nimport { isSystemError } from '../../util/errors/SystemError';\nimport { UnsupportedMediaTypeHttpError } from '../../util/errors/UnsupportedMediaTypeHttpError';\nimport { guardStream } from '../../util/GuardedStream';\nimport type { Guarded } from '../../util/GuardedStream';\nimport { joinFilePath, isContainerIdentifier } from '../../util/PathUtil';\nimport { parseQuads, serializeQuads } from '../../util/QuadUtil';\nimport { addResourceMetadata, updateModifiedDate } from '../../util/ResourceUtil';\nimport { toLiteral } from '../../util/TermUtil';\nimport { CONTENT_TYPE, DC, LDP, POSIX, RDF, SOLID_META, XSD } from '../../util/Vocabularies';\nimport type { FileIdentifierMapper, ResourceLink } from '../mapping/FileIdentifierMapper';\nimport type { DataAccessor } from './DataAccessor';\n\n/**\n * DataAccessor that uses the file system to store documents as files and containers as folders.\n */\nexport class FileDataAccessor implements DataAccessor {\n  private readonly resourceMapper: FileIdentifierMapper;\n\n  public constructor(resourceMapper: FileIdentifierMapper) {\n    this.resourceMapper = resourceMapper;\n  }\n\n  /**\n   * Only binary data can be directly stored as files so will error on non-binary data.\n   */\n  public async canHandle(representation: Representation): Promise<void> {\n    if (!representation.binary) {\n      throw new UnsupportedMediaTypeHttpError('Only binary data is supported.');\n    }\n  }\n\n  /**\n   * Will return data stream directly to the file corresponding to the resource.\n   * Will throw NotFoundHttpError if the input is a container.\n   */\n  public async getData(identifier: ResourceIdentifier): Promise<Guarded<Readable>> {\n    const link = await this.resourceMapper.mapUrlToFilePath(identifier, false);\n    const stats = await this.getStats(link.filePath);\n\n    if (stats.isFile()) {\n      return guardStream(createReadStream(link.filePath));\n    }\n\n    throw new NotFoundHttpError();\n  }\n\n  /**\n   * Will return corresponding metadata by reading the metadata file (if it exists)\n   * and adding file system specific metadata elements.\n   */\n  public async getMetadata(identifier: ResourceIdentifier): Promise<RepresentationMetadata> {\n    const link = await this.resourceMapper.mapUrlToFilePath(identifier, false);\n    const stats = await this.getStats(link.filePath);\n    if (!isContainerIdentifier(identifier) && stats.isFile()) {\n      return this.getFileMetadata(link, stats);\n    }\n    if (isContainerIdentifier(identifier) && stats.isDirectory()) {\n      return this.getDirectoryMetadata(link, stats);\n    }\n    throw new NotFoundHttpError();\n  }\n\n  public async* getChildren(identifier: ResourceIdentifier): AsyncIterableIterator<RepresentationMetadata> {\n    const link = await this.resourceMapper.mapUrlToFilePath(identifier, false);\n    yield* this.getChildMetadata(link);\n  }\n\n  /**\n   * Writes the given data as a file (and potential metadata as additional file).\n   * The metadata file will be written first and will be deleted if something goes wrong writing the actual data.\n   */\n  public async writeDocument(identifier: ResourceIdentifier, data: Guarded<Readable>, metadata: RepresentationMetadata):\n  Promise<void> {\n    const link = await this.resourceMapper.mapUrlToFilePath(identifier, false, metadata.contentType);\n\n    // Check if we already have a corresponding file with a different extension\n    await this.verifyExistingExtension(link);\n\n    const wroteMetadata = await this.writeMetadata(link, metadata);\n\n    try {\n      await this.writeDataFile(link.filePath, data);\n    } catch (error: unknown) {\n      // Delete the metadata if there was an error writing the file\n      if (wroteMetadata) {\n        const metaLink = await this.resourceMapper.mapUrlToFilePath(identifier, true);\n        await fsPromises.unlink(metaLink.filePath);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Creates corresponding folder if necessary and writes metadata to metadata file if necessary.\n   */\n  public async writeContainer(identifier: ResourceIdentifier, metadata: RepresentationMetadata): Promise<void> {\n    const link = await this.resourceMapper.mapUrlToFilePath(identifier, false);\n    try {\n      await fsPromises.mkdir(link.filePath, { recursive: true });\n    } catch (error: unknown) {\n      // Don't throw if directory already exists\n      if (!isSystemError(error) || error.code !== 'EEXIST') {\n        throw error;\n      }\n    }\n\n    await this.writeMetadata(link, metadata);\n  }\n\n  /**\n   * Removes the corresponding file/folder (and metadata file).\n   */\n  public async deleteResource(identifier: ResourceIdentifier): Promise<void> {\n    const link = await this.resourceMapper.mapUrlToFilePath(identifier, false);\n    const stats = await this.getStats(link.filePath);\n\n    try {\n      const metaLink = await this.resourceMapper.mapUrlToFilePath(identifier, true);\n      await fsPromises.unlink(metaLink.filePath);\n    } catch (error: unknown) {\n      // Ignore if it doesn't exist\n      if (!isSystemError(error) || error.code !== 'ENOENT') {\n        throw error;\n      }\n    }\n\n    if (!isContainerIdentifier(identifier) && stats.isFile()) {\n      await fsPromises.unlink(link.filePath);\n    } else if (isContainerIdentifier(identifier) && stats.isDirectory()) {\n      await fsPromises.rmdir(link.filePath);\n    } else {\n      throw new NotFoundHttpError();\n    }\n  }\n\n  /**\n   * Gets the Stats object corresponding to the given file path,\n   * resolving symbolic links.\n   * @param path - File path to get info from.\n   *\n   * @throws NotFoundHttpError\n   * If the file/folder doesn't exist.\n   */\n  private async getStats(path: string): Promise<Stats> {\n    try {\n      return await fsPromises.stat(path);\n    } catch (error: unknown) {\n      if (isSystemError(error) && error.code === 'ENOENT') {\n        throw new NotFoundHttpError('', { cause: error });\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Reads and generates all metadata relevant for the given file,\n   * ingesting it into a RepresentationMetadata object.\n   *\n   * @param link - Path related metadata.\n   * @param stats - Stats object of the corresponding file.\n   */\n  private async getFileMetadata(link: ResourceLink, stats: Stats):\n  Promise<RepresentationMetadata> {\n    return (await this.getBaseMetadata(link, stats, false))\n      .set(CONTENT_TYPE, link.contentType);\n  }\n\n  /**\n   * Reads and generates all metadata relevant for the given directory,\n   * ingesting it into a RepresentationMetadata object.\n   *\n   * @param link - Path related metadata.\n   * @param stats - Stats object of the corresponding directory.\n   */\n  private async getDirectoryMetadata(link: ResourceLink, stats: Stats):\n  Promise<RepresentationMetadata> {\n    return await this.getBaseMetadata(link, stats, true);\n  }\n\n  /**\n   * Writes the metadata of the resource to a meta file.\n   * @param link - Path related metadata of the resource.\n   * @param metadata - Metadata to write.\n   *\n   * @returns True if data was written to a file.\n   */\n  private async writeMetadata(link: ResourceLink, metadata: RepresentationMetadata): Promise<boolean> {\n    // These are stored by file system conventions\n    metadata.remove(RDF.terms.type, LDP.terms.Resource);\n    metadata.remove(RDF.terms.type, LDP.terms.Container);\n    metadata.remove(RDF.terms.type, LDP.terms.BasicContainer);\n    metadata.removeAll(DC.terms.modified);\n    metadata.removeAll(CONTENT_TYPE);\n    const quads = metadata.quads();\n    const metadataLink = await this.resourceMapper.mapUrlToFilePath(link.identifier, true);\n    let wroteMetadata: boolean;\n\n    // Write metadata to file if there are quads remaining\n    if (quads.length > 0) {\n      // Determine required content-type based on mapper\n      const serializedMetadata = serializeQuads(quads, metadataLink.contentType);\n      await this.writeDataFile(metadataLink.filePath, serializedMetadata);\n      wroteMetadata = true;\n\n    // Delete (potentially) existing metadata file if no metadata needs to be stored\n    } else {\n      try {\n        await fsPromises.unlink(metadataLink.filePath);\n      } catch (error: unknown) {\n        // Metadata file doesn't exist so nothing needs to be removed\n        if (!isSystemError(error) || error.code !== 'ENOENT') {\n          throw error;\n        }\n      }\n      wroteMetadata = false;\n    }\n    return wroteMetadata;\n  }\n\n  /**\n   * Generates metadata relevant for any resources stored by this accessor.\n   * @param link - Path related metadata.\n   * @param stats - Stats objects of the corresponding directory.\n   * @param isContainer - If the path points to a container (directory) or not.\n   */\n  private async getBaseMetadata(link: ResourceLink, stats: Stats, isContainer: boolean):\n  Promise<RepresentationMetadata> {\n    const metadata = new RepresentationMetadata(link.identifier)\n      .addQuads(await this.getRawMetadata(link.identifier));\n    addResourceMetadata(metadata, isContainer);\n    this.addPosixMetadata(metadata, stats);\n    return metadata;\n  }\n\n  /**\n   * Reads the metadata from the corresponding metadata file.\n   * Returns an empty array if there is no metadata file.\n   *\n   * @param identifier - Identifier of the resource (not the metadata!).\n   */\n  private async getRawMetadata(identifier: ResourceIdentifier): Promise<Quad[]> {\n    try {\n      const metadataLink = await this.resourceMapper.mapUrlToFilePath(identifier, true);\n\n      // Check if the metadata file exists first\n      await fsPromises.lstat(metadataLink.filePath);\n\n      const readMetadataStream = guardStream(createReadStream(metadataLink.filePath));\n      return await parseQuads(readMetadataStream, { format: metadataLink.contentType, baseIRI: identifier.path });\n    } catch (error: unknown) {\n      // Metadata file doesn't exist so lets keep `rawMetaData` an empty array.\n      if (!isSystemError(error) || error.code !== 'ENOENT') {\n        throw error;\n      }\n      return [];\n    }\n  }\n\n  /**\n   * Generate metadata for all children in a container.\n   *\n   * @param link - Path related metadata.\n   */\n  private async* getChildMetadata(link: ResourceLink): AsyncIterableIterator<RepresentationMetadata> {\n    const dir = await fsPromises.opendir(link.filePath);\n\n    // For every child in the container we want to generate specific metadata\n    for await (const entry of dir) {\n      // Obtain details of the entry, resolving any symbolic links\n      const childPath = joinFilePath(link.filePath, entry.name);\n      let childStats;\n      try {\n        childStats = await this.getStats(childPath);\n      } catch {\n        // Skip this entry if details could not be retrieved (e.g., bad symbolic link)\n        continue;\n      }\n\n      // Ignore non-file/directory entries in the folder\n      if (!childStats.isFile() && !childStats.isDirectory()) {\n        continue;\n      }\n\n      // Generate the URI corresponding to the child resource\n      const childLink = await this.resourceMapper.mapFilePathToUrl(childPath, childStats.isDirectory());\n\n      // Hide metadata files\n      if (childLink.isMetadata) {\n        continue;\n      }\n\n      // Generate metadata of this specific child\n      const metadata = new RepresentationMetadata(childLink.identifier);\n      addResourceMetadata(metadata, childStats.isDirectory());\n      this.addPosixMetadata(metadata, childStats);\n      yield metadata;\n    }\n  }\n\n  /**\n   * Helper function to add file system related metadata.\n   * @param metadata - metadata object to add to\n   * @param stats - Stats of the file/directory corresponding to the resource.\n   */\n  private addPosixMetadata(metadata: RepresentationMetadata, stats: Stats): void {\n    updateModifiedDate(metadata, stats.mtime);\n    metadata.add(POSIX.terms.mtime,\n      toLiteral(Math.floor(stats.mtime.getTime() / 1000), XSD.terms.integer),\n      SOLID_META.terms.ResponseMetadata);\n    if (!stats.isDirectory()) {\n      metadata.add(POSIX.terms.size, toLiteral(stats.size, XSD.terms.integer), SOLID_META.terms.ResponseMetadata);\n    }\n  }\n\n  /**\n   * Verifies if there already is a file corresponding to the given resource.\n   * If yes, that file is removed if it does not match the path given in the input ResourceLink.\n   * This can happen if the content-type differs from the one that was stored.\n   *\n   * @param link - ResourceLink corresponding to the new resource data.\n   */\n  private async verifyExistingExtension(link: ResourceLink): Promise<void> {\n    try {\n      // Delete the old file with the (now) wrong extension\n      const oldLink = await this.resourceMapper.mapUrlToFilePath(link.identifier, false);\n      if (oldLink.filePath !== link.filePath) {\n        await fsPromises.unlink(oldLink.filePath);\n      }\n    } catch (error: unknown) {\n      // Ignore it if the file didn't exist yet and couldn't be unlinked\n      if (!isSystemError(error) || error.code !== 'ENOENT') {\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Helper function without extra validation checking to create a data file.\n   * @param path - The filepath of the file to be created.\n   * @param data - The data to be put in the file.\n   */\n  private async writeDataFile(path: string, data: Readable): Promise<void> {\n    return new Promise((resolve, reject): any => {\n      const writeStream = createWriteStream(path);\n      data.pipe(writeStream);\n      data.on('error', reject);\n\n      writeStream.on('error', reject);\n      writeStream.on('finish', resolve);\n    });\n  }\n}\n"]}