{"version":3,"file":"ConvertingPatcher.js","sourceRoot":"","sources":["../../../src/storage/patch/ConvertingPatcher.ts"],"names":[],"mappings":";;;AAAA,uFAAoF;AAEpF,mDAAqD;AAGrD,mEAAgE;AAEhE;;;;;;;;GAQG;AACH,MAAa,iBAAkB,SAAQ,6CAAqB;IAQ1D;;;;;OAKG;IACH,YAAmB,OAA8B,EAAE,SAAkC,EAAE,gBAAyB,EAC9G,WAAoB;QACpB,KAAK,EAAE,CAAC;QAfS,WAAM,GAAG,sBAAY,CAAC,IAAI,CAAC,CAAC;QAgB7C,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;QACzC,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;IACjC,CAAC;IAEM,KAAK,CAAC,SAAS,CAAC,KAAiC;QACtD,qEAAqE;QACrE,MAAM,EAAE,UAAU,EAAE,cAAc,EAAE,GAAG,KAAK,CAAC;QAC7C,IAAI,oBAAoB,GAAG,cAAc,CAAC;QAC1C,IAAI,cAAc,IAAI,IAAI,CAAC,gBAAgB,EAAE;YAC3C,MAAM,WAAW,GAAG,EAAE,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,gBAAgB,CAAC,EAAE,CAAC,EAAE,EAAC,CAAC;YAC5D,MAAM,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,EAAE,cAAc,EAAE,UAAU,EAAE,WAAW,EAAE,CAAC,CAAC;YAC5E,oBAAoB,GAAG,IAAI,yCAAmB,CAAC,EAAE,EAAE,cAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;SACpG;QAED,+DAA+D;QAC/D,MAAM,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE,GAAG,KAAK,EAAE,cAAc,EAAE,oBAAoB,EAAE,CAAC,CAAC;IACnF,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,KAAiC;QACnD,MAAM,EAAE,UAAU,EAAE,cAAc,EAAE,GAAG,KAAK,CAAC;QAC7C,IAAI,UAA8B,CAAC;QACnC,IAAI,SAAS,GAAG,cAAc,CAAC;QAC/B,IAAI,CAAC,cAAc,EAAE;YACnB,yFAAyF;YACzF,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC;SAC/B;aAAM,IAAI,IAAI,CAAC,gBAAgB,EAAE;YAChC,wDAAwD;YACxD,UAAU,GAAG,cAAc,CAAC,QAAQ,CAAC,WAAW,CAAC;YACjD,MAAM,WAAW,GAAG,EAAE,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,gBAAgB,CAAC,EAAE,CAAC,EAAE,EAAC,CAAC;YAC5D,SAAS,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,EAAE,cAAc,EAAE,UAAU,EAAE,WAAW,EAAE,CAAC,CAAC;SACtF;QAED,2EAA2E;QAC3E,IAAI,MAAM,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,GAAG,KAAK,EAAE,cAAc,EAAE,SAAS,EAAE,CAAC,CAAC;QAEhF,6FAA6F;QAC7F,IAAI,UAAU,EAAE;YACd,MAAM,WAAW,GAAG,EAAE,IAAI,EAAE,EAAE,CAAC,UAAU,CAAC,EAAE,CAAC,EAAE,EAAC,CAAC;YACjD,MAAM,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,EAAE,cAAc,EAAE,MAAM,EAAE,UAAU,EAAE,WAAW,EAAE,CAAC,CAAC;SAC3F;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AA9DD,8CA8DC","sourcesContent":["import { BasicRepresentation } from '../../http/representation/BasicRepresentation';\nimport type { Representation } from '../../http/representation/Representation';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport type { RepresentationConverter } from '../conversion/RepresentationConverter';\nimport type { RepresentationPatcherInput } from './RepresentationPatcher';\nimport { RepresentationPatcher } from './RepresentationPatcher';\n\n/**\n * A `ConvertingPatcher` converts a document to its `intermediateType`,\n * sends the result to the wrapped patcher, and then converts back to its original type.\n * No changes will take place if no `intermediateType` is provided.\n *\n * In case there is no resource yet and a new one needs to be created,\n * the result of the wrapped patcher will be converted to the provided `defaultType`.\n * In case no `defaultType` is provided, the patcher output will be returned directly.\n */\nexport class ConvertingPatcher extends RepresentationPatcher {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly patcher: RepresentationPatcher;\n  private readonly converter: RepresentationConverter;\n  private readonly intermediateType?: string;\n  private readonly defaultType?: string;\n\n  /**\n   * @param patcher - Patcher that will be called with the Representation.\n   * @param converter - Converter that will be used to generate intermediate Representation.\n   * @param intermediateType - Content-type of the intermediate Representation if conversion is needed.\n   * @param defaultType - Content-type in case a new resource gets created and needs to be converted.\n   */\n  public constructor(patcher: RepresentationPatcher, converter: RepresentationConverter, intermediateType?: string,\n    defaultType?: string) {\n    super();\n    this.patcher = patcher;\n    this.converter = converter;\n    this.intermediateType = intermediateType;\n    this.defaultType = defaultType;\n  }\n\n  public async canHandle(input: RepresentationPatcherInput): Promise<void> {\n    // Verify the converter can handle the input representation if needed\n    const { identifier, representation } = input;\n    let convertedPlaceholder = representation;\n    if (representation && this.intermediateType) {\n      const preferences = { type: { [this.intermediateType]: 1 }};\n      await this.converter.canHandle({ representation, identifier, preferences });\n      convertedPlaceholder = new BasicRepresentation([], representation.metadata, this.intermediateType);\n    }\n\n    // Verify the patcher can handle the (converted) representation\n    await this.patcher.canHandle({ ...input, representation: convertedPlaceholder });\n  }\n\n  public async handle(input: RepresentationPatcherInput): Promise<Representation> {\n    const { identifier, representation } = input;\n    let outputType: string | undefined;\n    let converted = representation;\n    if (!representation) {\n      // If there is no representation the output will need to be converted to the default type\n      outputType = this.defaultType;\n    } else if (this.intermediateType) {\n      // Convert incoming representation to the requested type\n      outputType = representation.metadata.contentType;\n      const preferences = { type: { [this.intermediateType]: 1 }};\n      converted = await this.converter.handle({ representation, identifier, preferences });\n    }\n\n    // Call the wrapped patcher with the (potentially) converted representation\n    let result = await this.patcher.handle({ ...input, representation: converted });\n\n    // Convert the output back to its original type or the default type depending on what was set\n    if (outputType) {\n      const preferences = { type: { [outputType]: 1 }};\n      result = await this.converter.handle({ representation: result, identifier, preferences });\n    }\n\n    return result;\n  }\n}\n"]}