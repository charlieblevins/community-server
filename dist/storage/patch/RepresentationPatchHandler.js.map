{"version":3,"file":"RepresentationPatchHandler.js","sourceRoot":"","sources":["../../../src/storage/patch/RepresentationPatchHandler.ts"],"names":[],"mappings":";;;AACA,mDAAqD;AACrD,2EAAwE;AAGxE,iDAA8C;AAG9C;;;;;;GAMG;AACH,MAAa,0BAA2B,SAAQ,2BAAY;IAK1D,YAAmB,OAA8B;QAC/C,KAAK,EAAE,CAAC;QALS,WAAM,GAAG,sBAAY,CAAC,IAAI,CAAC,CAAC;QAM7C,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IACzB,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,EAAE,MAAM,EAAE,KAAK,EAAE,UAAU,EAAqB;QAClE,wCAAwC;QACxC,IAAI,cAA0C,CAAC;QAC/C,IAAI;YACF,cAAc,GAAG,MAAM,MAAM,CAAC,iBAAiB,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC;SACjE;QAAC,OAAO,KAAc,EAAE;YACvB,2EAA2E;YAC3E,qFAAqF;YACrF,0EAA0E;YAC1E,IAAI,CAAC,qCAAiB,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE;gBACxC,MAAM,KAAK,CAAC;aACb;YACD,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,yBAAyB,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC;SAC/D;QAED,WAAW;QACX,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,UAAU,EAAE,cAAc,EAAE,CAAC,CAAC;QAErF,6BAA6B;QAC7B,OAAO,MAAM,CAAC,iBAAiB,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;IACvD,CAAC;CACF;AA/BD,gEA+BC","sourcesContent":["import type { Representation } from '../../http/representation/Representation';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport { NotFoundHttpError } from '../../util/errors/NotFoundHttpError';\nimport type { ModifiedResource } from '../ResourceStore';\nimport type { PatchHandlerInput } from './PatchHandler';\nimport { PatchHandler } from './PatchHandler';\nimport type { RepresentationPatcher } from './RepresentationPatcher';\n\n/**\n * Handles a patch operation by getting the representation from the store, applying a `RepresentationPatcher`,\n * and then writing the result back to the store.\n *\n * In case there is no original representation (the store throws a `NotFoundHttpError`),\n * the patcher is expected to create a new one.\n */\nexport class RepresentationPatchHandler extends PatchHandler {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly patcher: RepresentationPatcher;\n\n  public constructor(patcher: RepresentationPatcher) {\n    super();\n    this.patcher = patcher;\n  }\n\n  public async handle({ source, patch, identifier }: PatchHandlerInput): Promise<ModifiedResource[]> {\n    // Get the representation from the store\n    let representation: Representation | undefined;\n    try {\n      representation = await source.getRepresentation(identifier, {});\n    } catch (error: unknown) {\n      // Solid, ยง5.1: \"When a successful PUT or PATCH request creates a resource,\n      // the server MUST use the effective request URI to assign the URI to that resource.\"\n      // https://solid.github.io/specification/protocol#resource-type-heuristics\n      if (!NotFoundHttpError.isInstance(error)) {\n        throw error;\n      }\n      this.logger.debug(`Patching new resource ${identifier.path}`);\n    }\n\n    // Patch it\n    const patched = await this.patcher.handleSafe({ patch, identifier, representation });\n\n    // Write it back to the store\n    return source.setRepresentation(identifier, patched);\n  }\n}\n"]}