{"version":3,"file":"SparqlUpdatePatcher.js","sourceRoot":"","sources":["../../../src/storage/patch/SparqlUpdatePatcher.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Readable } from 'stream';\nimport type { ActorInitSparql } from '@comunica/actor-init-sparql';\nimport { newEngine } from '@comunica/actor-init-sparql';\nimport type { IQueryResultUpdate } from '@comunica/actor-init-sparql/lib/ActorInitSparql-browser';\nimport { defaultGraph } from '@rdfjs/data-model';\nimport { Store } from 'n3';\nimport type { BaseQuad } from 'rdf-js';\nimport { Algebra } from 'sparqlalgebrajs';\nimport { BasicRepresentation } from '../../http/representation/BasicRepresentation';\nimport type { Patch } from '../../http/representation/Patch';\nimport type { Representation } from '../../http/representation/Representation';\nimport { RepresentationMetadata } from '../../http/representation/RepresentationMetadata';\nimport type { SparqlUpdatePatch } from '../../http/representation/SparqlUpdatePatch';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport { INTERNAL_QUADS } from '../../util/ContentTypes';\nimport { InternalServerError } from '../../util/errors/InternalServerError';\nimport { NotImplementedHttpError } from '../../util/errors/NotImplementedHttpError';\nimport { readableToQuads, readableToString } from '../../util/StreamUtil';\nimport { RepresentationPatcher } from './RepresentationPatcher';\nimport type { RepresentationPatcherInput } from './RepresentationPatcher';\n\n/**\n * Supports application/sparql-update PATCH requests on RDF resources.\n *\n * Only DELETE/INSERT updates without variables are supported.\n */\nexport class SparqlUpdatePatcher extends RepresentationPatcher {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly engine: ActorInitSparql;\n\n  public constructor() {\n    super();\n    this.engine = newEngine();\n  }\n\n  public async canHandle({ patch }: RepresentationPatcherInput): Promise<void> {\n    if (!this.isSparqlUpdate(patch)) {\n      throw new NotImplementedHttpError('Only SPARQL update patches are supported');\n    }\n  }\n\n  public async handle(input: RepresentationPatcherInput): Promise<Representation> {\n    // Verify the patch\n    const { patch, representation, identifier } = input;\n    const op = (patch as SparqlUpdatePatch).algebra;\n\n    // In case of a NOP we can skip everything\n    if (op.type === Algebra.types.NOP) {\n      return representation ?? new BasicRepresentation([], identifier, INTERNAL_QUADS, false);\n    }\n\n    this.validateUpdate(op);\n\n    return this.patch(input);\n  }\n\n  private isSparqlUpdate(patch: Patch): patch is SparqlUpdatePatch {\n    return typeof (patch as SparqlUpdatePatch).algebra === 'object';\n  }\n\n  private isDeleteInsert(op: Algebra.Operation): op is Algebra.DeleteInsert {\n    return op.type === Algebra.types.DELETE_INSERT;\n  }\n\n  private isComposite(op: Algebra.Operation): op is Algebra.CompositeUpdate {\n    return op.type === Algebra.types.COMPOSITE_UPDATE;\n  }\n\n  /**\n   * Checks if the input operation is of a supported type (DELETE/INSERT or composite of those)\n   */\n  private validateUpdate(op: Algebra.Operation): void {\n    if (this.isDeleteInsert(op)) {\n      this.validateDeleteInsert(op);\n    } else if (this.isComposite(op)) {\n      this.validateComposite(op);\n    } else {\n      this.logger.warn(`Unsupported operation: ${op.type}`);\n      throw new NotImplementedHttpError('Only DELETE/INSERT SPARQL update operations are supported');\n    }\n  }\n\n  /**\n   * Checks if the input DELETE/INSERT is supported.\n   * This means: no GRAPH statements, no DELETE WHERE containing terms of type Variable.\n   */\n  private validateDeleteInsert(op: Algebra.DeleteInsert): void {\n    const def = defaultGraph();\n    const deletes = op.delete ?? [];\n    const inserts = op.insert ?? [];\n    if (!deletes.every((pattern): boolean => pattern.graph.equals(def))) {\n      this.logger.warn('GRAPH statement in DELETE clause');\n      throw new NotImplementedHttpError('GRAPH statements are not supported');\n    }\n    if (!inserts.every((pattern): boolean => pattern.graph.equals(def))) {\n      this.logger.warn('GRAPH statement in INSERT clause');\n      throw new NotImplementedHttpError('GRAPH statements are not supported');\n    }\n    if (!(typeof op.where === 'undefined' || op.where.type === Algebra.types.BGP)) {\n      this.logger.warn('Non-BGP WHERE statements are not supported');\n      throw new NotImplementedHttpError('Non-BGP WHERE statements are not supported');\n    }\n  }\n\n  /**\n   * Checks if the composite update only contains supported update components.\n   */\n  private validateComposite(op: Algebra.CompositeUpdate): void {\n    for (const update of op.updates) {\n      this.validateUpdate(update);\n    }\n  }\n\n  /**\n   * Apply the given algebra operation to the given identifier.\n   */\n  private async patch({ identifier, patch, representation }: RepresentationPatcherInput): Promise<Representation> {\n    let result: Store<BaseQuad>;\n    let metadata: RepresentationMetadata;\n\n    if (representation) {\n      ({ metadata } = representation);\n      if (metadata.contentType !== INTERNAL_QUADS) {\n        throw new InternalServerError('Quad stream was expected for patching.');\n      }\n      result = await readableToQuads(representation.data);\n      this.logger.debug(`${result.size} quads in ${identifier.path}.`);\n    } else {\n      metadata = new RepresentationMetadata(identifier, INTERNAL_QUADS);\n      result = new Store<BaseQuad>();\n    }\n\n    // Run the query through Comunica\n    const sparql = await readableToString(patch.data);\n    const query = await this.engine.query(sparql,\n      { sources: [ result ], baseIRI: identifier.path }) as IQueryResultUpdate;\n    await query.updateResult;\n\n    this.logger.debug(`${result.size} quads will be stored to ${identifier.path}.`);\n\n    return new BasicRepresentation(result.match() as unknown as Readable, metadata, false);\n  }\n}\n"]}