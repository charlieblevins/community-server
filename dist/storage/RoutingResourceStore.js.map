{"version":3,"file":"RoutingResourceStore.js","sourceRoot":"","sources":["../../src/storage/RoutingResourceStore.ts"],"names":[],"mappings":";;;AAIA,wEAAqE;AACrE,oFAAiF;AAKjF;;;;GAIG;AACH,MAAa,oBAAoB;IAG/B,YAAmB,IAAgB;QACjC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;IACnB,CAAC;IAEM,KAAK,CAAC,cAAc,CAAC,UAA8B,EAAE,UAAuB;QAEjF,OAAO,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,cAAc,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;IAClF,CAAC;IAEM,KAAK,CAAC,iBAAiB,CAAC,UAA8B,EAAE,WAAsC,EACnG,UAAuB;QACvB,OAAO,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,iBAAiB,CAAC,UAAU,EAAE,WAAW,EAAE,UAAU,CAAC,CAAC;IAClG,CAAC;IAEM,KAAK,CAAC,WAAW,CAAC,SAA6B,EAAE,cAA8B,EACpF,UAAuB;QACvB,OAAO,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,cAAc,CAAC,CAAC,CAAC,WAAW,CAAC,SAAS,EAAE,cAAc,EAAE,UAAU,CAAC,CAAC;IAC7G,CAAC;IAEM,KAAK,CAAC,iBAAiB,CAAC,UAA8B,EAAE,cAA8B,EAC3F,UAAuB;QACvB,OAAO,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE,cAAc,CAAC,CAAC,CAAC,iBAAiB,CAAC,UAAU,EAAE,cAAc,EAAE,UAAU,CAAC,CAAC;IACrH,CAAC;IAEM,KAAK,CAAC,cAAc,CAAC,UAA8B,EACxD,UAAuB;QACvB,OAAO,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,cAAc,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;IAClF,CAAC;IAEM,KAAK,CAAC,cAAc,CAAC,UAA8B,EAAE,KAAY,EACtE,UAAuB;QACvB,OAAO,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,cAAc,CAAC,UAAU,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC;IACzF,CAAC;IAEO,KAAK,CAAC,QAAQ,CAAC,UAA8B,EAAE,cAA+B;QACpF,IAAI,cAAc,EAAE;YAClB,OAAO,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,UAAU,EAAE,cAAc,EAAE,CAAC,CAAC;SAC7D;QAED,gFAAgF;QAChF,IAAI;YACF,OAAO,MAAM,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,UAAU,EAAE,CAAC,CAAC;SACnD;QAAC,OAAO,KAAc,EAAE;YACvB,IAAI,iDAAuB,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE;gBAC7C,MAAM,IAAI,qCAAiB,CAAC,EAAE,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC,CAAC;aACnD;YACD,MAAM,KAAK,CAAC;SACb;IACH,CAAC;CACF;AApDD,oDAoDC","sourcesContent":["import type { Patch } from '../http/representation/Patch';\nimport type { Representation } from '../http/representation/Representation';\nimport type { RepresentationPreferences } from '../http/representation/RepresentationPreferences';\nimport type { ResourceIdentifier } from '../http/representation/ResourceIdentifier';\nimport { NotFoundHttpError } from '../util/errors/NotFoundHttpError';\nimport { NotImplementedHttpError } from '../util/errors/NotImplementedHttpError';\nimport type { Conditions } from './Conditions';\nimport type { ModifiedResource, ResourceStore } from './ResourceStore';\nimport type { RouterRule } from './routing/RouterRule';\n\n/**\n * Store that routes the incoming request to a specific store based on the stored ResourceRouter.\n * In case no store was found for one of the functions that take no data (GET/PATCH/DELETE),\n * a 404 will be thrown. In the other cases the error of the router will be thrown (which would probably be 400).\n */\nexport class RoutingResourceStore implements ResourceStore {\n  private readonly rule: RouterRule;\n\n  public constructor(rule: RouterRule) {\n    this.rule = rule;\n  }\n\n  public async resourceExists(identifier: ResourceIdentifier, conditions?: Conditions):\n  Promise<boolean> {\n    return (await this.getStore(identifier)).resourceExists(identifier, conditions);\n  }\n\n  public async getRepresentation(identifier: ResourceIdentifier, preferences: RepresentationPreferences,\n    conditions?: Conditions): Promise<Representation> {\n    return (await this.getStore(identifier)).getRepresentation(identifier, preferences, conditions);\n  }\n\n  public async addResource(container: ResourceIdentifier, representation: Representation,\n    conditions?: Conditions): Promise<ModifiedResource> {\n    return (await this.getStore(container, representation)).addResource(container, representation, conditions);\n  }\n\n  public async setRepresentation(identifier: ResourceIdentifier, representation: Representation,\n    conditions?: Conditions): Promise<ModifiedResource[]> {\n    return (await this.getStore(identifier, representation)).setRepresentation(identifier, representation, conditions);\n  }\n\n  public async deleteResource(identifier: ResourceIdentifier,\n    conditions?: Conditions): Promise<ModifiedResource[]> {\n    return (await this.getStore(identifier)).deleteResource(identifier, conditions);\n  }\n\n  public async modifyResource(identifier: ResourceIdentifier, patch: Patch,\n    conditions?: Conditions): Promise<ModifiedResource[]> {\n    return (await this.getStore(identifier)).modifyResource(identifier, patch, conditions);\n  }\n\n  private async getStore(identifier: ResourceIdentifier, representation?: Representation): Promise<ResourceStore> {\n    if (representation) {\n      return this.rule.handleSafe({ identifier, representation });\n    }\n\n    // In case there is no incoming data we want to return 404 if no store was found\n    try {\n      return await this.rule.handleSafe({ identifier });\n    } catch (error: unknown) {\n      if (NotImplementedHttpError.isInstance(error)) {\n        throw new NotFoundHttpError('', { cause: error });\n      }\n      throw error;\n    }\n  }\n}\n"]}