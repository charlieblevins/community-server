{"version":3,"file":"FixedContentTypeMapper.js","sourceRoot":"","sources":["../../../src/storage/mapping/FixedContentTypeMapper.ts"],"names":[],"mappings":";;;AACA,2EAAwE;AACxE,uFAAoF;AACpF,yEAAsE;AAGtE;;GAEG;AACH,MAAa,sBAAuB,SAAQ,mDAAwB;IAKlE;;;;;;;;OAQG;IACH,YACE,IAAY,EACZ,YAAoB,EACpB,WAAmB,EACnB,UAAU,GAAG,EAAE,EACf,SAAS,GAAG,EAAE;QAEd,KAAK,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;QAC1B,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAC7B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;IAC7B,CAAC;IAES,KAAK,CAAC,qBAAqB,CAAC,UAA8B,EAAE,WAAoB;QACxF,yCAAyC;QACzC,IAAI,WAAW,IAAI,WAAW,KAAK,IAAI,CAAC,WAAW,EAAE;YACnD,MAAM,IAAI,iDAAuB,CAAC,4BAA4B,WAAW,UAAU,IAAI,CAAC,WAAW,aAAa,CAAC,CAAC;SACnH;QACD,OAAO,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;IAES,KAAK,CAAC,sBAAsB;QACpC,OAAO,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;IAEM,KAAK,CAAC,oBAAoB,CAAC,UAA8B,EAAE,QAAgB,EAAE,WAAoB;QAEtG,oBAAoB;QACpB,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,IAAI,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE;gBACrC,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;aACtD;iBAAM;gBACL,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,wBAAwB,QAAQ,oCAAoC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;gBACvG,MAAM,IAAI,qCAAiB,CACzB,wBAAwB,QAAQ,oCAAoC,IAAI,CAAC,SAAS,EAAE,CACrF,CAAC;aACH;SACF;QAED,OAAO,KAAK,CAAC,oBAAoB,CAAC,UAAU,EAAE,QAAQ,GAAG,IAAI,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC;IACzF,CAAC;IAES,KAAK,CAAC,cAAc,CAAC,QAAgB;QAC7C,qBAAqB;QACrB,IAAI,IAAI,CAAC,UAAU,EAAE;YACnB,IAAI,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;gBACtC,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;aACvD;iBAAM;gBACL,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,yBAAyB,QAAQ,oCAAoC,IAAI,CAAC,UAAU,EAAE,CAAC,CAAC;gBACzG,MAAM,IAAI,qCAAiB,CAAC,QAAQ,QAAQ,uCAAuC,IAAI,CAAC,YAAY,EAAE,CAAC,CAAC;aACzG;SACF;QAED,OAAO,KAAK,CAAC,cAAc,CAAC,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC;IACzD,CAAC;CACF;AArED,wDAqEC","sourcesContent":["import type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport { NotFoundHttpError } from '../../util/errors/NotFoundHttpError';\nimport { NotImplementedHttpError } from '../../util/errors/NotImplementedHttpError';\nimport { BaseFileIdentifierMapper } from './BaseFileIdentifierMapper';\nimport type { ResourceLink } from './FileIdentifierMapper';\n\n/**\n * A mapper that always returns a fixed content type for files.\n */\nexport class FixedContentTypeMapper extends BaseFileIdentifierMapper {\n  protected readonly contentType: string;\n  protected readonly pathSuffix: string;\n  protected readonly urlSuffix: string;\n\n  /**\n   * @param base - Base URL.\n   * @param rootFilepath - Base file path.\n   * @param contentType - Fixed content type that will be used for all resources.\n   * @param pathSuffix - An optional suffix that will be appended to all file paths.\n   *                     Requested file paths without this suffix will be rejected.\n   * @param urlSuffix - An optional suffix that will be appended to all URL.\n   *                    Requested URLs without this suffix will be rejected.\n   */\n  public constructor(\n    base: string,\n    rootFilepath: string,\n    contentType: string,\n    pathSuffix = '',\n    urlSuffix = '',\n  ) {\n    super(base, rootFilepath);\n    this.contentType = contentType;\n    this.pathSuffix = pathSuffix;\n    this.urlSuffix = urlSuffix;\n  }\n\n  protected async getContentTypeFromUrl(identifier: ResourceIdentifier, contentType?: string): Promise<string> {\n    // Only allow the configured content type\n    if (contentType && contentType !== this.contentType) {\n      throw new NotImplementedHttpError(`Unsupported content type ${contentType}, only ${this.contentType} is allowed`);\n    }\n    return this.contentType;\n  }\n\n  protected async getContentTypeFromPath(): Promise<string> {\n    return this.contentType;\n  }\n\n  public async mapUrlToDocumentPath(identifier: ResourceIdentifier, filePath: string, contentType?: string):\n  Promise<ResourceLink> {\n    // Handle URL suffix\n    if (this.urlSuffix) {\n      if (filePath.endsWith(this.urlSuffix)) {\n        filePath = filePath.slice(0, -this.urlSuffix.length);\n      } else {\n        this.logger.warn(`Trying to access URL ${filePath} outside without required suffix ${this.urlSuffix}`);\n        throw new NotFoundHttpError(\n          `Trying to access URL ${filePath} outside without required suffix ${this.urlSuffix}`,\n        );\n      }\n    }\n\n    return super.mapUrlToDocumentPath(identifier, filePath + this.pathSuffix, contentType);\n  }\n\n  protected async getDocumentUrl(relative: string): Promise<string> {\n    // Handle path suffix\n    if (this.pathSuffix) {\n      if (relative.endsWith(this.pathSuffix)) {\n        relative = relative.slice(0, -this.pathSuffix.length);\n      } else {\n        this.logger.warn(`Trying to access file ${relative} outside without required suffix ${this.pathSuffix}`);\n        throw new NotFoundHttpError(`File ${relative} is not part of the file storage at ${this.rootFilepath}`);\n      }\n    }\n\n    return super.getDocumentUrl(relative + this.urlSuffix);\n  }\n}\n"]}