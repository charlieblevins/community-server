{"version":3,"file":"BaseFileIdentifierMapper.js","sourceRoot":"","sources":["../../../src/storage/mapping/BaseFileIdentifierMapper.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport { APPLICATION_OCTET_STREAM } from '../../util/ContentTypes';\nimport { BadRequestHttpError } from '../../util/errors/BadRequestHttpError';\nimport { ConflictHttpError } from '../../util/errors/ConflictHttpError';\nimport { InternalServerError } from '../../util/errors/InternalServerError';\nimport { NotFoundHttpError } from '../../util/errors/NotFoundHttpError';\nimport {\n  decodeUriPathComponents,\n  encodeUriPathComponents,\n  ensureTrailingSlash,\n  isContainerIdentifier,\n  joinFilePath,\n  normalizeFilePath,\n  trimTrailingSlashes,\n} from '../../util/PathUtil';\nimport type { FileIdentifierMapper, ResourceLink } from './FileIdentifierMapper';\n\n/**\n * Base class for {@link FileIdentifierMapper} implementations.\n */\nexport class BaseFileIdentifierMapper implements FileIdentifierMapper {\n  protected readonly logger = getLoggerFor(this);\n  protected readonly baseRequestURI: string;\n  protected readonly rootFilepath: string;\n\n  public constructor(base: string, rootFilepath: string) {\n    this.baseRequestURI = trimTrailingSlashes(base);\n    this.rootFilepath = trimTrailingSlashes(normalizeFilePath(rootFilepath));\n  }\n\n  /**\n   * Maps the given resource identifier / URL to a file path.\n   * Determines the content type if none was provided.\n   * For containers the content-type input is ignored.\n   * @param identifier - The input identifier.\n   * @param isMetadata - If we need the data or metadata file path.\n   * @param contentType - The content-type provided with the request.\n   *\n   * @returns A ResourceLink with all the necessary metadata.\n   */\n  public async mapUrlToFilePath(identifier: ResourceIdentifier, isMetadata: boolean, contentType?: string):\n  Promise<ResourceLink> {\n    // Technically we could allow paths ending on .meta as long as we make sure there is never a mixup.\n    // But this can lead to potential issues.\n    // This also immediately stops users that expect they can update metadata like this.\n    if (this.isMetadataPath(identifier.path)) {\n      throw new ConflictHttpError('Not allowed to create files with the metadata extension.');\n    }\n    let path = this.getRelativePath(identifier);\n    if (isMetadata) {\n      path += '.meta';\n    }\n    this.validateRelativePath(path, identifier);\n\n    const filePath = this.getAbsolutePath(path);\n    return isContainerIdentifier(identifier) ?\n      this.mapUrlToContainerPath(identifier, filePath) :\n      this.mapUrlToDocumentPath(identifier, filePath, contentType);\n  }\n\n  /**\n   * Maps the given container identifier to a file path,\n   * possibly making alterations to the direct translation.\n   * @param identifier - The input identifier.\n   * @param filePath - The direct translation of the identifier onto the file path.\n   *\n   * @returns A ResourceLink with all the necessary metadata.\n   */\n  protected async mapUrlToContainerPath(identifier: ResourceIdentifier, filePath: string): Promise<ResourceLink> {\n    this.logger.debug(`URL ${identifier.path} points to the container ${filePath}`);\n    return { identifier, filePath, isMetadata: this.isMetadataPath(filePath) };\n  }\n\n  /**\n   * Maps the given document identifier to a file path,\n   * possibly making alterations to the direct translation\n   * (for instance, based on its content type)).\n   * Determines the content type if none was provided.\n   * @param identifier - The input identifier.\n   * @param filePath - The direct translation of the identifier onto the file path.\n   * @param contentType - The content-type provided with the request.\n   *\n   * @returns A ResourceLink with all the necessary metadata.\n   */\n  protected async mapUrlToDocumentPath(identifier: ResourceIdentifier, filePath: string, contentType?: string):\n  Promise<ResourceLink> {\n    contentType = await this.getContentTypeFromUrl(identifier, contentType);\n    this.logger.debug(`The path for ${identifier.path} is ${filePath}`);\n    return { identifier, filePath, contentType, isMetadata: this.isMetadataPath(filePath) };\n  }\n\n  /**\n   * Determines the content type from the document identifier.\n   * @param identifier - The input identifier.\n   * @param contentType - The content-type provided with the request.\n   *\n   * @returns The content type of the document.\n   */\n  protected async getContentTypeFromUrl(identifier: ResourceIdentifier, contentType?: string): Promise<string> {\n    return contentType ?? APPLICATION_OCTET_STREAM;\n  }\n\n  /**\n   * Maps the given file path to a URL and determines its content type.\n   * @param filePath - The input file path.\n   * @param isContainer - If the path corresponds to a file.\n   *\n   * @returns A ResourceLink with all the necessary metadata.\n   */\n  public async mapFilePathToUrl(filePath: string, isContainer: boolean): Promise<ResourceLink> {\n    if (!filePath.startsWith(this.rootFilepath)) {\n      this.logger.error(`Trying to access file ${filePath} outside of ${this.rootFilepath}`);\n      throw new InternalServerError(`File ${filePath} is not part of the file storage at ${this.rootFilepath}`);\n    }\n    const relative = filePath.slice(this.rootFilepath.length);\n    let url: string;\n    let contentType: string | undefined;\n\n    if (isContainer) {\n      url = await this.getContainerUrl(relative);\n      this.logger.debug(`Container filepath ${filePath} maps to URL ${url}`);\n    } else {\n      url = await this.getDocumentUrl(relative);\n      this.logger.debug(`Document ${filePath} maps to URL ${url}`);\n      contentType = await this.getContentTypeFromPath(filePath);\n    }\n    const isMetadata = this.isMetadataPath(filePath);\n    if (isMetadata) {\n      url = url.slice(0, -'.meta'.length);\n    }\n    return { identifier: { path: url }, filePath, contentType, isMetadata };\n  }\n\n  /**\n   * Maps the given container path to a URL and determines its content type.\n   * @param relative - The relative container path.\n   *\n   * @returns A ResourceLink with all the necessary metadata.\n   */\n  protected async getContainerUrl(relative: string): Promise<string> {\n    return ensureTrailingSlash(this.baseRequestURI + encodeUriPathComponents(relative));\n  }\n\n  /**\n   * Maps the given document path to a URL and determines its content type.\n   * @param relative - The relative document path.\n   *\n   * @returns A ResourceLink with all the necessary metadata.\n   */\n  protected async getDocumentUrl(relative: string): Promise<string> {\n    return trimTrailingSlashes(this.baseRequestURI + encodeUriPathComponents(relative));\n  }\n\n  /**\n   * Determines the content type from the relative path.\n   * @param filePath - The file path of the document.\n   *\n   * @returns The content type of the document.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected async getContentTypeFromPath(filePath: string): Promise<string> {\n    return APPLICATION_OCTET_STREAM;\n  }\n\n  /**\n   * Get the absolute file path based on the rootFilepath.\n   * @param path - The relative file path.\n   *\n   * @returns Absolute path of the file.\n   */\n  protected getAbsolutePath(path: string): string {\n    return joinFilePath(this.rootFilepath, path);\n  }\n\n  /**\n   * Strips the baseRequestURI from the identifier.\n   * @param identifier - Incoming identifier.\n   *\n   * @throws {@link NotFoundHttpError}\n   * If the identifier does not match the baseRequestURI.\n   *\n   * @returns A string representing the relative path.\n   */\n  protected getRelativePath(identifier: ResourceIdentifier): string {\n    if (!identifier.path.startsWith(this.baseRequestURI)) {\n      this.logger.warn(`The URL ${identifier.path} is outside of the scope ${this.baseRequestURI}`);\n      throw new NotFoundHttpError();\n    }\n    return decodeUriPathComponents(identifier.path.slice(this.baseRequestURI.length));\n  }\n\n  /**\n   * Check if the given relative path is valid.\n   *\n   * @throws {@link BadRequestHttpError}\n   * If the relative path is invalid.\n   *\n   * @param path - A relative path, as generated by {@link getRelativePath}.\n   * @param identifier - A resource identifier.\n   */\n  protected validateRelativePath(path: string, identifier: ResourceIdentifier): void {\n    if (!path.startsWith('/')) {\n      this.logger.warn(`URL ${identifier.path} needs a / after the base`);\n      throw new BadRequestHttpError('URL needs a / after the base');\n    }\n\n    if (path.includes('/..')) {\n      this.logger.warn(`Disallowed /.. segment in URL ${identifier.path}.`);\n      throw new BadRequestHttpError('Disallowed /.. segment in URL');\n    }\n  }\n\n  /**\n   * Checks if the given path is a metadata path.\n   */\n  protected isMetadataPath(path: string): boolean {\n    return path.endsWith('.meta');\n  }\n}\n"]}