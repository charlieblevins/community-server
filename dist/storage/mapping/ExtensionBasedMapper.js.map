{"version":3,"file":"ExtensionBasedMapper.js","sourceRoot":"","sources":["../../../src/storage/mapping/ExtensionBasedMapper.ts"],"names":[],"mappings":"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","sourcesContent":["import { promises as fsPromises } from 'fs';\nimport * as mime from 'mime-types';\nimport type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport { DEFAULT_CUSTOM_TYPES } from '../../util/ContentTypes';\nimport { NotImplementedHttpError } from '../../util/errors/NotImplementedHttpError';\nimport { joinFilePath, getExtension } from '../../util/PathUtil';\nimport { BaseFileIdentifierMapper } from './BaseFileIdentifierMapper';\nimport type { FileIdentifierMapperFactory, ResourceLink } from './FileIdentifierMapper';\n\n/**\n * Supports the behaviour described in https://www.w3.org/DesignIssues/HTTPFilenameMapping.html\n * Determines content-type based on the file extension.\n * In case an identifier does not end on an extension matching its content-type,\n * the corresponding file will be appended with the correct extension, preceded by $.\n */\nexport class ExtensionBasedMapper extends BaseFileIdentifierMapper {\n  private readonly customTypes: Record<string, string>;\n  private readonly customExtensions: Record<string, string>;\n\n  public constructor(\n    base: string,\n    rootFilepath: string,\n    customTypes?: Record<string, string>,\n  ) {\n    super(base, rootFilepath);\n\n    // Workaround for https://github.com/LinkedSoftwareDependencies/Components.js/issues/20\n    if (!customTypes || Object.keys(customTypes).length === 0) {\n      this.customTypes = DEFAULT_CUSTOM_TYPES;\n    } else {\n      this.customTypes = customTypes;\n    }\n\n    this.customExtensions = {};\n    for (const [ extension, contentType ] of Object.entries(this.customTypes)) {\n      this.customExtensions[contentType] = extension;\n    }\n  }\n\n  protected async mapUrlToDocumentPath(identifier: ResourceIdentifier, filePath: string, contentType?: string):\n  Promise<ResourceLink> {\n    // Would conflict with how new extensions are stored\n    if (/\\$\\.\\w+$/u.test(filePath)) {\n      this.logger.warn(`Identifier ${identifier.path} contains a dollar sign before its extension`);\n      throw new NotImplementedHttpError('Identifiers cannot contain a dollar sign before their extension');\n    }\n\n    // Existing file\n    if (!contentType) {\n      // Find a matching file\n      const [ , folder, documentName ] = /^(.*\\/)(.*)$/u.exec(filePath)!;\n      let fileName: string | undefined;\n      try {\n        const files = await fsPromises.readdir(folder);\n        fileName = files.find((file): boolean =>\n          file.startsWith(documentName) && /^(?:\\$\\..+)?$/u.test(file.slice(documentName.length)));\n      } catch {\n        // Parent folder does not exist (or is not a folder)\n      }\n      if (fileName) {\n        filePath = joinFilePath(folder, fileName);\n      }\n      contentType = await this.getContentTypeFromPath(filePath);\n    // If the extension of the identifier matches a different content-type than the one that is given,\n    // we need to add a new extension to match the correct type.\n    } else if (contentType !== await this.getContentTypeFromPath(filePath)) {\n      const extension: string = mime.extension(contentType) || this.customExtensions[contentType];\n      if (!extension) {\n        this.logger.warn(`No extension found for ${contentType}`);\n        throw new NotImplementedHttpError(`Unsupported content type ${contentType}`);\n      }\n      filePath += `$.${extension}`;\n    }\n    return super.mapUrlToDocumentPath(identifier, filePath, contentType);\n  }\n\n  protected async getDocumentUrl(relative: string): Promise<string> {\n    return super.getDocumentUrl(this.stripExtension(relative));\n  }\n\n  protected async getContentTypeFromPath(filePath: string): Promise<string> {\n    const extension = getExtension(filePath).toLowerCase();\n    return mime.lookup(extension) ||\n      this.customTypes[extension] ||\n      await super.getContentTypeFromPath(filePath);\n  }\n\n  /**\n   * Helper function that removes the internal extension, one starting with $., from the given path.\n   * Nothing happens if no such extension is present.\n   */\n  protected stripExtension(path: string): string {\n    const extension = getExtension(path);\n    if (extension && path.endsWith(`$.${extension}`)) {\n      path = path.slice(0, -(extension.length + 2));\n    }\n    return path;\n  }\n}\n\nexport class ExtensionBasedMapperFactory implements FileIdentifierMapperFactory<ExtensionBasedMapper> {\n  public async create(base: string, rootFilePath: string): Promise<ExtensionBasedMapper> {\n    return new ExtensionBasedMapper(base, rootFilePath);\n  }\n}\n"]}