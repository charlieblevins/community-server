{"version":3,"file":"AgentGroupAccessChecker.js","sourceRoot":"","sources":["../../../src/authorization/access/AgentGroupAccessChecker.ts"],"names":[],"mappings":";;;AAIA,oDAAoD;AACpD,wDAAqD;AACrD,sDAAwD;AACxD,0DAAqD;AAErD,mDAAgD;AAEhD;;;;;;;;GAQG;AACH,MAAa,uBAAwB,SAAQ,6BAAa;IAKxD,YAAmB,SAAkC,EAAE,KAA8C,EACnG,UAAU,GAAG,IAAI;QACjB,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,UAAU,GAAG,UAAU,GAAG,IAAI,CAAC;IACtC,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,EAAE,GAAG,EAAE,IAAI,EAAE,UAAU,EAAqB;QAC9D,IAAI,OAAO,UAAU,CAAC,KAAK,KAAK,QAAQ,EAAE;YACxC,MAAM,EAAE,KAAK,EAAE,GAAG,UAAU,CAAC;YAC7B,MAAM,MAAM,GAAG,GAAG,CAAC,UAAU,CAAC,IAAI,EAAE,kBAAG,CAAC,KAAK,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;YAEhE,OAAO,MAAM,yBAAW,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,EAAC,KAAW,EAAoB,EAAE,CACzE,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;SACxC;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;;;;;OAMG;IACK,KAAK,CAAC,eAAe,CAAC,KAAa,EAAE,KAAW;QACtD,MAAM,aAAa,GAAuB,EAAE,IAAI,EAAE,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAE,CAAC,CAAC,CAAC,EAAE,CAAC;QAEpF,sCAAsC;QACtC,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAC9D,OAAO,KAAK,CAAC,UAAU,CAAC,KAAK,EAAE,oBAAK,CAAC,KAAK,CAAC,SAAS,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;IAC3E,CAAC;IAED;;;OAGG;IACK,KAAK,CAAC,gBAAgB,CAAC,GAAW;QACxC,IAAI,MAAM,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QACvC,IAAI,CAAC,MAAM,EAAE;YACX,MAAM,IAAI,GAAG,CAAC,KAAK,IAAmB,EAAE;gBACtC,MAAM,cAAc,GAAG,MAAM,wBAAY,CAAC,GAAG,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;gBAC/D,OAAO,4BAAe,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;YAC9C,CAAC,CAAC,EAAE,CAAC;YACL,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;YACjD,MAAM,GAAG,MAAM,IAAI,CAAC;SACrB;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AAvDD,0DAuDC","sourcesContent":["import type { Store, Term } from 'n3';\nimport type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport type { RepresentationConverter } from '../../storage/conversion/RepresentationConverter';\nimport type { ExpiringStorage } from '../../storage/keyvalue/ExpiringStorage';\nimport { fetchDataset } from '../../util/FetchUtil';\nimport { promiseSome } from '../../util/PromiseUtil';\nimport { readableToQuads } from '../../util/StreamUtil';\nimport { ACL, VCARD } from '../../util/Vocabularies';\nimport type { AccessCheckerArgs } from './AccessChecker';\nimport { AccessChecker } from './AccessChecker';\n\n/**\n * Checks if the given WebID belongs to a group that has access.\n * Implements the behaviour of groups from the WAC specification.\n *\n * Fetched results will be stored in an ExpiringStorage.\n *\n * Requires a storage that can store JS objects.\n * `expiration` parameter is how long entries in the cache should be stored in seconds, defaults to 3600.\n */\nexport class AgentGroupAccessChecker extends AccessChecker {\n  private readonly converter: RepresentationConverter;\n  private readonly cache: ExpiringStorage<string, Promise<Store>>;\n  private readonly expiration: number;\n\n  public constructor(converter: RepresentationConverter, cache: ExpiringStorage<string, Promise<Store>>,\n    expiration = 3600) {\n    super();\n    this.converter = converter;\n    this.cache = cache;\n    this.expiration = expiration * 1000;\n  }\n\n  public async handle({ acl, rule, credential }: AccessCheckerArgs): Promise<boolean> {\n    if (typeof credential.webId === 'string') {\n      const { webId } = credential;\n      const groups = acl.getObjects(rule, ACL.terms.agentGroup, null);\n\n      return await promiseSome(groups.map(async(group: Term): Promise<boolean> =>\n        this.isMemberOfGroup(webId, group)));\n    }\n    return false;\n  }\n\n  /**\n   * Checks if the given agent is member of a given vCard group.\n   * @param webId - WebID of the agent that needs access.\n   * @param group - URL of the vCard group that needs to be checked.\n   *\n   * @returns If the agent is member of the given vCard group.\n   */\n  private async isMemberOfGroup(webId: string, group: Term): Promise<boolean> {\n    const groupDocument: ResourceIdentifier = { path: /^[^#]*/u.exec(group.value)![0] };\n\n    // Fetch the required vCard group file\n    const quads = await this.fetchCachedQuads(groupDocument.path);\n    return quads.countQuads(group, VCARD.terms.hasMember, webId, null) !== 0;\n  }\n\n  /**\n   * Fetches quads from the given URL.\n   * Will cache the values for later re-use.\n   */\n  private async fetchCachedQuads(url: string): Promise<Store> {\n    let result = await this.cache.get(url);\n    if (!result) {\n      const prom = (async(): Promise<Store> => {\n        const representation = await fetchDataset(url, this.converter);\n        return readableToQuads(representation.data);\n      })();\n      await this.cache.set(url, prom, this.expiration);\n      result = await prom;\n    }\n    return result;\n  }\n}\n"]}