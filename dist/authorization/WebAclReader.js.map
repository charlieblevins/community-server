{"version":3,"file":"WebAclReader.js","sourceRoot":"","sources":["../../src/authorization/WebAclReader.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Quad, Term } from 'n3';\nimport { Store } from 'n3';\nimport { CredentialGroup } from '../authentication/Credentials';\nimport type { Credential, CredentialSet } from '../authentication/Credentials';\nimport type { AuxiliaryIdentifierStrategy } from '../http/auxiliary/AuxiliaryIdentifierStrategy';\nimport type { Representation } from '../http/representation/Representation';\nimport type { ResourceIdentifier } from '../http/representation/ResourceIdentifier';\nimport { getLoggerFor } from '../logging/LogUtil';\nimport type { ResourceStore } from '../storage/ResourceStore';\nimport { INTERNAL_QUADS } from '../util/ContentTypes';\nimport { createErrorMessage } from '../util/errors/ErrorUtil';\nimport { ForbiddenHttpError } from '../util/errors/ForbiddenHttpError';\nimport { InternalServerError } from '../util/errors/InternalServerError';\nimport { NotFoundHttpError } from '../util/errors/NotFoundHttpError';\nimport type { IdentifierStrategy } from '../util/identifiers/IdentifierStrategy';\nimport { readableToQuads } from '../util/StreamUtil';\nimport { ACL, RDF } from '../util/Vocabularies';\nimport type { AccessChecker } from './access/AccessChecker';\nimport type { PermissionReaderInput } from './PermissionReader';\nimport { PermissionReader } from './PermissionReader';\nimport type { AclPermission } from './permissions/AclPermission';\nimport { AclMode } from './permissions/AclPermission';\nimport { AccessMode } from './permissions/Permissions';\nimport type { PermissionSet } from './permissions/Permissions';\n\nconst modesMap: Record<string, keyof AclPermission> = {\n  [ACL.Read]: AccessMode.read,\n  [ACL.Write]: AccessMode.write,\n  [ACL.Append]: AccessMode.append,\n  [ACL.Control]: AclMode.control,\n} as const;\n\n/**\n * Handles permissions according to the WAC specification.\n * Specific access checks are done by the provided {@link AccessChecker}.\n */\nexport class WebAclReader extends PermissionReader {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly aclStrategy: AuxiliaryIdentifierStrategy;\n  private readonly aclStore: ResourceStore;\n  private readonly identifierStrategy: IdentifierStrategy;\n  private readonly accessChecker: AccessChecker;\n\n  public constructor(aclStrategy: AuxiliaryIdentifierStrategy, aclStore: ResourceStore,\n    identifierStrategy: IdentifierStrategy, accessChecker: AccessChecker) {\n    super();\n    this.aclStrategy = aclStrategy;\n    this.aclStore = aclStore;\n    this.identifierStrategy = identifierStrategy;\n    this.accessChecker = accessChecker;\n  }\n\n  /**\n   * Checks if an agent is allowed to execute the requested actions.\n   * Will throw an error if this is not the case.\n   * @param input - Relevant data needed to check if access can be granted.\n   */\n  public async handle({ identifier, credentials }: PermissionReaderInput):\n  Promise<PermissionSet> {\n    // Determine the required access modes\n    this.logger.debug(`Retrieving permissions of ${credentials.agent?.webId} for ${identifier.path}`);\n\n    const isAcl = this.aclStrategy.isAuxiliaryIdentifier(identifier);\n    const mainIdentifier = isAcl ? this.aclStrategy.getSubjectIdentifier(identifier) : identifier;\n\n    // Determine the full authorization for the agent granted by the applicable ACL\n    const acl = await this.getAclRecursive(mainIdentifier);\n    return this.createPermissions(credentials, acl, isAcl);\n  }\n\n  /**\n   * Creates an Authorization object based on the quads found in the ACL.\n   * @param credentials - Credentials to check permissions for.\n   * @param acl - Store containing all relevant authorization triples.\n   * @param isAcl - If the target resource is an acl document.\n   */\n  private async createPermissions(credentials: CredentialSet, acl: Store, isAcl: boolean):\n  Promise<PermissionSet> {\n    const publicPermissions = await this.determinePermissions(acl, credentials.public);\n    const agentPermissions = await this.determinePermissions(acl, credentials.agent);\n\n    return {\n      [CredentialGroup.agent]: this.updateAclPermissions(agentPermissions, isAcl),\n      [CredentialGroup.public]: this.updateAclPermissions(publicPermissions, isAcl),\n    };\n  }\n\n  /**\n   * Determines the available permissions for the given credentials.\n   * Will deny all permissions if credentials are not defined\n   * @param acl - Store containing all relevant authorization triples.\n   * @param credentials - Credentials to find the permissions for.\n   */\n  private async determinePermissions(acl: Store, credentials?: Credential): Promise<AclPermission> {\n    const aclPermissions: AclPermission = {};\n    if (!credentials) {\n      return aclPermissions;\n    }\n\n    // Apply all ACL rules\n    const aclRules = acl.getSubjects(RDF.type, ACL.Authorization, null);\n    for (const rule of aclRules) {\n      const hasAccess = await this.accessChecker.handleSafe({ acl, rule, credential: credentials });\n      if (hasAccess) {\n        // Set all allowed modes to true\n        const modes = acl.getObjects(rule, ACL.mode, null);\n        for (const { value: mode } of modes) {\n          if (mode in modesMap) {\n            aclPermissions[modesMap[mode]] = true;\n          }\n        }\n      }\n    }\n\n    if (aclPermissions.write) {\n      // Write permission implies Append permission\n      aclPermissions.append = true;\n    }\n\n    return aclPermissions;\n  }\n\n  /**\n   * Sets the correct values for non-acl permissions such as create and delete.\n   * Also adds the correct values to indicate that having control permission\n   * implies having read/write/etc. on the acl resource.\n   *\n   * The main reason for keeping the control value is so we can correctly set the WAC-Allow header later.\n   */\n  private updateAclPermissions(aclPermissions: AclPermission, isAcl: boolean): AclPermission {\n    if (isAcl) {\n      return {\n        read: aclPermissions.control,\n        append: aclPermissions.control,\n        write: aclPermissions.control,\n        create: aclPermissions.control,\n        delete: aclPermissions.control,\n        control: aclPermissions.control,\n      };\n    }\n    return {\n      ...aclPermissions,\n      create: aclPermissions.write,\n      delete: aclPermissions.write,\n    };\n  }\n\n  /**\n   * Returns the ACL triples that are relevant for the given identifier.\n   * These can either be from a corresponding ACL document or an ACL document higher up with defaults.\n   * Rethrows any non-NotFoundHttpErrors thrown by the ResourceStore.\n   * @param id - ResourceIdentifier of which we need the ACL triples.\n   * @param recurse - Only used internally for recursion.\n   *\n   * @returns A store containing the relevant ACL triples.\n   */\n  private async getAclRecursive(id: ResourceIdentifier, recurse?: boolean): Promise<Store> {\n    // Obtain the direct ACL document for the resource, if it exists\n    this.logger.debug(`Trying to read the direct ACL document of ${id.path}`);\n    try {\n      const acl = this.aclStrategy.getAuxiliaryIdentifier(id);\n      this.logger.debug(`Trying to read the ACL document ${acl.path}`);\n      const data = await this.aclStore.getRepresentation(acl, { type: { [INTERNAL_QUADS]: 1 }});\n      this.logger.info(`Reading ACL statements from ${acl.path}`);\n\n      return await this.filterData(data, recurse ? ACL.default : ACL.accessTo, id.path);\n    } catch (error: unknown) {\n      if (NotFoundHttpError.isInstance(error)) {\n        this.logger.debug(`No direct ACL document found for ${id.path}`);\n      } else {\n        const message = `Error reading ACL for ${id.path}: ${createErrorMessage(error)}`;\n        this.logger.error(message);\n        throw new InternalServerError(message, { cause: error });\n      }\n    }\n\n    // Obtain the applicable ACL of the parent container\n    this.logger.debug(`Traversing to the parent of ${id.path}`);\n    if (this.identifierStrategy.isRootContainer(id)) {\n      this.logger.error(`No ACL document found for root container ${id.path}`);\n      // Solid, §10.1: \"In the event that a server can’t apply an ACL to a resource, it MUST deny access.\"\n      // https://solid.github.io/specification/protocol#web-access-control\n      throw new ForbiddenHttpError('No ACL document found for root container');\n    }\n    const parent = this.identifierStrategy.getParentContainer(id);\n    return this.getAclRecursive(parent, true);\n  }\n\n  /**\n   * Finds all triples in the data stream of the given representation that use the given predicate and object.\n   * Then extracts the unique subjects from those triples,\n   * and returns a Store containing all triples from the data stream that have such a subject.\n   *\n   * This can be useful for finding the `acl:Authorization` objects corresponding to a specific URI\n   * and returning all relevant information on them.\n   * @param data - Representation with data stream of internal/quads.\n   * @param predicate - Predicate to match.\n   * @param object - Object to match.\n   *\n   * @returns A store containing the relevant triples.\n   */\n  private async filterData(data: Representation, predicate: string, object: string): Promise<Store> {\n    // Import all triples from the representation into a queryable store\n    const quads = await readableToQuads(data.data);\n\n    // Find subjects that occur with a given predicate/object, and collect all their triples\n    const subjectData = new Store();\n    const subjects = quads.getQuads(null, predicate, object, null).map((quad: Quad): Term => quad.subject);\n    subjects.forEach((subject): any => subjectData.addQuads(quads.getQuads(subject, null, null, null)));\n    return subjectData;\n  }\n}\n"]}