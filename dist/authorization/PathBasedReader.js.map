{"version":3,"file":"PathBasedReader.js","sourceRoot":"","sources":["../../src/authorization/PathBasedReader.ts"],"names":[],"mappings":";;;AAAA,oFAAiF;AACjF,+CAA4E;AAG5E,yDAAsD;AAGtD;;;;;;;GAOG;AACH,MAAa,eAAgB,SAAQ,mCAAgB;IAInD,YAAmB,OAAe,EAAE,KAAuC;QACzE,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,8BAAmB,CAAC,OAAO,CAAC,CAAC;QAC5C,MAAM,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC;aAClC,GAAG,CAAC,CAAC,CAAE,GAAG,EAAE,GAAG,CAAE,EAA8B,EAAE,CAAC,CAAE,IAAI,MAAM,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,GAAG,CAAE,CAAC,CAAC;QACpF,IAAI,CAAC,KAAK,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,CAAC;IAChC,CAAC;IAEM,KAAK,CAAC,SAAS,CAAC,KAA4B;QACjD,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QACtD,MAAM,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;IAChC,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,KAA4B;QAC9C,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QACtD,OAAO,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IAC9B,CAAC;IAED;;;OAGG;IACK,UAAU,CAAC,IAAY;QAC7B,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;YACjC,oCAAoC;YACpC,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,8BAAmB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC;YACtE,KAAK,MAAM,CAAE,KAAK,EAAE,MAAM,CAAE,IAAI,IAAI,CAAC,KAAK,EAAE;gBAC1C,IAAI,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;oBACxB,OAAO,MAAM,CAAC;iBACf;aACF;SACF;QACD,MAAM,IAAI,iDAAuB,CAAC,kCAAkC,CAAC,CAAC;IACxE,CAAC;CACF;AAtCD,0CAsCC","sourcesContent":["import { NotImplementedHttpError } from '../util/errors/NotImplementedHttpError';\nimport { ensureTrailingSlash, trimTrailingSlashes } from '../util/PathUtil';\n\nimport type { PermissionReaderInput } from './PermissionReader';\nimport { PermissionReader } from './PermissionReader';\nimport type { PermissionSet } from './permissions/Permissions';\n\n/**\n * Redirects requests to specific PermissionReaders based on their identifier.\n * The keys in the input map will be converted to regular expressions.\n * The regular expressions should all start with a slash\n * and will be evaluated relative to the base URL.\n *\n * Will error if no match is found.\n */\nexport class PathBasedReader extends PermissionReader {\n  private readonly baseUrl: string;\n  private readonly paths: Map<RegExp, PermissionReader>;\n\n  public constructor(baseUrl: string, paths: Record<string, PermissionReader>) {\n    super();\n    this.baseUrl = ensureTrailingSlash(baseUrl);\n    const entries = Object.entries(paths)\n      .map(([ key, val ]): [RegExp, PermissionReader] => [ new RegExp(key, 'u'), val ]);\n    this.paths = new Map(entries);\n  }\n\n  public async canHandle(input: PermissionReaderInput): Promise<void> {\n    const reader = this.findReader(input.identifier.path);\n    await reader.canHandle(input);\n  }\n\n  public async handle(input: PermissionReaderInput): Promise<PermissionSet> {\n    const reader = this.findReader(input.identifier.path);\n    return reader.handle(input);\n  }\n\n  /**\n   * Find the PermissionReader corresponding to the given path.\n   * Errors if there is no match.\n   */\n  private findReader(path: string): PermissionReader {\n    if (path.startsWith(this.baseUrl)) {\n      // We want to keep the leading slash\n      const relative = path.slice(trimTrailingSlashes(this.baseUrl).length);\n      for (const [ regex, reader ] of this.paths) {\n        if (regex.test(relative)) {\n          return reader;\n        }\n      }\n    }\n    throw new NotImplementedHttpError('No regex matches the given path.');\n  }\n}\n"]}