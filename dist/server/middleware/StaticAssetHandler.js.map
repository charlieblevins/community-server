{"version":3,"file":"StaticAssetHandler.js","sourceRoot":"","sources":["../../../src/server/middleware/StaticAssetHandler.ts"],"names":[],"mappings":"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","sourcesContent":["import { createReadStream } from 'fs';\nimport escapeStringRegexp from 'escape-string-regexp';\nimport * as mime from 'mime-types';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport { APPLICATION_OCTET_STREAM } from '../../util/ContentTypes';\nimport { NotFoundHttpError } from '../../util/errors/NotFoundHttpError';\nimport { NotImplementedHttpError } from '../../util/errors/NotImplementedHttpError';\nimport { joinFilePath, resolveAssetPath } from '../../util/PathUtil';\nimport { pipeSafely } from '../../util/StreamUtil';\nimport type { HttpHandlerInput } from '../HttpHandler';\nimport { HttpHandler } from '../HttpHandler';\nimport type { HttpRequest } from '../HttpRequest';\n\n/**\n * Handler that serves static resources on specific paths.\n * Relative file paths are assumed to be relative to cwd.\n * Relative file paths can be preceded by `@css:`, e.g. `@css:foo/bar`,\n * in case they need to be relative to the module root.\n */\nexport class StaticAssetHandler extends HttpHandler {\n  private readonly mappings: Record<string, string>;\n  private readonly pathMatcher: RegExp;\n  private readonly expires: number;\n  private readonly logger = getLoggerFor(this);\n\n  /**\n   * Creates a handler for the provided static resources.\n   * @param assets - A mapping from URL paths to paths,\n   *  where URL paths ending in a slash are interpreted as entire folders.\n   * @param options - Cache expiration time in seconds.\n   */\n  public constructor(assets: Record<string, string>, options: { expires?: number } = {}) {\n    super();\n    this.mappings = {};\n    for (const [ url, path ] of Object.entries(assets)) {\n      this.mappings[url] = resolveAssetPath(path);\n    }\n    this.pathMatcher = this.createPathMatcher(assets);\n    this.expires = Number.isInteger(options.expires) ? Math.max(0, options.expires!) : 0;\n  }\n\n  /**\n   * Creates a regular expression that matches the URL paths.\n   */\n  private createPathMatcher(assets: Record<string, string>): RegExp {\n    // Sort longest paths first to ensure the longest match has priority\n    const paths = Object.keys(assets)\n      .sort((pathA, pathB): number => pathB.length - pathA.length);\n\n    // Collect regular expressions for files and folders separately\n    const files = [ '.^' ];\n    const folders = [ '.^' ];\n    for (const path of paths) {\n      (path.endsWith('/') ? folders : files).push(escapeStringRegexp(path));\n    }\n\n    // Either match an exact document or a file within a folder (stripping the query string)\n    return new RegExp(`^(?:(${files.join('|')})|(${folders.join('|')})([^?]+))(?:\\\\?.*)?$`, 'u');\n  }\n\n  /**\n   * Obtains the file path corresponding to the asset URL\n   */\n  private getFilePath({ url }: HttpRequest): string {\n    // Verify if the URL matches any of the paths\n    const match = this.pathMatcher.exec(url ?? '');\n    if (!match || match[0].includes('/..')) {\n      throw new NotImplementedHttpError(`No static resource configured at ${url}`);\n    }\n\n    // The mapping is either a known document, or a file within a folder\n    const [ , document, folder, file ] = match;\n    return document ?\n      this.mappings[document] :\n      joinFilePath(this.mappings[folder], decodeURIComponent(file));\n  }\n\n  public async canHandle({ request }: HttpHandlerInput): Promise<void> {\n    if (request.method !== 'GET' && request.method !== 'HEAD') {\n      throw new NotImplementedHttpError('Only GET and HEAD requests are supported');\n    }\n    this.getFilePath(request);\n  }\n\n  public async handle({ request, response }: HttpHandlerInput): Promise<void> {\n    // Determine the asset to serve\n    const filePath = this.getFilePath(request);\n    this.logger.debug(`Serving ${request.url} via static asset ${filePath}`);\n\n    // Resolve when asset loading succeeds\n    const asset = createReadStream(filePath);\n    return new Promise((resolve, reject): void => {\n      // Write a 200 response when the asset becomes readable\n      asset.once('readable', (): void => {\n        const contentType = mime.lookup(filePath) || APPLICATION_OCTET_STREAM;\n        response.writeHead(200, {\n          'content-type': contentType,\n          ...this.getCacheHeaders(),\n        });\n\n        // With HEAD, only write the headers\n        if (request.method === 'HEAD') {\n          response.end();\n          asset.destroy();\n        // With GET, pipe the entire response\n        } else {\n          pipeSafely(asset, response);\n        }\n        resolve();\n      });\n\n      // Pass the error when something goes wrong\n      asset.once('error', (error): void => {\n        const { code } = error as any;\n        // When the file if not found or a folder, signal a 404\n        if (code === 'ENOENT' || code === 'EISDIR') {\n          this.logger.debug(`Static asset ${filePath} not found`);\n          reject(new NotFoundHttpError(`Cannot find ${request.url}`));\n        // In other cases, we might already have started writing, so just hang up\n        } else {\n          this.logger.warn(`Error reading asset ${filePath}: ${error.message}`, { error });\n          response.end();\n          asset.destroy();\n          resolve();\n        }\n      });\n    });\n  }\n\n  private getCacheHeaders(): Record<string, string> {\n    return this.expires <= 0 ?\n      {} :\n      {\n        'cache-control': `max-age=${this.expires}`,\n        expires: new Date(Date.now() + (this.expires * 1000)).toUTCString(),\n      };\n  }\n}\n"]}