{"version":3,"file":"ParsingHttpHandler.js","sourceRoot":"","sources":["../../src/server/ParsingHttpHandler.ts"],"names":[],"mappings":";;;AAMA,gDAAkD;AAClD,wDAAuD;AAEvD,+CAA4C;AA0B5C;;;;GAIG;AACH,MAAa,kBAAmB,SAAQ,yBAAW;IASjD,YAAmB,IAA4B;QAC7C,KAAK,EAAE,CAAC;QATO,WAAM,GAAG,sBAAY,CAAC,IAAI,CAAC,CAAC;QAU3C,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC;QACxC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;QACtC,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC;QAC1C,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,iBAAiB,CAAC;QAChD,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;IAChD,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,EAAE,OAAO,EAAE,QAAQ,EAAoB;QACzD,IAAI,MAAuC,CAAC;QAC5C,IAAI,WAAW,GAA8B,EAAE,IAAI,EAAE,EAAE,YAAY,EAAE,CAAC,EAAE,EAAC,CAAC;QAE1E,IAAI;YACF,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;YAC/D,CAAC,EAAE,WAAW,EAAE,GAAG,SAAS,CAAC,CAAC;YAC9B,MAAM,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,EAAE,SAAS,EAAE,OAAO,EAAE,QAAQ,EAAE,CAAC,CAAC;YAElF,IAAI,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,QAAQ,EAAE;gBACpB,MAAM,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC;aACnF;YAED,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,UAAU,SAAS,CAAC,MAAM,iBAAiB,SAAS,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,CAAC;SACzF;QAAC,OAAO,KAAc,EAAE;YACvB,uBAAW,CAAC,KAAK,CAAC,CAAC;YACnB,MAAM,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,WAAW,EAAE,CAAC,CAAC;SACrE;QAED,IAAI,MAAM,EAAE;YACV,MAAM,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC,CAAC;SAC5D;IACH,CAAC;CACF;AAzCD,gDAyCC","sourcesContent":["import type { RequestParser } from '../http/input/RequestParser';\nimport type { OperationMetadataCollector } from '../http/ldp/metadata/OperationMetadataCollector';\nimport type { ErrorHandler } from '../http/output/error/ErrorHandler';\nimport type { ResponseDescription } from '../http/output/response/ResponseDescription';\nimport type { ResponseWriter } from '../http/output/ResponseWriter';\nimport type { RepresentationPreferences } from '../http/representation/RepresentationPreferences';\nimport { getLoggerFor } from '../logging/LogUtil';\nimport { assertError } from '../util/errors/ErrorUtil';\nimport type { HttpHandlerInput } from './HttpHandler';\nimport { HttpHandler } from './HttpHandler';\nimport type { OperationHttpHandler } from './OperationHttpHandler';\n\nexport interface ParsingHttpHandlerArgs {\n  /**\n   * Parses the incoming requests.\n   */\n  requestParser: RequestParser;\n  /**\n   * Generates generic operation metadata that is required for a response.\n   */\n  metadataCollector: OperationMetadataCollector;\n  /**\n   * Converts errors to a serializable format.\n   */\n  errorHandler: ErrorHandler;\n  /**\n   * Writes out the response of the operation.\n   */\n  responseWriter: ResponseWriter;\n  /**\n   * Handler to send the operation to.\n   */\n  operationHandler: OperationHttpHandler;\n}\n\n/**\n * Parses requests and sends the resulting Operation to wrapped operationHandler.\n * Errors are caught and handled by the Errorhandler.\n * In case the operationHandler returns a result it will be sent to the ResponseWriter.\n */\nexport class ParsingHttpHandler extends HttpHandler {\n  private readonly logger = getLoggerFor(this);\n\n  private readonly requestParser: RequestParser;\n  private readonly errorHandler: ErrorHandler;\n  private readonly responseWriter: ResponseWriter;\n  private readonly metadataCollector: OperationMetadataCollector;\n  private readonly operationHandler: OperationHttpHandler;\n\n  public constructor(args: ParsingHttpHandlerArgs) {\n    super();\n    this.requestParser = args.requestParser;\n    this.errorHandler = args.errorHandler;\n    this.responseWriter = args.responseWriter;\n    this.metadataCollector = args.metadataCollector;\n    this.operationHandler = args.operationHandler;\n  }\n\n  public async handle({ request, response }: HttpHandlerInput): Promise<void> {\n    let result: ResponseDescription | undefined;\n    let preferences: RepresentationPreferences = { type: { 'text/plain': 1 }};\n\n    try {\n      const operation = await this.requestParser.handleSafe(request);\n      ({ preferences } = operation);\n      result = await this.operationHandler.handleSafe({ operation, request, response });\n\n      if (result?.metadata) {\n        await this.metadataCollector.handleSafe({ operation, metadata: result.metadata });\n      }\n\n      this.logger.verbose(`Parsed ${operation.method} operation on ${operation.target.path}`);\n    } catch (error: unknown) {\n      assertError(error);\n      result = await this.errorHandler.handleSafe({ error, preferences });\n    }\n\n    if (result) {\n      await this.responseWriter.handleSafe({ response, result });\n    }\n  }\n}\n"]}