{"version":3,"file":"RepresentationMetadata.js","sourceRoot":"","sources":["../../../src/http/representation/RepresentationMetadata.ts"],"names":[],"mappings":";;;AAAA,2BAAwC;AAExC,mDAAqD;AACrD,+EAA4E;AAC5E,kDAA2F;AAC3F,0DAA0E;AAE1E,6DAA4D;AAO5D;;GAEG;AACH,SAAgB,wBAAwB,CAAC,MAAW;IAClD,OAAO,OAAO,CAAA,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,WAAW,CAAA,KAAK,UAAU,CAAC;AACnD,CAAC;AAFD,4DAEC;AAED;;;GAGG;AACH,MAAa,sBAAsB;IA6CjC,YACE,KAA6E,EAC7E,SAAmC;QA9ClB,WAAM,GAAG,sBAAY,CAAC,IAAI,CAAC,CAAC;QAgD7C,IAAI,CAAC,KAAK,GAAG,IAAI,UAAK,EAAE,CAAC;QACzB,IAAI,yCAAoB,CAAC,KAAK,CAAC,EAAE;YAC/B,IAAI,CAAC,EAAE,GAAG,gBAAW,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;SAC7C;aAAM,IAAI,iBAAM,CAAC,KAAK,CAAC,EAAE;YACxB,IAAI,CAAC,EAAE,GAAG,KAAK,CAAC;SACjB;aAAM,IAAI,wBAAwB,CAAC,KAAK,CAAC,EAAE;YAC1C,IAAI,CAAC,EAAE,GAAG,KAAK,CAAC,UAAU,CAAC;YAC3B,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;SAC9B;aAAM;YACL,SAAS,GAAG,KAAK,CAAC;YAClB,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,eAAe,EAAE,CAAC;SACxC;QAED,IAAI,SAAS,EAAE;YACb,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;gBACjC,SAAS,GAAG,EAAE,CAAC,2BAAY,CAAC,EAAE,SAAS,EAAE,CAAC;aAC3C;YACD,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;SAC9B;IACH,CAAC;IAEO,YAAY,CAAC,SAAwC;QAC3D,KAAK,MAAM,SAAS,IAAI,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE;YAC9C,MAAM,cAAc,GAAG,4BAAiB,CAAC,SAAS,CAAC,CAAC;YACpD,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;YAE/B,IAAI,OAAO,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC;YACnC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;gBAC3B,OAAO,GAAG,CAAE,OAAO,CAAE,CAAC;aACvB;YACD,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;gBAC5B,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,EAAE,cAAc,EAAE,uBAAY,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC;aACzE;SACF;IACH,CAAC;IAED;;OAEG;IACI,KAAK,CACV,UAAiD,IAAI,EACrD,YAAuC,IAAI,EAC3C,SAA0D,IAAI,EAC9D,QAA8B,IAAI;QAElC,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,OAAO,EAAE,SAAS,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;IAChE,CAAC;IAED;;;OAGG;IACH,IAAW,UAAU;QACnB,OAAO,IAAI,CAAC,EAAE,CAAC;IACjB,CAAC;IAED,IAAW,UAAU,CAAC,EAAyB;QAC7C,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE;YACvB,wFAAwF;YACxF,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC,GAAG,CAAC,CAAC,IAAI,EAAQ,EAAE;gBAC5C,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE;oBAChC,OAAO,gBAAW,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;iBACtE;gBACD,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE;oBAC/B,OAAO,gBAAW,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,SAAS,EAAE,EAAE,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;iBACvE;gBACD,OAAO,IAAI,CAAC;YACd,CAAC,CAAC,CAAC;YACH,IAAI,CAAC,KAAK,GAAG,IAAI,UAAK,CAAC,KAAK,CAAC,CAAC;YAC9B,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC;SACd;IACH,CAAC;IAED;;;;OAIG;IACI,WAAW,CAAC,QAAgC;QACjD,IAAI,CAAC,UAAU,GAAG,QAAQ,CAAC,UAAU,CAAC;QACtC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC,CAAC;QAChC,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;;OAKG;IACI,OAAO,CACZ,OAAuC,EACvC,SAA6B,EAC7B,MAAgD,EAChD,KAAqB;QAErB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,sBAAW,CAAC,OAAO,CAAC,EACrC,4BAAiB,CAAC,SAAS,CAAC,EAC5B,uBAAY,CAAC,MAAM,EAAE,IAAI,CAAC,EAC1B,KAAK,CAAC,CAAC,CAAC,sBAAW,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;QAC1C,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;OAEG;IACI,QAAQ,CAAC,KAAa;QAC3B,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAC3B,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;;OAKG;IACI,UAAU,CACf,OAAuC,EACvC,SAA6B,EAC7B,MAAgD,EAChD,KAAqB;QAErB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,sBAAW,CAAC,OAAO,CAAC,EAC3C,4BAAiB,CAAC,SAAS,CAAC,EAC5B,uBAAY,CAAC,MAAM,EAAE,IAAI,CAAC,EAC1B,KAAK,CAAC,CAAC,CAAC,sBAAW,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;QAC1C,OAAO,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;IACjC,CAAC;IAED;;OAEG;IACI,WAAW,CAAC,KAAa;QAC9B,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QAC9B,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;;OAKG;IACI,GAAG,CAAC,SAA6B,EAAE,MAAqB,EAAE,KAAqB;QACpF,OAAO,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,MAAM,EAAE,CAAC,IAAI,EAAE,GAAG,EAAO,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC,CAAC;IACvG,CAAC;IAED;;;;;OAKG;IACI,MAAM,CAAC,SAA6B,EAAE,MAAqB,EAAE,KAAqB;QACvF,OAAO,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,MAAM,EAAE,CAAC,IAAI,EAAE,GAAG,EAAO,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC,CAAC;IAC1G,CAAC;IAED;;;OAGG;IACK,QAAQ,CAAC,SAA6B,EAAE,MAAqB,EACnE,KAA0D;QAC1D,MAAM,aAAa,GAAG,4BAAiB,CAAC,SAAS,CAAC,CAAC;QACnD,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAE,MAAM,CAAE,CAAC;QAC5D,KAAK,MAAM,GAAG,IAAI,OAAO,EAAE;YACzB,KAAK,CAAC,aAAa,EAAE,uBAAY,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC;SAC/C;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;OAIG;IACI,SAAS,CAAC,SAA6B,EAAE,KAAqB;QACnE,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,EAAE,4BAAiB,CAAC,SAAS,CAAC,EAAE,IAAI,EAAE,KAAK,aAAL,KAAK,cAAL,KAAK,GAAI,IAAI,CAAC,CAAC,CAAC;QAClG,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;;;OAMG;IACI,MAAM,CAAC,SAA6B,EAAE,KAAqB;QAChE,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,EAAE,4BAAiB,CAAC,SAAS,CAAC,EAAE,IAAI,EAAE,KAAK,aAAL,KAAK,cAAL,KAAK,GAAI,IAAI,CAAC;aACnF,GAAG,CAAC,CAAC,IAAI,EAAQ,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACtC,CAAC;IAED;;;;;;;;OAQG;IACI,GAAG,CAAC,SAA6B,EAAE,KAAqB;QAC7D,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;QAC5C,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;YACtB,OAAO;SACR;QACD,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;YACpB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,wBAAwB,OAAO,SAAS,KAAK,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC,CAAC;YACzG,MAAM,IAAI,yCAAmB,CAC3B,wBAAwB,OAAO,SAAS,KAAK,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,KAAK,EAAE,CACtF,CAAC;SACH;QACD,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC;IAClB,CAAC;IAED;;;;;;OAMG;IACI,GAAG,CAAC,SAA6B,EAAE,MAAsB,EAAE,KAAqB;QACrF,IAAI,CAAC,SAAS,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;QACjC,IAAI,MAAM,EAAE;YACV,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;SACpC;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAED,wCAAwC;IAExC;;OAEG;IACH,IAAW,WAAW;;QACpB,OAAO,MAAA,IAAI,CAAC,GAAG,CAAC,gCAAiB,CAAC,0CAAE,KAAK,CAAC;IAC5C,CAAC;IAED,IAAW,WAAW,CAAC,KAAK;QAC1B,IAAI,CAAC,GAAG,CAAC,gCAAiB,EAAE,KAAK,CAAC,CAAC;IACrC,CAAC;CACF;AArSD,wDAqSC","sourcesContent":["import { DataFactory, Store } from 'n3';\nimport type { BlankNode, DefaultGraph, Literal, NamedNode, Quad, Term } from 'rdf-js';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport { InternalServerError } from '../../util/errors/InternalServerError';\nimport { toNamedTerm, toObjectTerm, toCachedNamedNode, isTerm } from '../../util/TermUtil';\nimport { CONTENT_TYPE, CONTENT_TYPE_TERM } from '../../util/Vocabularies';\nimport type { ResourceIdentifier } from './ResourceIdentifier';\nimport { isResourceIdentifier } from './ResourceIdentifier';\n\nexport type MetadataIdentifier = ResourceIdentifier | NamedNode | BlankNode;\nexport type MetadataValue = NamedNode | Literal | string | (NamedNode | Literal | string)[];\nexport type MetadataRecord = Record<string, MetadataValue>;\nexport type MetadataGraph = NamedNode | BlankNode | DefaultGraph | string;\n\n/**\n * Determines whether the object is a `RepresentationMetadata`.\n */\nexport function isRepresentationMetadata(object: any): object is RepresentationMetadata {\n  return typeof object?.setMetadata === 'function';\n}\n\n/**\n * Stores the metadata triples and provides methods for easy access.\n * Most functions return the metadata object to allow for chaining.\n */\nexport class RepresentationMetadata {\n  protected readonly logger = getLoggerFor(this);\n\n  private store: Store;\n  private id: NamedNode | BlankNode;\n\n  /**\n   * @param identifier - Identifier of the resource relevant to this metadata.\n   *                     A blank node will be generated if none is provided.\n   *                     Strings will be converted to named nodes. @ignored\n   * @param overrides - Key/value map of extra values that need to be added to the metadata. @ignored\n   *\n   * `@ignored` tag is necessary for Components-Generator.js\n   */\n  public constructor(identifier?: MetadataIdentifier, overrides?: MetadataRecord);\n\n  /**\n   * @param metadata - Starts as a copy of the input metadata.\n   * @param overrides - Key/value map of extra values that need to be added to the metadata.\n   *                    Will override values that were set by the input metadata.\n   */\n  public constructor(metadata?: RepresentationMetadata, overrides?: MetadataRecord);\n\n  /**\n   * @param identifier - Identifier of the resource relevant to this metadata.\n   * @param contentType - Override for the content type of the representation.\n   */\n  public constructor(identifier?: MetadataIdentifier, contentType?: string);\n\n  /**\n   * @param metadata - Starts as a copy of the input metadata.\n   * @param contentType - Override for the content type of the representation.\n   */\n  public constructor(metadata?: RepresentationMetadata, contentType?: string);\n\n  /**\n   * @param contentType - The content type of the representation.\n   */\n  public constructor(contentType?: string);\n\n  /**\n   * @param metadata - Metadata values (defaulting to content type if a string)\n   */\n  public constructor(metadata?: RepresentationMetadata | MetadataRecord | string);\n\n  public constructor(\n    input?: MetadataIdentifier | RepresentationMetadata | MetadataRecord | string,\n    overrides?: MetadataRecord | string,\n  ) {\n    this.store = new Store();\n    if (isResourceIdentifier(input)) {\n      this.id = DataFactory.namedNode(input.path);\n    } else if (isTerm(input)) {\n      this.id = input;\n    } else if (isRepresentationMetadata(input)) {\n      this.id = input.identifier;\n      this.addQuads(input.quads());\n    } else {\n      overrides = input;\n      this.id = this.store.createBlankNode();\n    }\n\n    if (overrides) {\n      if (typeof overrides === 'string') {\n        overrides = { [CONTENT_TYPE]: overrides };\n      }\n      this.setOverrides(overrides);\n    }\n  }\n\n  private setOverrides(overrides: Record<string, MetadataValue>): void {\n    for (const predicate of Object.keys(overrides)) {\n      const namedPredicate = toCachedNamedNode(predicate);\n      this.removeAll(namedPredicate);\n\n      let objects = overrides[predicate];\n      if (!Array.isArray(objects)) {\n        objects = [ objects ];\n      }\n      for (const object of objects) {\n        this.store.addQuad(this.id, namedPredicate, toObjectTerm(object, true));\n      }\n    }\n  }\n\n  /**\n   * @returns All matching metadata quads.\n   */\n  public quads(\n    subject: NamedNode | BlankNode | string | null = null,\n    predicate: NamedNode | string | null = null,\n    object: NamedNode | BlankNode | Literal | string | null = null,\n    graph: MetadataGraph | null = null,\n  ): Quad[] {\n    return this.store.getQuads(subject, predicate, object, graph);\n  }\n\n  /**\n   * Identifier of the resource this metadata is relevant to.\n   * Will update all relevant triples if this value gets changed.\n   */\n  public get identifier(): NamedNode | BlankNode {\n    return this.id;\n  }\n\n  public set identifier(id: NamedNode | BlankNode) {\n    if (!id.equals(this.id)) {\n      // Convert all instances of the old identifier to the new identifier in the stored quads\n      const quads = this.quads().map((quad): Quad => {\n        if (quad.subject.equals(this.id)) {\n          return DataFactory.quad(id, quad.predicate, quad.object, quad.graph);\n        }\n        if (quad.object.equals(this.id)) {\n          return DataFactory.quad(quad.subject, quad.predicate, id, quad.graph);\n        }\n        return quad;\n      });\n      this.store = new Store(quads);\n      this.id = id;\n    }\n  }\n\n  /**\n   * Helper function to import all entries from the given metadata.\n   * If the new metadata has a different identifier the internal one will be updated.\n   * @param metadata - Metadata to import.\n   */\n  public setMetadata(metadata: RepresentationMetadata): this {\n    this.identifier = metadata.identifier;\n    this.addQuads(metadata.quads());\n    return this;\n  }\n\n  /**\n   * @param subject - Subject of quad to add.\n   * @param predicate - Predicate of quad to add.\n   * @param object - Object of quad to add.\n   * @param graph - Optional graph of quad to add.\n   */\n  public addQuad(\n    subject: NamedNode | BlankNode | string,\n    predicate: NamedNode | string,\n    object: NamedNode | BlankNode | Literal | string,\n    graph?: MetadataGraph,\n  ): this {\n    this.store.addQuad(toNamedTerm(subject),\n      toCachedNamedNode(predicate),\n      toObjectTerm(object, true),\n      graph ? toNamedTerm(graph) : undefined);\n    return this;\n  }\n\n  /**\n   * @param quads - Quads to add to the metadata.\n   */\n  public addQuads(quads: Quad[]): this {\n    this.store.addQuads(quads);\n    return this;\n  }\n\n  /**\n   * @param subject - Subject of quad to remove.\n   * @param predicate - Predicate of quad to remove.\n   * @param object - Object of quad to remove.\n   * @param graph - Optional graph of quad to remove.\n   */\n  public removeQuad(\n    subject: NamedNode | BlankNode | string,\n    predicate: NamedNode | string,\n    object: NamedNode | BlankNode | Literal | string,\n    graph?: MetadataGraph,\n  ): this {\n    const quads = this.quads(toNamedTerm(subject),\n      toCachedNamedNode(predicate),\n      toObjectTerm(object, true),\n      graph ? toNamedTerm(graph) : undefined);\n    return this.removeQuads(quads);\n  }\n\n  /**\n   * @param quads - Quads to remove from the metadata.\n   */\n  public removeQuads(quads: Quad[]): this {\n    this.store.removeQuads(quads);\n    return this;\n  }\n\n  /**\n   * Adds a value linked to the identifier. Strings get converted to literals.\n   * @param predicate - Predicate linking identifier to value.\n   * @param object - Value(s) to add.\n   * @param graph - Optional graph of where to add the values to.\n   */\n  public add(predicate: NamedNode | string, object: MetadataValue, graph?: MetadataGraph): this {\n    return this.forQuads(predicate, object, (pred, obj): any => this.addQuad(this.id, pred, obj, graph));\n  }\n\n  /**\n   * Removes the given value from the metadata. Strings get converted to literals.\n   * @param predicate - Predicate linking identifier to value.\n   * @param object - Value(s) to remove.\n   * @param graph - Optional graph of where to remove the values from.\n   */\n  public remove(predicate: NamedNode | string, object: MetadataValue, graph?: MetadataGraph): this {\n    return this.forQuads(predicate, object, (pred, obj): any => this.removeQuad(this.id, pred, obj, graph));\n  }\n\n  /**\n   * Helper function to simplify add/remove\n   * Runs the given function on all predicate/object pairs, but only converts the predicate to a named node once.\n   */\n  private forQuads(predicate: NamedNode | string, object: MetadataValue,\n    forFn: (pred: NamedNode, obj: NamedNode | Literal) => void): this {\n    const predicateNode = toCachedNamedNode(predicate);\n    const objects = Array.isArray(object) ? object : [ object ];\n    for (const obj of objects) {\n      forFn(predicateNode, toObjectTerm(obj, true));\n    }\n    return this;\n  }\n\n  /**\n   * Removes all values linked through the given predicate.\n   * @param predicate - Predicate to remove.\n   * @param graph - Optional graph where to remove from.\n   */\n  public removeAll(predicate: NamedNode | string, graph?: MetadataGraph): this {\n    this.removeQuads(this.store.getQuads(this.id, toCachedNamedNode(predicate), null, graph ?? null));\n    return this;\n  }\n\n  /**\n   * Finds all object values matching the given predicate and/or graph.\n   * @param predicate - Optional predicate to get the values for.\n   * @param graph - Optional graph where to get from.\n   *\n   * @returns An array with all matches.\n   */\n  public getAll(predicate: NamedNode | string, graph?: MetadataGraph): Term[] {\n    return this.store.getQuads(this.id, toCachedNamedNode(predicate), null, graph ?? null)\n      .map((quad): Term => quad.object);\n  }\n\n  /**\n   * @param predicate - Predicate to get the value for.\n   * @param graph - Optional graph where the triple should be found.\n   *\n   * @throws Error\n   * If there are multiple matching values.\n   *\n   * @returns The corresponding value. Undefined if there is no match\n   */\n  public get(predicate: NamedNode | string, graph?: MetadataGraph): Term | undefined {\n    const terms = this.getAll(predicate, graph);\n    if (terms.length === 0) {\n      return;\n    }\n    if (terms.length > 1) {\n      this.logger.error(`Multiple results for ${typeof predicate === 'string' ? predicate : predicate.value}`);\n      throw new InternalServerError(\n        `Multiple results for ${typeof predicate === 'string' ? predicate : predicate.value}`,\n      );\n    }\n    return terms[0];\n  }\n\n  /**\n   * Sets the value for the given predicate, removing all other instances.\n   * In case the object is undefined this is identical to `removeAll(predicate)`.\n   * @param predicate - Predicate linking to the value.\n   * @param object - Value(s) to set.\n   * @param graph - Optional graph where the triple should be stored.\n   */\n  public set(predicate: NamedNode | string, object?: MetadataValue, graph?: MetadataGraph): this {\n    this.removeAll(predicate, graph);\n    if (object) {\n      this.add(predicate, object, graph);\n    }\n    return this;\n  }\n\n  // Syntactic sugar for common predicates\n\n  /**\n   * Shorthand for the CONTENT_TYPE predicate.\n   */\n  public get contentType(): string | undefined {\n    return this.get(CONTENT_TYPE_TERM)?.value;\n  }\n\n  public set contentType(input) {\n    this.set(CONTENT_TYPE_TERM, input);\n  }\n}\n"]}