{"version":3,"file":"RoutingAuxiliaryStrategy.js","sourceRoot":"","sources":["../../../src/http/auxiliary/RoutingAuxiliaryStrategy.ts"],"names":[],"mappings":";;;AAIA,6FAA0F;AAE1F;;;;;;GAMG;AACH,MAAa,wBAAyB,SAAQ,uEAAkC;IAG9E,YAAmB,OAA4B;QAC7C,KAAK,CAAC,OAAO,CAAC,CAAC;IACjB,CAAC;IAEM,oBAAoB,CAAC,UAA8B;QACxD,MAAM,MAAM,GAAG,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;QAClD,OAAO,MAAM,CAAC,oBAAoB,CAAC,UAAU,CAAC,CAAC;IACjD,CAAC;IAEM,gBAAgB,CAAC,UAA8B;QACpD,MAAM,MAAM,GAAG,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;QAClD,OAAO,MAAM,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;IAC7C,CAAC;IAEM,KAAK,CAAC,WAAW,CAAC,QAAgC;QACvD,MAAM,UAAU,GAAG,EAAE,IAAI,EAAE,QAAQ,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;QACvD,4FAA4F;QAC5F,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,EAAW,EAAE,CAAC,MAAM,CAAC,qBAAqB,CAAC,UAAU,CAAC,CAAC,CAAC;QAC/F,IAAI,KAAK,EAAE;YACT,MAAM,KAAK,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;SACnC;aAAM;YACL,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,OAAO,EAAE;gBACjC,MAAM,MAAM,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;aACpC;SACF;IACH,CAAC;IAEM,KAAK,CAAC,QAAQ,CAAC,cAA8B;QAClD,MAAM,UAAU,GAAG,EAAE,IAAI,EAAE,cAAc,CAAC,QAAQ,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;QACtE,MAAM,MAAM,GAAG,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;QAClD,OAAO,MAAM,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;IACzC,CAAC;IAED,kCAAkC;IACxB,iBAAiB,CAAC,UAA8B;QACxD,OAAO,KAAK,CAAC,iBAAiB,CAAC,UAAU,CAAsB,CAAC;IAClE,CAAC;CACF;AAxCD,4DAwCC","sourcesContent":["import type { Representation } from '../representation/Representation';\nimport type { RepresentationMetadata } from '../representation/RepresentationMetadata';\nimport type { ResourceIdentifier } from '../representation/ResourceIdentifier';\nimport type { AuxiliaryStrategy } from './AuxiliaryStrategy';\nimport { RoutingAuxiliaryIdentifierStrategy } from './RoutingAuxiliaryIdentifierStrategy';\n\n/**\n * An {@link AuxiliaryStrategy} that combines multiple AuxiliaryStrategies into one.\n * Uses `isAuxiliaryIdentifier` to know which strategy to call for which call.\n *\n * `addMetadata` will either call all strategies if the input is the subject identifier,\n * or only the matching strategy if the input is an auxiliary identifier.\n */\nexport class RoutingAuxiliaryStrategy extends RoutingAuxiliaryIdentifierStrategy implements AuxiliaryStrategy {\n  protected readonly sources!: AuxiliaryStrategy[];\n\n  public constructor(sources: AuxiliaryStrategy[]) {\n    super(sources);\n  }\n\n  public usesOwnAuthorization(identifier: ResourceIdentifier): boolean {\n    const source = this.getMatchingSource(identifier);\n    return source.usesOwnAuthorization(identifier);\n  }\n\n  public isRequiredInRoot(identifier: ResourceIdentifier): boolean {\n    const source = this.getMatchingSource(identifier);\n    return source.isRequiredInRoot(identifier);\n  }\n\n  public async addMetadata(metadata: RepresentationMetadata): Promise<void> {\n    const identifier = { path: metadata.identifier.value };\n    // Make sure unrelated auxiliary strategies don't add metadata to another auxiliary resource\n    const match = this.sources.find((source): boolean => source.isAuxiliaryIdentifier(identifier));\n    if (match) {\n      await match.addMetadata(metadata);\n    } else {\n      for (const source of this.sources) {\n        await source.addMetadata(metadata);\n      }\n    }\n  }\n\n  public async validate(representation: Representation): Promise<void> {\n    const identifier = { path: representation.metadata.identifier.value };\n    const source = this.getMatchingSource(identifier);\n    return source.validate(representation);\n  }\n\n  // Updated with new source typings\n  protected getMatchingSource(identifier: ResourceIdentifier): AuxiliaryStrategy {\n    return super.getMatchingSource(identifier) as AuxiliaryStrategy;\n  }\n}\n"]}