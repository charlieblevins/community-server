{"version":3,"file":"ConvertingErrorHandler.js","sourceRoot":"","sources":["../../../../src/http/output/error/ConvertingErrorHandler.ts"],"names":[],"mappings":";;;AAIA,6DAA4D;AAC5D,sEAAmE;AACnE,qDAAmD;AACnD,6DAAuD;AACvD,kFAA+E;AAE/E,wFAAqF;AAGrF,iDAA8C;AAQ9C;;;GAGG;AACH,MAAa,sBAAuB,SAAQ,2BAAY;IAItD,YAAmB,SAAkC,EAAE,cAAc,GAAG,KAAK;QAC3E,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;IACvC,CAAC;IAEM,KAAK,CAAC,SAAS,CAAC,KAAuB;QAC5C,MAAM,EAAE,cAAc,EAAE,GAAG,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;QAExD,MAAM,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;IACjD,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,KAAuB;QACzC,MAAM,EAAE,UAAU,EAAE,cAAc,EAAE,GAAG,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;QAEpE,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC;QAE9D,OAAO,IAAI,CAAC,cAAc,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;IACpD,CAAC;IAEM,KAAK,CAAC,UAAU,CAAC,KAAuB;QAC7C,MAAM,EAAE,UAAU,EAAE,cAAc,EAAE,GAAG,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;QAEpE,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC;QAElE,OAAO,IAAI,CAAC,cAAc,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;IACpD,CAAC;IAED;;OAEG;IACK,gBAAgB,CAAC,EAAE,KAAK,EAAE,WAAW,EAAoB;QAC/D,MAAM,UAAU,GAAG,6BAAa,CAAC,KAAK,CAAC,CAAC;QACxC,MAAM,cAAc,GAAG,IAAI,CAAC,gBAAgB,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;QAChE,MAAM,UAAU,GAAG,EAAE,IAAI,EAAE,cAAc,CAAC,QAAQ,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;QACtE,OAAO,EAAE,UAAU,EAAE,cAAc,EAAE,EAAE,UAAU,EAAE,cAAc,EAAE,WAAW,EAAE,EAAC,CAAC;IACpF,CAAC;IAED;;OAEG;IACK,cAAc,CAAC,UAAkB,EAAE,SAAyB;QAClE,OAAO;YACL,UAAU;YACV,QAAQ,EAAE,SAAS,CAAC,QAAQ;YAC5B,IAAI,EAAE,SAAS,CAAC,IAAI;SACrB,CAAC;IACJ,CAAC;IAED;;;;OAIG;IACK,gBAAgB,CAAC,KAAY,EAAE,UAAkB;QACvD,MAAM,QAAQ,GAAG,IAAI,+CAAsB,CAAC,6BAAc,CAAC,CAAC;QAC5D,QAAQ,CAAC,GAAG,CAAC,mBAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE,oBAAS,CAAC,UAAU,EAAE,kBAAG,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC;QAEpF,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE;YACxB,OAAO,KAAK,CAAC,KAAK,CAAC;SACpB;QAED,OAAO,IAAI,yCAAmB,CAAC,CAAE,KAAK,CAAE,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;IAC7D,CAAC;CACF;AApED,wDAoEC","sourcesContent":["import type {\n  RepresentationConverter,\n  RepresentationConverterArgs,\n} from '../../../storage/conversion/RepresentationConverter';\nimport { INTERNAL_ERROR } from '../../../util/ContentTypes';\nimport { getStatusCode } from '../../../util/errors/HttpErrorUtil';\nimport { toLiteral } from '../../../util/TermUtil';\nimport { HTTP, XSD } from '../../../util/Vocabularies';\nimport { BasicRepresentation } from '../../representation/BasicRepresentation';\nimport type { Representation } from '../../representation/Representation';\nimport { RepresentationMetadata } from '../../representation/RepresentationMetadata';\nimport type { ResponseDescription } from '../response/ResponseDescription';\nimport type { ErrorHandlerArgs } from './ErrorHandler';\nimport { ErrorHandler } from './ErrorHandler';\n\n// Used by internal helper function\ntype PreparedArguments = {\n  statusCode: number;\n  conversionArgs: RepresentationConverterArgs;\n};\n\n/**\n * Converts an error into a Representation of content type internal/error.\n * Then feeds that representation into its converter to create a representation based on the given preferences.\n */\nexport class ConvertingErrorHandler extends ErrorHandler {\n  private readonly converter: RepresentationConverter;\n  private readonly showStackTrace: boolean;\n\n  public constructor(converter: RepresentationConverter, showStackTrace = false) {\n    super();\n    this.converter = converter;\n    this.showStackTrace = showStackTrace;\n  }\n\n  public async canHandle(input: ErrorHandlerArgs): Promise<void> {\n    const { conversionArgs } = this.prepareArguments(input);\n\n    await this.converter.canHandle(conversionArgs);\n  }\n\n  public async handle(input: ErrorHandlerArgs): Promise<ResponseDescription> {\n    const { statusCode, conversionArgs } = this.prepareArguments(input);\n\n    const converted = await this.converter.handle(conversionArgs);\n\n    return this.createResponse(statusCode, converted);\n  }\n\n  public async handleSafe(input: ErrorHandlerArgs): Promise<ResponseDescription> {\n    const { statusCode, conversionArgs } = this.prepareArguments(input);\n\n    const converted = await this.converter.handleSafe(conversionArgs);\n\n    return this.createResponse(statusCode, converted);\n  }\n\n  /**\n   * Prepares the arguments used by all functions.\n   */\n  private prepareArguments({ error, preferences }: ErrorHandlerArgs): PreparedArguments {\n    const statusCode = getStatusCode(error);\n    const representation = this.toRepresentation(error, statusCode);\n    const identifier = { path: representation.metadata.identifier.value };\n    return { statusCode, conversionArgs: { identifier, representation, preferences }};\n  }\n\n  /**\n   * Creates a ResponseDescription based on the Representation.\n   */\n  private createResponse(statusCode: number, converted: Representation): ResponseDescription {\n    return {\n      statusCode,\n      metadata: converted.metadata,\n      data: converted.data,\n    };\n  }\n\n  /**\n   * Creates a Representation based on the given error.\n   * Content type will be internal/error.\n   * The status code is used for metadata.\n   */\n  private toRepresentation(error: Error, statusCode: number): Representation {\n    const metadata = new RepresentationMetadata(INTERNAL_ERROR);\n    metadata.add(HTTP.terms.statusCodeNumber, toLiteral(statusCode, XSD.terms.integer));\n\n    if (!this.showStackTrace) {\n      delete error.stack;\n    }\n\n    return new BasicRepresentation([ error ], metadata, false);\n  }\n}\n"]}