{"version":3,"file":"BasicResponseWriter.js","sourceRoot":"","sources":["../../../src/http/output/BasicResponseWriter.ts"],"names":[],"mappings":";;;AAAA,mDAAqD;AAErD,4EAAgF;AAChF,uFAAoF;AACpF,sDAAmD;AAGnD,qDAAkD;AAElD;;GAEG;AACH,MAAa,mBAAoB,SAAQ,+BAAc;IAIrD,YAAmB,cAA8B;QAC/C,KAAK,EAAE,CAAC;QAJS,WAAM,GAAG,sBAAY,CAAC,IAAI,CAAC,CAAC;QAK7C,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;IACvC,CAAC;IAEM,KAAK,CAAC,SAAS,CAAC,KAA8D;;QACnF,MAAM,WAAW,GAAG,MAAA,KAAK,CAAC,MAAM,CAAC,QAAQ,0CAAE,WAAW,CAAC;QACvD,IAAI,sCAAqB,CAAC,WAAW,CAAC,EAAE;YACtC,MAAM,IAAI,iDAAuB,CAAC,8CAA8C,WAAW,EAAE,CAAC,CAAC;SAChG;IACH,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,KAA8D;QAChF,IAAI,KAAK,CAAC,MAAM,CAAC,QAAQ,EAAE;YACzB,MAAM,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,EAAE,QAAQ,EAAE,KAAK,CAAC,QAAQ,EAAE,QAAQ,EAAE,KAAK,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC;SACrG;QAED,KAAK,CAAC,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;QAElD,IAAI,KAAK,CAAC,MAAM,CAAC,IAAI,EAAE;YACrB,MAAM,IAAI,GAAG,uBAAU,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,QAAQ,CAAC,CAAC;YAC3D,IAAI,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,KAAK,EAAQ,EAAE;gBAC/B,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,+CAA+C,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;YACpF,CAAC,CAAC,CAAC;SACJ;aAAM;YACL,0EAA0E;YAC1E,KAAK,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC;SACtB;IACH,CAAC;CACF;AAjCD,kDAiCC","sourcesContent":["import { getLoggerFor } from '../../logging/LogUtil';\nimport type { HttpResponse } from '../../server/HttpResponse';\nimport { isInternalContentType } from '../../storage/conversion/ConversionUtil';\nimport { NotImplementedHttpError } from '../../util/errors/NotImplementedHttpError';\nimport { pipeSafely } from '../../util/StreamUtil';\nimport type { MetadataWriter } from './metadata/MetadataWriter';\nimport type { ResponseDescription } from './response/ResponseDescription';\nimport { ResponseWriter } from './ResponseWriter';\n\n/**\n * Writes to an {@link HttpResponse} based on the incoming {@link ResponseDescription}.\n */\nexport class BasicResponseWriter extends ResponseWriter {\n  protected readonly logger = getLoggerFor(this);\n  private readonly metadataWriter: MetadataWriter;\n\n  public constructor(metadataWriter: MetadataWriter) {\n    super();\n    this.metadataWriter = metadataWriter;\n  }\n\n  public async canHandle(input: { response: HttpResponse; result: ResponseDescription }): Promise<void> {\n    const contentType = input.result.metadata?.contentType;\n    if (isInternalContentType(contentType)) {\n      throw new NotImplementedHttpError(`Cannot serialize the internal content type ${contentType}`);\n    }\n  }\n\n  public async handle(input: { response: HttpResponse; result: ResponseDescription }): Promise<void> {\n    if (input.result.metadata) {\n      await this.metadataWriter.handleSafe({ response: input.response, metadata: input.result.metadata });\n    }\n\n    input.response.writeHead(input.result.statusCode);\n\n    if (input.result.data) {\n      const pipe = pipeSafely(input.result.data, input.response);\n      pipe.on('error', (error): void => {\n        this.logger.error(`Writing to HttpResponse failed with message ${error.message}`);\n      });\n    } else {\n      // If there is input data the response will end once the input stream ends\n      input.response.end();\n    }\n  }\n}\n"]}