{"version":3,"file":"RawBodyParser.js","sourceRoot":"","sources":["../../../../src/http/input/body/RawBodyParser.ts"],"names":[],"mappings":";;;AAAA,sDAAwD;AACxD,kFAA+E;AAC/E,kFAA+E;AAG/E,6CAA0C;AAE1C;;GAEG;AACH,MAAa,aAAc,SAAQ,uBAAU;IAA7C;;QACqB,WAAM,GAAG,sBAAY,CAAC,IAAI,CAAC,CAAC;IA6BjD,CAAC;IA3BC,0EAA0E;IAC1E,iFAAiF;IAC1E,KAAK,CAAC,MAAM,CAAC,EAAE,OAAO,EAAE,QAAQ,EAAkB;QACvD,MAAM,EACJ,cAAc,EAAE,WAAW,EAC3B,gBAAgB,EAAE,aAAa,EAC/B,mBAAmB,EAAE,gBAAgB,GACtC,GAAG,OAAO,CAAC,OAAO,CAAC;QAEpB,6DAA6D;QAC7D,qEAAqE;QACrE,mEAAmE;QACnE,uEAAuE;QACvE,IAAI,CAAC,CAAC,aAAa,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,gBAAgB,EAAE;YAC1F,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,uFAAuF,CAAC,CAAC;YAC3G,OAAO,IAAI,yCAAmB,CAAC,EAAE,EAAE,QAAQ,CAAC,CAAC;SAC9C;QAED,gFAAgF;QAChF,qFAAqF;QACrF,IAAI,CAAC,WAAW,EAAE;YAChB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,qDAAqD,CAAC,CAAC;YACxE,MAAM,IAAI,yCAAmB,CAAC,4DAA4D,CAAC,CAAC;SAC7F;QAED,OAAO,IAAI,yCAAmB,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;IACpD,CAAC;CACF;AA9BD,sCA8BC","sourcesContent":["import { getLoggerFor } from '../../../logging/LogUtil';\nimport { BadRequestHttpError } from '../../../util/errors/BadRequestHttpError';\nimport { BasicRepresentation } from '../../representation/BasicRepresentation';\nimport type { Representation } from '../../representation/Representation';\nimport type { BodyParserArgs } from './BodyParser';\nimport { BodyParser } from './BodyParser';\n\n/**\n * Converts incoming {@link HttpRequest} to a Representation without any further parsing.\n */\nexport class RawBodyParser extends BodyParser {\n  protected readonly logger = getLoggerFor(this);\n\n  // Note that the only reason this is a union is in case the body is empty.\n  // If this check gets moved away from the BodyParsers this union could be removed\n  public async handle({ request, metadata }: BodyParserArgs): Promise<Representation> {\n    const {\n      'content-type': contentType,\n      'content-length': contentLength,\n      'transfer-encoding': transferEncoding,\n    } = request.headers;\n\n    // RFC7230, ยง3.3: The presence of a message body in a request\n    // is signaled by a Content-Length or Transfer-Encoding header field.\n    // While clients SHOULD NOT use use a Content-Length header on GET,\n    // some still provide a Content-Length of 0 (but without Content-Type).\n    if ((!contentLength || (/^0+$/u.test(contentLength) && !contentType)) && !transferEncoding) {\n      this.logger.debug('HTTP request does not have a body, or its empty body is missing a Content-Type header');\n      return new BasicRepresentation([], metadata);\n    }\n\n    // While RFC7231 allows treating a body without content type as an octet stream,\n    // such an omission likely signals a mistake, so force clients to make this explicit.\n    if (!contentType) {\n      this.logger.warn('HTTP request has a body, but no Content-Type header');\n      throw new BadRequestHttpError('HTTP request body was passed without a Content-Type header');\n    }\n\n    return new BasicRepresentation(request, metadata);\n  }\n}\n"]}