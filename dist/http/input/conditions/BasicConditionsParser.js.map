{"version":3,"file":"BasicConditionsParser.js","sourceRoot":"","sources":["../../../../src/http/input/conditions/BasicConditionsParser.ts"],"names":[],"mappings":";;;AAAA,sDAAwD;AAGxD,sEAAmE;AAEnE,yDAAsD;AAEtD;;;;;;;;GAQG;AACH,MAAa,qBAAsB,SAAQ,mCAAgB;IAA3D;;QACqB,WAAM,GAAG,sBAAY,CAAC,IAAI,CAAC,CAAC;IA6CjD,CAAC;IA3CQ,KAAK,CAAC,MAAM,CAAC,OAAoB;QACtC,MAAM,OAAO,GAA2B;YACtC,WAAW,EAAE,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,UAAU,CAAC;YACrD,cAAc,EAAE,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,eAAe,CAAC;SAC9D,CAAC;QAEF,kGAAkG;QAClG,gHAAgH;QAChH,IAAI,CAAC,OAAO,CAAC,cAAc,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,KAAK,IAAI,OAAO,CAAC,MAAM,KAAK,MAAM,CAAC,EAAE;YACtF,OAAO,CAAC,aAAa,GAAG,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,mBAAmB,CAAC,CAAC;SAC5E;QAED,+FAA+F;QAC/F,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE;YACxB,OAAO,CAAC,eAAe,GAAG,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,qBAAqB,CAAC,CAAC;SAChF;QAED,0FAA0F;QAC1F,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,mCAAmC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;QAChF,IAAI,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC,GAAG,EAAW,EAAE,CAAC,OAAO,GAAG,KAAK,WAAW,CAAC,EAAE;YAC7E,OAAO,IAAI,iCAAe,CAAC,OAAO,CAAC,CAAC;SACrC;IACH,CAAC;IAED;;;OAGG;IACK,eAAe,CAAC,OAAoB,EAAE,MAAmD;QAC/F,MAAM,SAAS,GAAG,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QAC1C,IAAI,SAAS,EAAE;YACb,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;YACxC,OAAO,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,SAAS,CAAC,CAAC;SAClE;IACH,CAAC;IAED;;;OAGG;IACK,cAAc,CAAC,OAAoB,EAAE,MAAoC;;QAC/E,OAAO,MAAA,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,0CAAE,IAAI,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC;IAC3D,CAAC;CACF;AA9CD,sDA8CC","sourcesContent":["import { getLoggerFor } from '../../../logging/LogUtil';\nimport type { HttpRequest } from '../../../server/HttpRequest';\nimport type { BasicConditionsOptions } from '../../../storage/BasicConditions';\nimport { BasicConditions } from '../../../storage/BasicConditions';\nimport type { Conditions } from '../../../storage/Conditions';\nimport { ConditionsParser } from './ConditionsParser';\n\n/**\n * Creates a Conditions object based on the the following headers:\n *  - If-Modified-Since\n *  - If-Unmodified-Since\n *  - If-Match\n *  - If-None-Match\n *\n * Implementation based on RFC7232\n */\nexport class BasicConditionsParser extends ConditionsParser {\n  protected readonly logger = getLoggerFor(this);\n\n  public async handle(request: HttpRequest): Promise<Conditions | undefined> {\n    const options: BasicConditionsOptions = {\n      matchesETag: this.parseTagHeader(request, 'if-match'),\n      notMatchesETag: this.parseTagHeader(request, 'if-none-match'),\n    };\n\n    // A recipient MUST ignore If-Modified-Since if the request contains an If-None-Match header field\n    // A recipient MUST ignore the If-Modified-Since header field ... if the request method is neither GET nor HEAD.\n    if (!options.notMatchesETag && (request.method === 'GET' || request.method === 'HEAD')) {\n      options.modifiedSince = this.parseDateHeader(request, 'if-modified-since');\n    }\n\n    // A recipient MUST ignore If-Unmodified-Since if the request contains an If-Match header field\n    if (!options.matchesETag) {\n      options.unmodifiedSince = this.parseDateHeader(request, 'if-unmodified-since');\n    }\n\n    // Only return a Conditions object if there is at least one condition; undefined otherwise\n    this.logger.debug(`Found the following conditions: ${JSON.stringify(options)}`);\n    if (Object.values(options).some((val): boolean => typeof val !== 'undefined')) {\n      return new BasicConditions(options);\n    }\n  }\n\n  /**\n   * Converts a request header containing a datetime string to an actual Date object.\n   * Undefined if there is no value for the given header name.\n   */\n  private parseDateHeader(request: HttpRequest, header: 'if-modified-since' | 'if-unmodified-since'): Date | undefined {\n    const headerVal = request.headers[header];\n    if (headerVal) {\n      const timestamp = Date.parse(headerVal);\n      return Number.isNaN(timestamp) ? undefined : new Date(timestamp);\n    }\n  }\n\n  /**\n   * Converts a request header containing ETags to an array of ETags.\n   * Undefined if there is no value for the given header name.\n   */\n  private parseTagHeader(request: HttpRequest, header: 'if-match' | 'if-none-match'): string[] | undefined {\n    return request.headers[header]?.trim().split(/\\s*,\\s*/u);\n  }\n}\n"]}