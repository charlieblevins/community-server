{"version":3,"file":"LinkRelParser.js","sourceRoot":"","sources":["../../../../src/http/input/metadata/LinkRelParser.ts"],"names":[],"mappings":";;;AACA,2BAAiC;AACjC,sDAAwD;AAExD,yDAAkG;AAElG,qDAAkD;AAClD,IAAO,SAAS,GAAG,gBAAW,CAAC,SAAS,CAAC;AAEzC;;GAEG;AACH,MAAa,aAAc,SAAQ,+BAAc;IAK/C,YAAmB,UAAkC;QACnD,KAAK,EAAE,CAAC;QALS,WAAM,GAAG,sBAAY,CAAC,IAAI,CAAC,CAAC;QAM7C,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,WAAW,CAClC,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,CAAE,MAAM,EAAE,GAAG,CAAE,EAAuB,EAAE,CAAC,CAAE,MAAM,EAAE,SAAS,CAAC,GAAG,CAAC,CAAE,CAAC,CACrG,CAAC;IACJ,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,KAAiE;;QACnF,MAAM,IAAI,GAAG,MAAA,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,mCAAI,EAAE,CAAC;QAC9C,MAAM,OAAO,GAAa,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAE,IAAI,CAAE,CAAC;QAChE,KAAK,MAAM,KAAK,IAAI,OAAO,EAAE;YAC3B,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,KAAK,CAAC,QAAQ,CAAC,CAAC;SACvC;IACH,CAAC;IAES,SAAS,CAAC,SAAiB,EAAE,QAAgC;QACrE,MAAM,EAAE,MAAM,EAAE,YAAY,EAAE,GAAG,mCAAsB,CAAC,SAAS,CAAC,CAAC;QACnE,KAAK,MAAM,IAAI,IAAI,0BAAa,CAAC,MAAM,CAAC,EAAE;YACxC,MAAM,CAAE,IAAI,EAAE,GAAG,UAAU,CAAE,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;YACvD,IAAI,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;gBAC7B,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,uBAAuB,IAAI,GAAG,CAAC,CAAC;gBACjD,SAAS;aACV;YACD,KAAK,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,4BAAe,CAAC,UAAU,EAAE,YAAY,CAAC,EAAE;gBACvE,IAAI,IAAI,KAAK,KAAK,IAAI,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE;oBAC5C,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;iBACpE;aACF;SACF;IACH,CAAC;CACF;AAnCD,sCAmCC","sourcesContent":["import type { NamedNode } from '@rdfjs/types';\nimport { DataFactory } from 'n3';\nimport { getLoggerFor } from '../../../logging/LogUtil';\nimport type { HttpRequest } from '../../../server/HttpRequest';\nimport { parseParameters, splitAndClean, transformQuotedStrings } from '../../../util/HeaderUtil';\nimport type { RepresentationMetadata } from '../../representation/RepresentationMetadata';\nimport { MetadataParser } from './MetadataParser';\nimport namedNode = DataFactory.namedNode;\n\n/**\n * Parses Link headers with a specific `rel` value and adds them as metadata with the given predicate.\n */\nexport class LinkRelParser extends MetadataParser {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly linkRelMap: Record<string, NamedNode>;\n\n  public constructor(linkRelMap: Record<string, string>) {\n    super();\n    this.linkRelMap = Object.fromEntries(\n      Object.entries(linkRelMap).map(([ header, uri ]): [string, NamedNode] => [ header, namedNode(uri) ]),\n    );\n  }\n\n  public async handle(input: { request: HttpRequest; metadata: RepresentationMetadata }): Promise<void> {\n    const link = input.request.headers.link ?? [];\n    const entries: string[] = Array.isArray(link) ? link : [ link ];\n    for (const entry of entries) {\n      this.parseLink(entry, input.metadata);\n    }\n  }\n\n  protected parseLink(linkEntry: string, metadata: RepresentationMetadata): void {\n    const { result, replacements } = transformQuotedStrings(linkEntry);\n    for (const part of splitAndClean(result)) {\n      const [ link, ...parameters ] = part.split(/\\s*;\\s*/u);\n      if (/^[^<]|[^>]$/u.test(link)) {\n        this.logger.warn(`Invalid link header ${part}.`);\n        continue;\n      }\n      for (const { name, value } of parseParameters(parameters, replacements)) {\n        if (name === 'rel' && this.linkRelMap[value]) {\n          metadata.add(this.linkRelMap[value], namedNode(link.slice(1, -1)));\n        }\n      }\n    }\n  }\n}\n"]}