{"version":3,"file":"ContentTypeParser.js","sourceRoot":"","sources":["../../../../src/http/input/metadata/ContentTypeParser.ts"],"names":[],"mappings":";;;AACA,yDAA4D;AAE5D,qDAAkD;AAElD;;;GAGG;AACH,MAAa,iBAAkB,SAAQ,+BAAc;IAC5C,KAAK,CAAC,MAAM,CAAC,KAAiE;QACnF,MAAM,WAAW,GAAG,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC;QAC1D,IAAI,WAAW,EAAE;YACf,KAAK,CAAC,QAAQ,CAAC,WAAW,GAAG,6BAAgB,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC;SACjE;IACH,CAAC;CACF;AAPD,8CAOC","sourcesContent":["import type { HttpRequest } from '../../../server/HttpRequest';\nimport { parseContentType } from '../../../util/HeaderUtil';\nimport type { RepresentationMetadata } from '../../representation/RepresentationMetadata';\nimport { MetadataParser } from './MetadataParser';\n\n/**\n * Parser for the `content-type` header.\n * Currently only stores the media type and ignores other parameters such as charset.\n */\nexport class ContentTypeParser extends MetadataParser {\n  public async handle(input: { request: HttpRequest; metadata: RepresentationMetadata }): Promise<void> {\n    const contentType = input.request.headers['content-type'];\n    if (contentType) {\n      input.metadata.contentType = parseContentType(contentType).type;\n    }\n  }\n}\n"]}