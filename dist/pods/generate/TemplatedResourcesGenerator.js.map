{"version":3,"file":"TemplatedResourcesGenerator.js","sourceRoot":"","sources":["../../../src/pods/generate/TemplatedResourcesGenerator.ts"],"names":[],"mappings":"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","sourcesContent":["import { createReadStream, promises as fsPromises } from 'fs';\nimport type { Readable } from 'stream';\nimport { Parser } from 'n3';\nimport { BasicRepresentation } from '../../http/representation/BasicRepresentation';\nimport { RepresentationMetadata } from '../../http/representation/RepresentationMetadata';\nimport type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport type {\n  FileIdentifierMapper,\n  FileIdentifierMapperFactory,\n  ResourceLink,\n} from '../../storage/mapping/FileIdentifierMapper';\nimport { TEXT_TURTLE } from '../../util/ContentTypes';\nimport { guardStream } from '../../util/GuardedStream';\nimport type { Guarded } from '../../util/GuardedStream';\nimport { joinFilePath, isContainerIdentifier, resolveAssetPath } from '../../util/PathUtil';\nimport { guardedStreamFrom, readableToString } from '../../util/StreamUtil';\nimport type { TemplateEngine } from '../../util/templates/TemplateEngine';\nimport type { Resource, ResourcesGenerator } from './ResourcesGenerator';\nimport Dict = NodeJS.Dict;\n\ninterface TemplateResourceLink extends ResourceLink {\n  isTemplate: boolean;\n}\n\n/**\n * Generates resources by making use of a template engine.\n * The template folder structure will be kept.\n * Folders will be interpreted as containers and files as documents.\n * A FileIdentifierMapper will be used to generate identifiers that correspond to the relative structure.\n *\n * A relative `templateFolder` is resolved relative to cwd,\n * unless it's preceded by `@css:`, e.g. `@css:foo/bar`.\n */\nexport class TemplatedResourcesGenerator implements ResourcesGenerator {\n  private readonly templateFolder: string;\n  private readonly factory: FileIdentifierMapperFactory;\n  private readonly templateEngine: TemplateEngine;\n  private readonly templateExtension: string;\n\n  /**\n   * A mapper is needed to convert the template file paths to identifiers relative to the given base identifier.\n   *\n   * @param templateFolder - Folder where the templates are located.\n   * @param factory - Factory used to generate mapper relative to the base identifier.\n   * @param templateEngine - Template engine for generating the resources.\n   * @param templateExtension - The extension of files that need to be interpreted as templates.\n   *                            Will be removed to generate the identifier.\n   */\n  public constructor(templateFolder: string, factory: FileIdentifierMapperFactory, templateEngine: TemplateEngine,\n    templateExtension = '.hbs') {\n    this.templateFolder = resolveAssetPath(templateFolder);\n    this.factory = factory;\n    this.templateEngine = templateEngine;\n    this.templateExtension = templateExtension;\n  }\n\n  public async* generate(location: ResourceIdentifier, options: Dict<string>): AsyncIterable<Resource> {\n    const mapper = await this.factory.create(location.path, this.templateFolder);\n    const folderLink = await this.toTemplateLink(this.templateFolder, mapper);\n    yield* this.processFolder(folderLink, mapper, options);\n  }\n\n  /**\n   * Generates results for all entries in the given folder, including the folder itself.\n   */\n  private async* processFolder(folderLink: TemplateResourceLink, mapper: FileIdentifierMapper, options: Dict<string>):\n  AsyncIterable<Resource> {\n    // Group resource links with their corresponding metadata links\n    const links = await this.groupLinks(folderLink.filePath, mapper);\n\n    // Remove root metadata if it exists\n    const metaLink = links[folderLink.identifier.path]?.meta;\n    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n    delete links[folderLink.identifier.path];\n\n    yield this.generateResource(folderLink, options, metaLink);\n\n    for (const { link, meta } of Object.values(links)) {\n      if (isContainerIdentifier(link.identifier)) {\n        yield* this.processFolder(link, mapper, options);\n      } else {\n        yield this.generateResource(link, options, meta);\n      }\n    }\n  }\n\n  /**\n   * Creates a TemplateResourceLink for the given filePath.\n   * The identifier will be based on the file path stripped from the template extension,\n   * but the filePath parameter will still point to the original file.\n   */\n  private async toTemplateLink(filePath: string, mapper: FileIdentifierMapper): Promise<TemplateResourceLink> {\n    const stats = await fsPromises.lstat(filePath);\n\n    // Slice the template extension from the filepath for correct identifier generation\n    const isTemplate = filePath.endsWith(this.templateExtension);\n    const slicedPath = isTemplate ? filePath.slice(0, -this.templateExtension.length) : filePath;\n    const link = await mapper.mapFilePathToUrl(slicedPath, stats.isDirectory());\n    // We still need the original file path for disk reading though\n    return {\n      ...link,\n      filePath,\n      isTemplate,\n    };\n  }\n\n  /**\n   * Generates TemplateResourceLinks for each entry in the given folder\n   * and combines the results so resources and their metadata are grouped together.\n   */\n  private async groupLinks(folderPath: string, mapper: FileIdentifierMapper):\n  Promise<Record<string, { link: TemplateResourceLink; meta?: TemplateResourceLink }>> {\n    const files = await fsPromises.readdir(folderPath);\n    const links: Record<string, { link: TemplateResourceLink; meta?: TemplateResourceLink }> = { };\n    for (const name of files) {\n      const link = await this.toTemplateLink(joinFilePath(folderPath, name), mapper);\n      const { path } = link.identifier;\n      links[path] = Object.assign(links[path] || {}, link.isMetadata ? { meta: link } : { link });\n    }\n    return links;\n  }\n\n  /**\n   * Generates a Resource object for the given ResourceLink.\n   * In the case of documents the corresponding template will be used.\n   * If a ResourceLink of metadata is provided the corresponding data will be added as metadata.\n   */\n  private async generateResource(link: TemplateResourceLink, options: Dict<string>, metaLink?: TemplateResourceLink):\n  Promise<Resource> {\n    let data: Guarded<Readable> | undefined;\n    const metadata = new RepresentationMetadata(link.identifier);\n\n    // Read file if it is not a container\n    if (isContainerIdentifier(link.identifier)) {\n      // Containers need to be an RDF type\n      metadata.contentType = TEXT_TURTLE;\n    } else {\n      data = await this.processFile(link, options);\n      metadata.contentType = link.contentType;\n    }\n\n    // Add metadata from meta file if there is one\n    if (metaLink) {\n      const rawMetadata = await this.generateMetadata(metaLink, options);\n      metadata.addQuads(rawMetadata.quads());\n    }\n\n    return {\n      identifier: link.identifier,\n      representation: new BasicRepresentation(data ?? [], metadata),\n    };\n  }\n\n  /**\n   * Generates a RepresentationMetadata using the given template.\n   */\n  private async generateMetadata(metaLink: TemplateResourceLink, options: Dict<string>):\n  Promise<RepresentationMetadata> {\n    const metadata = new RepresentationMetadata(metaLink.identifier);\n\n    const data = await this.processFile(metaLink, options);\n    const parser = new Parser({ format: metaLink.contentType, baseIRI: metaLink.identifier.path });\n    const quads = parser.parse(await readableToString(data));\n    metadata.addQuads(quads);\n\n    return metadata;\n  }\n\n  /**\n   * Creates a read stream from the file and applies the template if necessary.\n   */\n  private async processFile(link: TemplateResourceLink, options: Dict<string>): Promise<Guarded<Readable>> {\n    if (link.isTemplate) {\n      const rendered = await this.templateEngine.render(options, { templateFile: link.filePath });\n      return guardedStreamFrom(rendered);\n    }\n    return guardStream(createReadStream(link.filePath));\n  }\n}\n"]}