{"version":3,"file":"TokenOwnershipValidator.js","sourceRoot":"","sources":["../../../src/identity/ownership/TokenOwnershipValidator.ts"],"names":[],"mappings":";;;AACA,2BAAiC;AACjC,+BAA0B;AAC1B,mDAAqD;AAGrD,+EAA4E;AAC5E,oDAAoD;AACpD,0DAAgD;AAChD,6DAA0D;AAC1D,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,IAAI,EAAE,GAAG,gBAAW,CAAC;AAEjD;;;GAGG;AACH,MAAa,uBAAwB,SAAQ,uCAAkB;IAO7D,YAAmB,SAAkC,EAAE,OAAwC,EAAE,UAAU,GAAG,EAAE;QAC9G,KAAK,EAAE,CAAC;QAPS,WAAM,GAAG,sBAAY,CAAC,IAAI,CAAC,CAAC;QAQ7C,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,kCAAkC;QAClC,IAAI,CAAC,UAAU,GAAG,UAAU,GAAG,EAAE,GAAG,IAAI,CAAC;IAC3C,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,EAAE,KAAK,EAAqB;QAC9C,MAAM,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QACpC,IAAI,KAAK,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAExC,4DAA4D;QAC5D,IAAI,CAAC,KAAK,EAAE;YACV,KAAK,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;YAC7B,MAAM,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;YACpD,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;SAC/B;QAED,gDAAgD;QAChD,IAAI,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,CAAC,EAAE;YACtC,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;SAC/B;QACD,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,yBAAyB,KAAK,EAAE,CAAC,CAAC;QACpD,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;IACjC,CAAC;IAED;;OAEG;IACK,WAAW,CAAC,KAAa;QAC/B,OAAO,iBAAiB,KAAK,EAAE,CAAC;IAClC,CAAC;IAED;;OAEG;IACK,aAAa;QACnB,OAAO,SAAE,EAAE,CAAC;IACd,CAAC;IAED;;OAEG;IACK,KAAK,CAAC,QAAQ,CAAC,KAAa,EAAE,KAAa;QACjD,MAAM,cAAc,GAAG,MAAM,wBAAY,CAAC,KAAK,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;QACjE,MAAM,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE,oBAAK,CAAC,KAAK,CAAC,2BAA2B,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;QACrG,IAAI,KAAK,EAAE,MAAM,IAAI,IAAI,cAAc,CAAC,IAAI,EAAE;YAC5C,MAAM,MAAM,GAAG,IAAY,CAAC;YAC5B,IAAI,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,EAAE;gBAC/B,cAAc,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;gBAC9B,OAAO,IAAI,CAAC;aACb;SACF;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;OAEG;IACK,UAAU,CAAC,KAAa,EAAE,KAAa;QAC7C,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,mCAAmC,KAAK,EAAE,CAAC,CAAC;QAC9D,MAAM,YAAY,GAAG;YACnB,+BAA+B;YAC/B,2BAA2B;YAC3B,IAAI,KAAK,MAAM,oBAAK,CAAC,2BAA2B,MAAM,KAAK,IAAI;YAC/D,4BAA4B,KAAK,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;YACvD,6BAA6B;YAC7B,oDAAoD;SACrD,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACZ,MAAM,OAAO,GAAG,EAAE,IAAI,EAAE,IAAI,KAAK,MAAM,oBAAK,CAAC,2BAA2B,MAAM,KAAK,IAAI,EAAE,CAAC;QAC1F,MAAM,IAAI,yCAAmB,CAAC,YAAY,EAAE,EAAE,OAAO,EAAE,CAAC,CAAC;IAC3D,CAAC;CACF;AAhFD,0DAgFC","sourcesContent":["import type { Quad } from 'n3';\nimport { DataFactory } from 'n3';\nimport { v4 } from 'uuid';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport type { RepresentationConverter } from '../../storage/conversion/RepresentationConverter';\nimport type { ExpiringStorage } from '../../storage/keyvalue/ExpiringStorage';\nimport { BadRequestHttpError } from '../../util/errors/BadRequestHttpError';\nimport { fetchDataset } from '../../util/FetchUtil';\nimport { SOLID } from '../../util/Vocabularies';\nimport { OwnershipValidator } from './OwnershipValidator';\nconst { literal, namedNode, quad } = DataFactory;\n\n/**\n * Validates ownership of a WebId by seeing if a specific triple can be added.\n * `expiration` parameter is how long the token should be valid in minutes.\n */\nexport class TokenOwnershipValidator extends OwnershipValidator {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly converter: RepresentationConverter;\n  private readonly storage: ExpiringStorage<string, string>;\n  private readonly expiration: number;\n\n  public constructor(converter: RepresentationConverter, storage: ExpiringStorage<string, string>, expiration = 30) {\n    super();\n    this.converter = converter;\n    this.storage = storage;\n    // Convert minutes to milliseconds\n    this.expiration = expiration * 60 * 1000;\n  }\n\n  public async handle({ webId }: { webId: string }): Promise<void> {\n    const key = this.getTokenKey(webId);\n    let token = await this.storage.get(key);\n\n    // No reason to fetch the WebId if we don't have a token yet\n    if (!token) {\n      token = this.generateToken();\n      await this.storage.set(key, token, this.expiration);\n      this.throwError(webId, token);\n    }\n\n    // Verify if the token can be found in the WebId\n    if (!await this.hasToken(webId, token)) {\n      this.throwError(webId, token);\n    }\n    this.logger.debug(`Verified ownership of ${webId}`);\n    await this.storage.delete(key);\n  }\n\n  /**\n   * Creates a key to use with the token storage.\n   */\n  private getTokenKey(webId: string): string {\n    return `ownershipToken${webId}`;\n  }\n\n  /**\n   * Generates a random verification token;\n   */\n  private generateToken(): string {\n    return v4();\n  }\n\n  /**\n   * Fetches data from the WebID to determine if the token is present.\n   */\n  private async hasToken(webId: string, token: string): Promise<boolean> {\n    const representation = await fetchDataset(webId, this.converter);\n    const expectedQuad = quad(namedNode(webId), SOLID.terms.oidcIssuerRegistrationToken, literal(token));\n    for await (const data of representation.data) {\n      const triple = data as Quad;\n      if (triple.equals(expectedQuad)) {\n        representation.data.destroy();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Throws an error containing the description of which triple is needed for verification.\n   */\n  private throwError(webId: string, token: string): never {\n    this.logger.debug(`No verification token found for ${webId}`);\n    const errorMessage = [\n      'Verification token not found.',\n      'Please add the RDF triple',\n      `<${webId}> <${SOLID.oidcIssuerRegistrationToken}> \"${token}\".`,\n      `to the WebID document at ${webId.replace(/#.*/u, '')}`,\n      'to prove it belongs to you.',\n      'You can remove this triple again after validation.',\n    ].join(' ');\n    const details = { quad: `<${webId}> <${SOLID.oidcIssuerRegistrationToken}> \"${token}\".` };\n    throw new BadRequestHttpError(errorMessage, { details });\n  }\n}\n"]}