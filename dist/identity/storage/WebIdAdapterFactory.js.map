{"version":3,"file":"WebIdAdapterFactory.js","sourceRoot":"","sources":["../../../src/identity/storage/WebIdAdapterFactory.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Response } from 'cross-fetch';\nimport { fetch } from 'cross-fetch';\nimport type { Quad } from 'n3';\nimport type { Adapter, AdapterPayload } from 'oidc-provider';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport type { RepresentationConverter } from '../../storage/conversion/RepresentationConverter';\nimport { createErrorMessage } from '../../util/errors/ErrorUtil';\nimport { fetchDataset } from '../../util/FetchUtil';\nimport { OIDC } from '../../util/Vocabularies';\nimport type { AdapterFactory } from './AdapterFactory';\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\n/**\n * This {@link Adapter} redirects the `find` call to its source adapter.\n * In case no client data was found in the source for the given WebId,\n * this class will do an HTTP GET request to that WebId.\n * If a valid `solid:oidcRegistration` triple is found there,\n * that data will be returned instead.\n */\nexport class WebIdAdapter implements Adapter {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly name: string;\n  private readonly source: Adapter;\n  private readonly converter: RepresentationConverter;\n\n  public constructor(name: string, source: Adapter, converter: RepresentationConverter) {\n    this.name = name;\n    this.source = source;\n    this.converter = converter;\n  }\n\n  public async upsert(id: string, payload: AdapterPayload, expiresIn: number): Promise<void> {\n    return this.source.upsert(id, payload, expiresIn);\n  }\n\n  public async find(id: string): Promise<AdapterPayload | void> {\n    let payload = await this.source.find(id);\n\n    // No payload is stored for the given Client ID.\n    // Try to see if valid client metadata is found at the given Client ID.\n    // The oidc-provider library will check if the redirect_uri matches an entry in the list of redirect_uris,\n    // so no extra checks are needed from our side.\n    if (!payload && this.name === 'Client' && /^https?:\\/\\/.+/u.test(id)) {\n      this.logger.debug(`Looking for payload data at ${id}`);\n      // All checks based on https://solid.github.io/authentication-panel/solid-oidc/#clientids-webid\n      if (!/^https:|^http:\\/\\/localhost(?::\\d+)?(?:\\/|$)/u.test(id)) {\n        throw new Error(`SSL is required for client_id authentication unless working locally.`);\n      }\n      const response = await fetch(id);\n      if (response.status !== 200) {\n        throw new Error(`Unable to access data at ${id}: ${await response.text()}`);\n      }\n      const data = await response.text();\n      let json: any | undefined;\n      try {\n        json = JSON.parse(data);\n        // We can only parse as simple JSON if the @context is correct\n        if (json['@context'] !== 'https://www.w3.org/ns/solid/oidc-context.jsonld') {\n          throw new Error('Invalid context');\n        }\n      } catch (error: unknown) {\n        json = undefined;\n        this.logger.debug(`Found unexpected client WebID for ${id}: ${createErrorMessage(error)}`);\n      }\n\n      if (json) {\n        // Need to make sure the document is about the id\n        if (json.client_id !== id) {\n          throw new Error('The client registration `client_id` field must match the client WebID');\n        }\n        payload = json;\n      } else {\n        // Since the WebID does not match the default JSON-LD we try to interpret it as RDF\n        payload = await this.parseRdfWebId(data, id, response);\n      }\n\n      // `token_endpoint_auth_method: 'none'` prevents oidc-provider from requiring a client_secret\n      payload = { ...payload, token_endpoint_auth_method: 'none' };\n    }\n\n    // Will also be returned if no valid client data was found above\n    return payload;\n  }\n\n  /**\n   * Parses RDF data found at a client WebID.\n   * @param data - Raw data from the WebID.\n   * @param id - The actual WebID.\n   * @param response - Response object from the request.\n   */\n  private async parseRdfWebId(data: string, id: string, response: Response): Promise<AdapterPayload> {\n    const representation = await fetchDataset(response, this.converter, data);\n\n    // Find the valid redirect URIs\n    const redirectUris: string[] = [];\n    for await (const entry of representation.data) {\n      const triple = entry as Quad;\n      if (triple.predicate.equals(OIDC.terms.redirect_uris)) {\n        redirectUris.push(triple.object.value);\n      }\n    }\n\n    return {\n      client_id: id,\n      redirect_uris: redirectUris,\n    };\n  }\n\n  public async findByUserCode(userCode: string): Promise<AdapterPayload | void> {\n    return this.source.findByUserCode(userCode);\n  }\n\n  public async findByUid(uid: string): Promise<AdapterPayload | void> {\n    return this.source.findByUid(uid);\n  }\n\n  public async destroy(id: string): Promise<void> {\n    return this.source.destroy(id);\n  }\n\n  public async revokeByGrantId(grantId: string): Promise<void> {\n    return this.source.revokeByGrantId(grantId);\n  }\n\n  public async consume(id: string): Promise<void> {\n    return this.source.consume(id);\n  }\n}\n\nexport class WebIdAdapterFactory implements AdapterFactory {\n  private readonly source: AdapterFactory;\n  private readonly converter: RepresentationConverter;\n\n  public constructor(source: AdapterFactory, converter: RepresentationConverter) {\n    this.source = source;\n    this.converter = converter;\n  }\n\n  public createStorageAdapter(name: string): Adapter {\n    return new WebIdAdapter(name, this.source.createStorageAdapter(name), this.converter);\n  }\n}\n"]}